	SUBTTL COMMAND SCANNER
;
;THE COMMAND SCANNER IS A PSEUDO-SYNTAX MACHINE IN WHICH THE
;SO CALLED PSEUDO-OPERATIONS ARE ACTUALLY SUBROUTINE CALLS
;OR MACROS.  PRIMITIVES:

	GETSTR=PUSHJ P,RDSTR	;GET SIXBIT STRING IN "NM"
	GETOCT=PUSHJ P,RDOCT	;GET OCTAL CONSTANT IN "NM"
	GETSW=PUSHJ P,RDSW	;LOOK FOR SWITCHES
	GETCHR=AOS COMPTR	;ADVANCE SCANNING POINTER

	DEFINE MCH(A)
<	MOVE PA1,@COMPTR
	CAIE PA1,A>

;THE PRIMITIVES MCH, GETSTR, AND GETSW USE A SKIP/NO SKIP
;CONVENTION FOR RECOGNITION/NON-RECOGNITION.
;HENCE WE DEFINE SOME PSEUDO-CODES FOR
;HANDLING THIS CONVENTION:

	OPDEF FAIL [JRST]	;FAILURE ALTERNATE
	OPDEF SKP [CAIA]	;COMPULSORY SKIP

	NM==ARG
;EXEC3, PAGE 2
;THE MAIN SUBROUTINE "SCAN" ANALYZES INFORMATION TO THE LEFT
;OF THE _ OR = AND PUTS IT INTO THE BINARY AND/OR LISTING
;FILE BLOCKS.

;FIRST THOUGH, WE MUST DO A RON KRONENBERG SPECIAL,IE, A COMMAND
;PRESCAN WHICH GETS THREE ITEMS FROM THE COMMAND STRING:
;1) DOES THE COMMAND STRING CONTAIN AN = OR _?  IF NOT, DONT
;   BOTHER TO LOOK FOR BINARY OR LIST FILES.
;2) DOES THE COMMAND STRING CONTAIN ANY IMPLICIT FILE REQUESTS?
;   IF SO, SET APPROPRIATE REQUEST FLAGS.
;3) GET THE NAME OF THE LAST (SOURCE) FILE.
;AS A RESULT OF THIS PRESCAN, THE USER CAN TYPE IN:
;*(ABC)FILE<CR>
;INSTEAD OF
;*FILE/A/C,FILE_FILE
;IN FACT, HE CAN EVEN TYPE IN
;*FILE/A/B/C<CR>
;
;RAH
;
SCAN:	PUSH P,F	;PRESCAN... SAVE CURRENT EXEC FLAGS.
	PUSH P,COMPTR	;SAVE COMMAND STRING POINTER.
NXTFLD:	MOVEI ARG,SRCBLK	;USING THE STANDARD SWITCHES,
	PUSHJ P,GETNAM	;SCAN FOR A FILE NAME.
	JFCL		;DONT CARE IF NOT FOUND.
	MOVE PA1,@COMPTR	;GET TERMINAL CHARACTER.
	CAIE PA1,"+"	;IS IT A PLUS, OR,
	CAIN PA1,","	;IS IT A COMMA?
	JRST NXTFLD	;YES, GO ON WITH PRESCAN.
	CAIE PA1,"_"	;NO, IS IT _ OR =?
	CAIN PA1,"="
	JRST NRMLFM	;YES, NORMAL FORM, SET LEFT ARROW FLAG.
	CAIN PA1,"@"	;TERMINATE IN ATSIGN?
	JRST USRCCL	;THEN USER SUPPLIED CCL FILE
	PUSHJ P,CHKEOL	;NO KNOWN TERMINATOR.  END OF STRING?
	JRST BADCHR	;NO, THEN ILLEGAL.
	CPY SCNNAM,SRCBLK+FNAM	;LAST FILE... SAVE NAME FOR IMPLICIT
	TLNN F,QCCL+QCCLC+QCCLU	;ARE WE IN CCL MODE?
	JRST NOID	;NO, NO ID NEEDED.
	OUTSTR [ASCIZ /PROG: /]	;YES, OUTPUT PROGRAM NAME.
	PUSHJ P,ERRSIX	;ON CONSOLE TTY.
NOID:	POP P,COMPTR	;BINARY AND LISTING FILES.  RECOVER STRING
	POP P,PA1	;POINTER AND OLD EXEC FLAGS.
	AND F,[XWD QNLSTRQ!QNBINRQ,QNSYMRQ!QNMACRQ!QLFTARW]	;MERGE
	ANDCM PA1,[XWD QNLSTRQ!QNBINRQ,QNSYMRQ!QNMACRQ!QLFTARW]	;OLD AND NEW
	IOR F,PA1	;FLAG WORDS.  ONLY REQUEST FLAGS COULD BE
	TRZN F,QLFTARW	;MODIFIED.  LEFT ARROW SEEN?
	JRST SCNTHR	;NO, SPECIAL KRONENBERG FORM, GO DO IT.

;SCANNER PROPER:

	MOVEI ARG,BINBLK	;USING THE BINARY SWITCH TABLE,
	PUSHJ P,GETNAM	;LOOK FOR A SPECIFIER.
	JRST NOBINF	;NOT FOUND, NO BINARY FILE.
	PUSHJ P,INITBN	;FOUND, INITIALIZE BINARY FILE.
NOBINF:
	MCH <",">	;DID FIELD END IN COMMA?
	FAIL SCNCMP	;NO, NO LISTING FILE POSSIBLE.
	MOVEI ARG,LSTBLK	;YES, USING THE LISTING SWITCH
	PUSHJ P,GETNAM	;TABLE, LOOK FOR A FILE SPECIFIER.
	JRST NOLST1	;NOT FOUND.
	PUSHJ P,INITLS	;FOUND, INITIALIZE LISTING FILE.
NOLST1:
SCNCMP:	MCH "_"	;DID FIELD END IN "_"?
	CAIN PA1,"="	;NO, HOW ABOUT IN EQUALS?
	SKP		;EITHER, OK.
	JRST BADCHR	;NEITHER, BAD.
SCNTHR:	CPY COMPTR,SAVPTR	;SAVE THIS POINTER POSITION FOR PASS2.
	PJRST IMPINT	;GO DO IMPLICIT INITS AND EXIT.

NRMLFM:	TRO F,QLFTARW	;NORMAL FORM... SET LEFT ARROW FLAG AND
	JRST NXTFLD	;GO ON TO NEXT FIELD.
;EXEC3, PAGE 2A
;PROCESS USER SPECIFIED CCL FILE-- SET CCL MODE, OPEN AND LOOKUP FILE,
;RETURN TO GET NEW COMMAND LINE.
;***WARNING!!!***
;SEVERAL VICIOUS DOGS LURK HERE.  FIRST, THE STACK IS THROWN AWAY.
;SECOND, ALL PREVIOUS PARTS OF THE LINE ARE THROWN AWAY.
;
USRCCL:	SUB P,[XWD 3,3]	;CLEAR RETURN AND 2 SAVED ARG'S.
	TLOE F,QCCL+QCCLU	;ARE WE ALREADY IN USER CCL MODE?
	JRST BADCHR	;THEN REJECT FURTHER INDIRECTION.
	MOVEI ARG,CCLBLK	;GET BLOCK FOR CCL FILE AND
	MOVE T1,SCNDEV	;GET DEVICE FOR CCL FILE.
	DEVCHR T1,	;IS IT A DIRECTORY DEVICE?
	TLNN T1,DIRDEV
	JRST BADDV1	;NO, ERROR.
	PUSHJ P,MOVSCN	;MOVE SCANNER ARGUMENTS TO CCL BLOCK.
	PUSHJ P,OPNCCL	;OPEN THE CCL FILE.
	JRST NEWPRG	;GO GET A NEW LINE.
;EXEC3, PAGE 3
;GETNAM--- GET DEVICE AND FILE SPECIFIER AND SWITCHES.
;CALLING SEQUENCE...
;	MOVEI ARG,SWITCHTABLE
;	PUSHJ P,GETNAM
;	...	;NULL FILE RETURN
;	...	;NORMAL RETURN

GETNAM:	MOVEM ARG,SWTARG	;SAVE ADDRESS OF SWITCH TABLE.
	MOVSI PA1,'DSK'	;INITIALIZE FILE NAME TO 'DSK'.
	MOVEM PA1,SCNDEV
	CLEARM ,SCNNAM	;CLEAR NAME, EXTENSION, AND PROJECT#-
	CLEARM ,SCNEXT	;PROGRAMMER# WORD
	CLEARM ,SCNPJ

GLOOP:	PUSHJ P,GETBLK	;ABSORB LEADING SPACES.
	GETSTR		;LOOK FOR AN ALPHANUMERIC STRING.
	FAIL CHKSW	;NONE FOUND, MAYBE SWITCHES?
	MCH ":"		;FOUND, DID IT END IN COLON?
	FAIL NODEV	;NO.
	MOVEM NM,SCNDEV	;YES, SAVE AS DEVICE NAME.
	GETSTR		;LOOK FOR ANOTHER STRING.
	FAIL NONAME	;NOT FOUND, DEVICE HAS NO FILE, GO CHECK.

NODEV:	MOVEM NM,SCNNAM	;SAVE STRING AS FILE NAME.
	MCH "."		;DID IT END IN PERIOD?
	FAIL NOEXT	;NO, NO EXTENSION.
	AOS ,SCNEXT	;YES, SET EXPLICIT EXTENS[ON FLAG.
	GETSTR		;GET EXTENS[ON.
	FAIL NOEXT	;NOT FOUND, FORGET IT.
	HLLZM NM,SCNEXT	;FOUND, SAVE EXTENSION.

NOEXT:	MCH "["		;DID NAME OR EXTENSION END IN RIGHT BRACKET?
	FAIL NOPJ	;NO.
	GETOCT		;YES, GET PROJECT# AND SAVE.
	HRLZM NM,SCNPJ
	MCH <",">	;DID IT END IN ","?
	FAIL BADCHR	;NO, ERROR
	GETOCT		;YES, GET PROGRAMMER# AND SAVE.
	HRRM NM,SCNPJ
	MCH "]"		;DID STRING TERMINATE IN "]"?
	FAIL BADCHR	;NO, ERROR

GEXIT:	GETCHR		;GET CHARACTER TO PRIME SWITCH READDER.
NOPJ:	MCH "	 "	;FIRST, LOOK FOR ANY INTERMEDIATE SPACES
	CAIN PA1,"	"	;OR TABS.
	JRST GEXIT	;FOUND, GET NEXT CHARACTER.
	GETSW		;LOOK FOR SWITCHES.
	SKP		;NONE FOUND, EXIT.
	JRST GEXIT	;FOUND, LOOK FOR MORE.
	AOS ,(P)	;SET UP SKIP RETURN.

EMPTY:	POPJ P,		;RETURN.


NONAME:	MOVE PA1,SCNDEV	;DEVICE NAME BUT NO FILE NAME.
	DEVCHR PA1,	;GET DEVICE CHARACTERISTICS.
	TLNE PA1,DIRDEV	;IS IT A DIRECTORY DEVICE?
	JRST NONMER	;YES, ERROR, THERE MUST BE A NAME.
	JRST NOPJ	;NO, OK, EXIT.

CHKSW:	GETSW		;NO INITIAL STRING... LOOK FOR SWITCHES.
	FAIL EMPTY	;NOT FOUND, EMPTY FIELD.
	JRST GLOOP	;FOUND, TRY AGAIN.
;EXEC3, PAGE 4
;ROUTINES FOR IMPLEMENTING PRIMITIVES.
;RDSTR---	READ SIXBIT ALPHANUMERIC STRING
;RDOCT---	READ OCTAL NUMBER
;RDSW---	LOOK FOR SWITCHES
;
;RDSTR AND RDOCT ARE UNPRIMED;  THEY ASSUME THAT THEY MUST START
;BY GETTING A CHARACTER FROM THE STRING, AND THEY LEAVE THE
;SCANNING PROCESS "PRIMED", IE, WITH AN UNPROCESSED
;CHARACTER IN "TERML".  RDSW MUST BE PRIMED BEFORE CALL AND
;LEAVES THE PROCESS UNPRIMED.

RDSTR:	CLEAR NM,	;CLEAR THE OUTPUT AREA.
	MOVE PA2,[POINT 6,NM]	;SET UP BYTE PTR INTO OUTPUT AREA.

RDSLP:	GETCHR		;GET A CHARACTER.
	MOVE PA1,@COMPTR
	CAIGE PA1,"0"	;IS IT A NUMBER?
	JRST ENDSTR	;NO, END OF STRING.
	CAIG PA1,"9"
	JRST OK		;YES PACK IT IN.
	CAIL PA1,"A"	;IS IT A LETTER?
	CAILE PA1,"Z"
	JRST ENDSTR	;NO, END OF STRING.
OK:	SUBI PA1,40	;CONVERT TO SIXBIT ASCII.
	TLNE PA2,770000	;LESS THAN SIX CHARACTERS PACKED?
	IDPB PA1,PA2	;YES, SAVE CHARACTER.
	JRST RDSLP	;GET NEXT CHARACTER.

ENDSTR:	JUMPN NM,CPOPJ1	;END OF STRING... ANY OUTPUT?
			;YES, SKIP.
	POPJ P,		;NO, FAIL.

RDOCT:	CLEAR NM,	;CLEAR THE OUTPUT AREA.

RDOCTL:	GETCHR		;GET A CHARACTER.
	MOVE PA1,@COMPTR
	CAIL PA1,"0"	;IS IT AN OCTAL DIGIT?
	CAILE PA1,"7"
	POPJ P,		;NO, EXIT.
	LSH NM,3	;RESULT= RESULT*8 +DIGIT.
	ADDI NM,-"0"(PA1)
	JRST RDOCTL	;GET NEXT CHARACTER.


RDSW:	MCH <"(">	;IS OUTSTANDING CHARACTER A START OF SWITCH GROUP CHAR?
	FAIL SINGSW	;NO, LOOK FOR SINGLE SWITCH.
	PUSHJ P,LOOKSW	;LOOK FOR ONE SWITCH.
	SKP		;NOT FOUND.
	JRST .-2	;FOUND, GO LOOK FOR ANOTHER.
	GETCHR		;LOOKSW STARTS AND ENDS UNPRIMED.  GET NEXT CHAR.
	MCH <")">	;DID SWITCHES END IN )?
	FAIL BADSW+1	;NO, ERROR
	JRST CPOPJ1	;YES, EXIT OK.

SINGSW:	MCH "/"		;IS OUTSTANDING CHAR A SWITCH INDICATOR?
	POPJ P,		;NO, NO SWITCHES, FAIL.
	PUSHJ P,LOOKSW	;YES, LOOK FOR SWITCH.
	JRST BADSW	;NOT FOUND, BAD SWITCH.
	JRST CPOPJ1	;OK, EXIT.
;EXEC3, PAGE 5
;ROUTINES FOR SWITCH PROCESSING.
;LOOKSW---	LOOK FOR SWITCH (UNPRIMED)
;MATCH---	LOOK FOR SWITCH GIVEN A SWITCH TABLE.

LOOKSW:	MOVEI ARG,$USRSW	;USING FIRST THE USER'S SWITCH TABLE,
	PUSHJ P,MATCH	;TRY TO MATCH ONE SWITCH.
	SKP		;NOT FOUND.
	JRST CPOPJ1	;FOUND, TAKE SKIP RETURN.
	MOVE ARG,SWTARG	;USING IINTERNAL SWITCH TABLE,
	MOVE ARG,FSWT(ARG)	;WHICH WE GET FROM THE ARGUMENT BLOCK,
	PUSHJ P,MATCH	;TRY TO MATCH ONE SWITCH.
	POPJ P,		;NOT FOUND, FAIL.
	JRST CPOPJ1	;FAIL, TAKE SKIP RETURN.


MATCH:	SKIPN ,(ARG)	;DOES POINTER POINT TO END OF TABLE?
	POPJ P,		;YES, EXIT, NO MATCH.
	PUSH P,ARG	;NO, SAVE ARGUMENT.
	HRLI ARG,(POINT 7,)	;CONVERT ARGUMENT TO BYTE PTR.
	MOVE PA1,COMPTR	;GET BYTE POINTER TO COMMAND STRING.

MCHLP:	ILDB PA2,ARG	;GET CHARACTER FROM TABLE ENTRY.
	JUMPE PA2,MCHFND	;IF END, THEN MATCHED.
	ADDI PA1,1	;NOT END, GET NEXT CHARACTER FROM COMMAND
	CAMN PA2,(PA1)	;STRING.  MATCH?
	JRST MCHLP	;YES, CONTINUE COMPARISON.
	POP P,ARG	;NO, RECOVER ARGUMENT.
	ADDI ARG,2	;ADVANCE TO NEXT TABLE ENTRY.
	JRST MATCH

MCHFND:	MOVEM PA1,COMPTR	;SAVE ADVANCED PTR IN COMMAND STRING.
	POP P,ARG	;GET RID OF SAVED ARGUMENT.
	XCT 1(ARG)	;EXECUTE SWITCH INSTRUCTION.
	JRST CPOPJ1	;EXIT OK.


;EXEC3, PAGE 6
;ERROR MESSAGE HANDLING.  AL FATAL ERRORS ARE TREATED IN THE
;SAME WAY.  THE USER GETS THE BAD NEWS AND WE RETURN DIRECTLY TO
;THE CONTROL PACKAGE, WHICH IS LAREADY IN PROGRESS.

GERROR:	OUTSTR ERRSTR	;START BY TYPING "? "
	HRLI PA1,(POINT 7,)	;CONVERT ERROR MESSAGE ADDR
	MOVEM PA1,TMPPTR	;INTO BYTE POINTER.

ERRLP:	ILDB PA1,TMPPTR	;GET NEXT ERROR MESSAGE CHR.
	JUMPN PA1,.+3	;ZERO?
	OUTSTR CRLFLF	;YES, SPACE DOWN TWO LINES
	JRST RETURN	;AND GO BACK TO CONTROL PACKAGE.
	CAIL PA1,"1"	;NO, IF CHARACTER IS 1,2,3 OR 4,
	CAILE PA1,"4"	;SUBSTTITUTE A SPECIAL PRINTOUT.
	SKP
	XCT ERRTBL-"1"(PA1)
	OUTCHR PA1	;OTHERWISE, SIMPLY TYPE THE CHARACTER.
	JRST ERRLP

ERRTBL:	JRST PRFIELD	;SPECIAL PRINTOUTS:  1=FIELD NAME
	JRST PRDEV	;2= DEVICE NAME
	MOVE PA1,@COMPTR	;3= CURRENT CHARACTER.
	JRST PRNAME	;4= FILE NAME.

PRFIELD:	OUTSTR FFLD(ARG)	;FIELD NAME IS POINTED TO BY ARG.
	JRST ERRLP

PRDEV:	MOVE PA1,SCNDEV	;DEVICE NAME IS IN SCANNER OUTPUT AREA
	PUSHJ P,ERRSIX	;PRINT IT FOLLOWED BY A COLON.
	OUTCHR [":"]
	JRST ERRLP

PRNAME:	MOVE PA1,FDEV(ARG)	;FILE NAME... FIRST GET DEVICE FROM
	CAMN PA1,[SIXBIT /DSK/]	;FILE BLOCK
	JRST .+3	;AND PRINT IT IF NOT DEVICE "DSK".
	PUSHJ P,ERRSIX
	OUTCHR [":"]
	MOVE PA1,FNAM(ARG)	;GET THE FILE NAME AND PRINT IT.
	PUSHJ P,ERRSIX
	HLLZ PA1,FEXT(ARG)	;GET THE EXTENSION AND PRINT
	JUMPE PA1,.+3	;IT IF NOT NULL.
	OUTCHR ["."]
	PUSHJ P,ERRSIX
	JRST ERRLP

ERRSIX:	LSHC PA1-1,6	;SIXBIT PRINTER.... ISOLATE NEXT CHARACTER.
	ANDI PA1-1,77
	ADDI PA1-1,40	;CONVERT TO SEVEN BIT AND OUTPUT IT.
	OUTCHR PA1-1
	JUMPN PA1,ERRSIX	;IF MORE TO DO, DO IT!
	POPJ P,		;OTHERWISE EXIT.
;EXEC3, PAGE 7
;ERROR MESSAGES.

	DEFINE ER(A)
<	MOVEI PA1,.+2
	JRST GERROR
	ASCIZ \A\>

BADDV1:	TLZ F,QCCL+QCCLC+QCCLU	;ERROR IN OPNCCL, CLEAR FLAGS.
BADDEV:	ER <2 ILLEGAL AS 1 DEVICE>
ERLKF:	ER <LOOKUP FAILURE ON FILE 4>
ERENTR:	ER <ENTER FAILURE ON FILE 4>
ERRID:	MOVEI ARG,SRCBLK
IOERR:	ER <I/O ERROR IN FILE 4>
ERNSF:	ER <NO SOURCE FILE SPECIFIED>
ERRTMF:	ER <TOO MANY SOURCE FILES>
EROPEN:	ER <OPEN FAILURE ON 1 DEVICE 2>
NONMER:	ER <FILE NAME REQUIRED FOR 2>
BADCHR:	ER <ILLEGAL CHARACTER 3>
BADSW:	GETCHR
	MOVE ARG,SWTARG
	ER <ILLEGAL SWITCH /3 IN 1 FIELD>
ERRSTR:	ASCIZ /
?/
	SUBTTL PHYSICAL DEVICE CONTROL
;
;INITIALIZATION ROUTINES.  IMPLICIT INITIALIZATION (MAC,SYN,LST)
;INVOLVES TAKING THE FILE NAME FROM THE BINARY SPECIFICATION AND
;THE EXTENSION FROM THE STANDARD DEFAULTS.  IF NO BINARY FILE
;WAS SPECIFIED, A STANDARD DEFAULT NAME IS USED AS WELL:
;	SYMBOL.SYM FOR SYMBOLS
;	MACRO.EXP  FOR MACRO EXPANSION
;	LIST.LST   FOR LISTINGS
;
;EXPLICIT INITIALIZTION (BIN,LST) INVOLVES TAKING THE DEVICE, NAME,
;AND EXTENSION FROM THE OUTPUT OF THE COMMAND SCANNER.  IF NO
;EXTENSION AT ALL WAS SPECIFIED, A DEFAULT IS USED:
;	BINARY -->	BINARY.DEFAULT
;	BINARY.		BINARY.
;	BINARY.EXT	BINARY.EXT

	DEFINE IMP(A)	;IMPLICIT INITIALIZATION
<	MOVEI ARG,A'BLK
	PUSHJ P,INITNT>

	DEFINE EXD(A,B,C)	;EXPLICIT DEVICE
<	MOVEI ARG,A'BLK
	MOVE PA1,SCNDEV
	DEVCHR PA1,
	TLN'B PA1,C
	JRST BADDEV
	PUSHJ P,INITEX>


	INTERN $INITM,$INITS,$INITL
$INITB:	IMP BIN;	INITIALIZE THE BINARY FILE (IMPLICIT).
	TLZ F,QNOBIN	;CLEAR THE NO BINARY FILE FLAG.
	POPJ P,		;EXIT.

$INITM:	IMP MAC;	;INITIALIZE THE MACRO FILE (IMPLICIT).
	TRZ F,QNOMAC	;CLEAR THE "NO MACRO FILE" FLAG.
	POPJ P,		;EXIT

$INITS:	IMP SYM;	;INITIALIZE THE SYMBOL FILE (IMPLICIT).
	TRZ F,QNOSYM	;CLEAR THE "NO SYMBOL FILE" FLAG.
	POPJ P,

$INITL:	IMP LST;	;INITIALIZE THE LISTING FILE
	TLZ F,QNOLST+QTTY	;CLEAR THE "NO LIST FILE" FLAG.
	POPJ P,

INITBN:	EXD (BIN,E,CDRDEV+PTRDEV+LPTDEV+TTYDEV)	;INITIALIZE
	TLZ F,QNOBIN	;THE BINARY DEVICE.  CDR,PTP,LPT,TTY ARE
			;ILLEGAL AS BINARY DEVICES.
	POPJ P,

INITLS:	EXD (LST,N,OTPDEV)	;INITIALIZE THE LISTING DEVICE.
	TLZ F,QNOLST	;CLEAR THE "NO LIST FILE" FLAG.
	MOVE PA1,SCNDEV	;GET THE SPECIFIED DEVICE AND FIND OUT
	DEVCHR PA1,	;WHAT IT REALLY IS.
	TLNE PA1,TTYDEV	;IF TTY, SET "LIST IS TTY" FLAG.
	TLO F,QTTY
	POPJ P,
;EXEC4, PAGE 2
;ACTUAL CHARACTER OUT SUBROUTINES.  ALL ARE CALLED BY
;	MOVE ARG,WORD OR CHARACTER
;	PUSHJ P,ROUTINE
;IN FACT, ALL ARE VIRTUALLY THE SAME, AS WE NOW SHOW:

	DEFINE PIO(A)
<	SOSG A'HDR+HCNT	;BUFFER COUNT EXHAUSTED?
	PUSHJ P,A'DMP	;YES, OUTPUT THE BUFFER.
	IDPB ARG,A'HDR+HBYT	;STORE ARGUMENT IN BUFFER.
	POPJ P,		;RETURN

A'DMP:	OUTPUT A,	;OUTPUT A BLOCK.
A'TST:	STATO A,IODERR+IODTER+IOBKTL+IOIMPM	;CHECK FOR ERRORS.
	POPJ P,		;OK, EXIT
	MOVEI ARG,A'BLK	;OTHERWISE, ERROR.
	JRST IOERR>

	INTERN $WRWRD,$WRITM,$WRITS,$WRCHR
$WRWRD:	TLNE F,QNOBIN+QBINOFF	;BINARY SUPPRESSED?
	POPJ P,		;YES, EXIT.
	PIO BIN;	;NO, DO I/O

$WRITM:	TRNE F,QNOMAC+QMACOFF	;MACRO OUTPUT OFF?
	POPJ P,		;YES, EXIT.
	PIO MAC;	;NO, DO I/O

$WRITS:	TRNE F,QNOSYM+QSYMOFF	;NO SYMBOL OUTPUT?
	POPJ P,		;YES, EXIT.
	PIO SYM;	;NO, DO I/O

WRTTAB:	SKIPA ARG,["	"]
WRTSPC:	MOVEI ARG," "
WRTASC:	TLNE F,QPASS1+QNOLST+QLSTOFF+QANLST	;LISTING SUPPRESSED
	POPJ P,		;YES, EXIT.
	PIO LST;	;DO I/O
			;THE INTERNED LISTING OUTPUT ROUTINE IS
			;$WRCHR, WHICH IS ALSO RESPONSIBLE FOR
			;MAINTAINING THE LISTING.
;EXEC4, PAGE 3
;INITNT-- INITIALIZE IMPLICIT FILE.  BLOCK ADDRESS IN ARG.
;INITEX-- INITIALIZE EXPLICIT FILE.  BLOCK ADDRESS IN ARG,
;	  SCANNER OUTPUT IN SCNDEV,SCNNAM, ETC.

	DEFINE BLD(A,B)	;BUILD THE UUO A XXX,B
<	MOVE PA3,FCHL(ARG)	;GET CHANNEL NUMBER.
	TLO PA3,(A)	;OR IN OPCODE.
	HRRI PA3,B	;SET UP ADDRESS
	XCT PA3	;DO UUO
>

INITNT:	SKIPN PA1,BINBLK+FNAM	;ANY BINARY FILE NAME?
	SKIPE PA1,SRCBLK+FNAM	;NO, ANY SOURCE FILE YET?
	SKP		;EITHER ONE NON-BLANK, USE IT.
	MOVE PA1,FDFNAM(ARG)	;BOTH BLANK, USE DEFAULT NAME.
	MOVEM PA1,FNAM(ARG)	;SET UP IMPLICIT FILE NAME.
	CPY FDFDEV(ARG),FDEV(ARG)	;SET UP IMPLICIT DEVICE.
	CPY FDFEXT(ARG),FEXT(ARG)	;SET UP IMPLICIT EXTENSION.
	SETZM FPJ(ARG)	;CLEAR PRJECT# PROG# FIELD.
INITUS:	SETZM FEXT+1(ARG)	;CLEAR ACCESS DATE.
	BLD OPEN,FOBLK(ARG)	;BUILD AN OPEN CHL,FOBLK
	JRST EROPEN	;ERROR, DIE.
	BLD OUTBUF,NUMBUF	;ALLOCATE BUFFERS.
	BLD ENTER,FNAM(ARG)	;BUILD AN   ENTER CHL,FNAME
	JRST ERENTR	;ERROR, DIE.
	POPJ P,

INITEX:	PUSHJ P,MOVSCN	;EXPLICIT INIT... MOVE SCANNER OUTPUT TO FILE
	JRST INITUS	;BLOCK AND GO INITIALIZE.


MOVSCN:	CPY SCNNAM,FNAM(ARG)	;MOVE SCANNER OUTPUT TO FILE BLOCK
	CPY SCNDEV,FDEV(ARG)	;SPECIFIED BY ARG.
	CPY SCNPJ,FPJ(ARG)
	SKIPN PA1,SCNEXT	;IS THERE ANY EXTENSION?
	MOVE PA1,FDFEXT(ARG)	;NO, USE DEFAULT EXTENSION.
	HLLZM PA1,FEXT(ARG)
	POPJ P,		;EXIT.
;EXEC4, PAGE 4
;SOURCE FILE INITIALIZATION IS A DIFFERENT KETTLE OF FISH.  FIRST OF
;ALL, WE ARE DOING INPUT INSTEAD OF OUTPUT.  SECONDLY, WE HAVE
;TO LOOK FOR BOTH IMPLICIT AND BLANK EXTENSIONS IF NONE ARE GIVEN.
;FINALLY, THE GET SOURCE CHARACTER ROUTINE HAS A SKIP/NON-SKIP
;CONVENTION FOR OK/END-OF-FILE.

	INTERN $RDCHR
INITSRC:	MOVEI ARG,SRCBLK	;SET UP ARGUMENT FOR MOVSCN.
	MOVE PA1,SCNDEV	;FIND OUT ABOUT THE SOURCE DEVICE.
	DEVCHR PA1,
	TLNN PA1,INPDEV	;IS IT AN INPUT DEVICE?
	JRST BADDEV	;NO, DIE.
	PUSHJ P,MOVSCN	;DEVICE OK, MOVE SCANNER OUTPUT TO SOURCE BLOCK.
	OPEN SRC,FOBLK(ARG)	;OPEN THE SOURCE CHANNEL.
	JRST EROPEN	;NO GO.

	PUSH P,JOBFF	;SAVE OLD JOBFF.
	MOVEI PA1,BCORE	;KLUDGE JOBFF TO POINT TO INPUT BUFFERS.
	MOVEM PA1,JOBFF
	INBUF SRC,NUMBUF	;SET UP SRC BUFFERS.
	POP P,JOBFF	;RESTORE JOBFF.

	LOOKUP SRC,SRCBLK+FNAM	;LOOKUP THE NEW FILE.
	JRST LKFAIL	;FAILURE, DIE.
	POPJ P,		;OK.

LKFAIL:	SKIPE ,SCNEXT		;WAS THE SCANNER EXTENSION BLANK?
	JRST ERLKF	;NO, THEN LOOKUP REALLY FAILED.
	SETZM SRCBLK+FEXT	;YES, THEN WE LOOKED UP WITH DEFAULT
	LOOKUP SRC,SRCBLK+FNAM	;EXTENSION, TRY AGAIN WITH BLANK EXT.
	JRST ERLKF	;FAILED, DIE.
	POPJ P,		;OK, LEAVE.


$RDCHR:	SOSGE SRCHDR+HCNT	;CURRENT BUFFER EXHAUSTED?
	JRST NEWBUF	;YES, GET A NEW ONE.
	IBP SRCHDR+HBYT	;NO, ADVANCE BYTE POINTER.
	MOVE PA1,@SRCHDR+HBYT	;GET THE WHOLE WORD CURRENTLY SELECTED.
	TRZE PA1,1	;LOW ORDER 1?
	JRST FSQNUM	;YES, A SEQUENCE NUMBER.
	LDB ARG,SRCHDR+HBYT	;NO, GET CURRENT CHARACTER.
	JUMPE ARG,$RDCHR	;IF NULL, TRY AGAIN.
	CAIN ARG,FFEED	;NON NULL, IS IT FORM FEED?
	AOS ,FILPAG	;YES, GO ONTO TO NEW PHYSICAL PAGE.
	AOS (P)		;TAKE SKIP RETURN.
	POPJ P,

NEWBUF:	INPUT SRC,	;GET A NEW BUFFER.
	STATZ SRC,IODERR+IODTERR+IOIMPM+IOBKTL	;ERRORS?
	JRST ERRID	;YES, DIE
	STATO SRC,IOEOF	;NO, END OF FILE?
	JRST $RDCHR	;NO, CONTINUE.
	MOVE PA1,@COMPTR	;YES, GO ONTO NEW FILE.  ARE WE AT THE END
	PUSHJ P,CHKEOL	;OF THE COMMAND STRING?
	SKP		;NO.
	POPJ P,		;YES, TAKE FAIL RETURN.
	MOVEI ARG,SRCBLK	;USING THE SOURCE SWITCH TABLE,
	PUSHJ P,GETNAM	;GET A NAME.
	JRST BADCHR	;NONE FOUND, DIE.
	PUSHJ P,GETSRC	;INITIALIZE THE SOURCE PROCESS.
	JRST $RDCHR	;START OVER.

FSQNUM:	MOVEM PA1,$SQNUM	;SAVE SEQUENCE NUMBER.
	AOS ,SRCHDR+HBYT	;ADVANCE BYTE POINTER OVER SQ#.
	MOVNI PA1,5	;DECREMENT COUNT BY 5 CHARACTERS.
	ADDM PA1,SRCHDR+HCNT
	JRST $RDCHR	;TRY AGAIN
;EXEC4, P
;SWITCH TABLES FOR VARIOUS FIELDS:
;SRCSWT:	SOURCE SWITCHES
;ALL THE SWITCH TABLES ARE FOR THE MOMENT THE SAME.

	DEFINE SW(A,B)
<	ASCIZ /A/
	B>

LSTSWT:
BINSWT:	SALL
SRCSWT:	SW A,<TRO F,QADVF>	;/A = ENABLE ADVANCED FEATURES
	SW -A,<TRZ F,QADVF>	;-A = DISABLE ADVANCED FEATURES
	SW B,<TLZ F,QNBINRQ+QBINOFF>	;/B = ENABLE BINARY
	SW -B,<TLO F,QBINOFF>	;/-B = DISABLE BINARY
	SW C,<PUSHJ P,SETCRF>	;/C = ENABLE CREF
	SW -C,<TLZ F,QCREF>	;/-C = DISABLE CREF
	SW D,<TRZ F,QNSYMRQ+QSYMOFF>	;/D = ENABLE SYMBOLS
	SW -D,<TRO F,QSYMOFF>	;/-D = DISABLE SYMBOLS
	SW E,<TRO F,QXPAND>	;/E = EXPANDED LISTING
	SW -E,<TRZ F,QXPAND>	;/-E = NORMAL LISTING
	SW G,<TRO F,QSYML>	;/G = MACHINE COMPATIBLE SYMTAB
	SW -G,<TRZ F,QSYML>	;/-G = NO COMPATIBLE SYMBOL TABLE
	SW I,<TRO F,QICRF>	;/I = PRODUCE INSTRUCTION CREF TABLE
	SW -I,<TRZ F,QICRF>	;/-I = NO INSTRUCTION CREF TABLE
	SW J,<TLZ F,QNOSMT>	;/J = SYMBOL TABLE LISTING
	SW -J,<TLO F,QNOSMT>	;/-J = NO SYMBOL TABLE LISTING
	SW L,<TLZ F,QNLSTRQ+QLSTOFF>	;/L = LISTING
	SW -L,<TLO F,QLSTOFF>	;/-L = LISTING OFF
	SW O,<TRO F,QOVRID>	;/O = DISABLE "LIST/XLIST"
	SW -O,<TRZ F,QOVRID>	;/-O = ENABLE "LIST/XLIST"
	SW Q,<TRO F,QNQUES>	;/Q = NOTE QUESTIONABLE ERRORS
	SW -Q,<TRZ F,QNQUES>	;/-Q = SUPPRESS Q ERRORS
	SW R,<TRZ F,QNMACRQ+QMACOFF>	;/R = ENABLE EXPANSION FILE
	SW -R,<TRO F,QMACOFF>	;/-R = DISABLE EXPANSION FILE
	SW T,<TLZ F,QNOERR>	;/T = ERRORS ON TTY
	SW -T,<TLO F,QNOERR>	;/-T = SUPPRESS ERRORS ON TTY
	SW V,<TRO F,QVERFY>	;/V = VERIFY
	SW -V,<TRZ F,QVERFY>	;/-V = NO VERIFY
	SW X,<TRO F,QNADV>	;/X = FLAG EXTENDED FEATURES
	SW -X,<TRZ F,QNADV>	;/-X = ALLOW EXTENDED FEATURES
	Z

SETCRF:	TLO F,QCREF	;RESPONDS TO /C:  SET CREF FLAG.
	TLZ F,QNLSTRQ	;CLEAR NO LIST REQUEST FLAG SINCE
	POPJ P,		;/C IMPLIES /L
  h5?