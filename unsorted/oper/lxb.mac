	SUBTTL COMMAND SCANNER
;
;THE COMMAND SCANNER IS A PSEUDO-SYNTAX MACHINE IN WHICH THE
;SO CALLED PSEUDO-OPERATIONS ARE ACTUALLY SUBROUTINE CALLS
;OR MACROS.  PRIMITIVES:

	GETSTR=PUSHJ P,RDSTR	;GET SIXBIT STRING IN "NM"
	GETOCT=PUSHJ P,RDOCT	;GET OCTAL CONSTANT IN "NM"
	GETSW=PUSHJ P,RDSW	;LOOK FOR SWITCHES
	OPDEF GETCHR [AOS COMPTR]	;ADVANCE SCANNING POINTER.

	GETCHR		;ADVANCE TO NEXT CHARACTER AND...
GETBLK:	MOVE PA2,COMPTR	;WITHOUT ADVANCING COMPTR,
	MOVE PA1,1(PA2)	;ABSORB NEXT BLANK OR TAB.
	CAIE PA1," "
	CAIN PA1,"	"
	JRST GETBLK-1	;AND CONTINUE SCAN.
	POPJ P,		;EXIT.
;LEXEC B, PAGE 2
;GETNAM--- GET DEVICE AND FILE SPECIFIER AND SWITCHES.
;CALLING SEQUENCE...
;	MOVEI ARG,SWITCHTABLE
;	PUSHJ P,GETNAM
;	...	;NULL FILE RETURN
;	...	;NORMAL RETURN

GETNAM:	MOVEM ARG,SWTARG	;SAVE ADDRESS OF SWITCH TABLE.
	MOVSI PA1,'DSK'	;INITIALIZE FILE NAME TO 'DSK'.
	MOVEM PA1,SCNDEV
	CLEARM ,SCNNAM	;CLEAR NAME, EXTENSION, AND PROJECT#-
	CLEARM ,SCNEXT	;PROGRAMMER# WORD
	CLEARM ,SCNPJ

GLOOP:	PUSHJ P,GETBLK	;ABSORB LEADING SPACES.
	GETSTR		;LOOK FOR AN ALPHANUMERIC STRING.
	FAIL CHKSW	;NONE FOUND, MAYBE SWITCHES?
	MCH ":"		;FOUND, DID IT END IN COLON?
	FAIL NODEV	;NO.
	MOVEM NM,SCNDEV	;YES, SAVE AS DEVICE NAME.
	GETSTR		;LOOK FOR ANOTHER STRING.
	FAIL NONAME	;NOT FOUND, DEVICE HAS NO FILE, GO CHECK.

NODEV:	MOVEM NM,SCNNAM	;SAVE STRING AS FILE NAME.
	MCH "."		;DID IT END IN PERIOD?
	FAIL NOEXT	;NO, NO EXTENSION.
	AOS ,SCNEXT	;YES, SET EXPLICIT EXTENS[ON FLAG.
	GETSTR		;GET EXTENS[ON.
	FAIL NOEXT	;NOT FOUND, FORGET IT.
	HLLZM NM,SCNEXT	;FOUND, SAVE EXTENSION.

NOEXT:	MCH "["		;DID NAME OR EXTENSION END IN RIGHT BRACKET?
	FAIL NOPJ	;NO.
	GETOCT		;YES, GET PROJECT# AND SAVE.
	HRLZM NM,SCNPJ
	MCH <",">	;DID IT END IN ","?
	FAIL BADCHR	;NO, ERROR
	GETOCT		;YES, GET PROGRAMMER# AND SAVE.
	HRRM NM,SCNPJ
	MCH "]"		;DID STRING TERMINATE IN "]"?
	FAIL BADCHR	;NO, ERROR

GEXIT:	GETCHR		;GET CHARACTER TO PRIME SWITCH READDER.
NOPJ:	MCH "	 "	;FIRST, LOOK FOR ANY INTERMEDIATE SPACES
	CAIN PA1,"	"	;OR TABS.
	JRST GEXIT	;FOUND, GET NEXT CHARACTER.
	GETSW		;LOOK FOR SWITCHES.
	SKP		;NONE FOUND, EXIT.
	JRST GEXIT	;FOUND, LOOK FOR MORE.
	AOS ,(P)	;SET UP SKIP RETURN.

EMPTY:	POPJ P,		;RETURN.


NONAME:	MOVE PA1,SCNDEV	;DEVICE NAME BUT NO FILE NAME.
	DEVCHR PA1,	;GET DEVICE CHARACTERISTICS.
	TLNE PA1,DIRDEV	;IS IT A DIRECTORY DEVICE?
	JRST NONMER	;YES, ERROR, THERE MUST BE A NAME.
	JRST NOPJ	;NO, OK, EXIT.

CHKSW:	GETSW		;NO INITIAL STRING... LOOK FOR SWITCHES.
	FAIL EMPTY	;NOT FOUND, EMPTY FIELD.
	JRST GLOOP	;FOUND, TRY AGAIN.
;LEXEC B, PAGE 3
;ROUTINES FOR IMPLEMENTING PRIMITIVES.
;RDSTR---	READ SIXBIT ALPHANUMERIC STRING
;RDOCT---	READ OCTAL NUMBER
;RDSW---	LOOK FOR SWITCHES
;
;RDSTR AND RDOCT ARE UNPRIMED;  THEY ASSUME THAT THEY MUST START
;BY GETTING A CHARACTER FROM THE STRING, AND THEY LEAVE THE
;SCANNING PROCESS "PRIMED", IE, WITH AN UNPROCESSED
;CHARACTER IN "TERML".  RDSW MUST BE PRIMED BEFORE CALL AND
;LEAVES THE PROCESS UNPRIMED.

RDSTR:	CLEAR NM,	;CLEAR THE OUTPUT AREA.
	MOVE PA2,[POINT 6,NM]	;SET UP BYTE PTR INTO OUTPUT AREA.

RDSLP:	GETCHR	;GET A CHARACTER.
	MOVE PA1,@COMPTR
	CAIGE PA1,"0"	;IS IT A NUMBER?
	JRST ENDSTR	;NO, END OF STRING.
	CAIG PA1,"9"
	JRST OK	;YES PACK IT IN.
	CAIL PA1,"A"	;IS IT A LETTER?
	CAILE PA1,"Z"
	JRST ENDSTR	;NO, END OF STRING.
OK:	SUBI PA1,40	;CONVERT TO SIXBIT ASCII.
	TLNE PA2,770000	;LESS THAN SIX CHARACTERS PACKED?
	IDPB PA1,PA2	;YES, SAVE CHARACTER.
	JRST RDSLP	;GET NEXT CHARACTER.

ENDSTR:	JUMPN NM,CPOPJ1	;END OF STRING... ANY OUTPUT?
			;YES, SKIP.
	POPJ P,		;NO, FAIL.

RDNUM:	SKIPA T,$RADIX	;RDNUM...READ ARBITRARY RADIX INT.
RDOCT:	MOVEI T,^D8	;RDOCT... READ OCTAL INTEGER.
	MOVEM T,NRADIX
	CLEAR NM,	;CLEAR THE OUTPUT AREA.
RDOCTL:	GETCHR		;GET A CHARACTER.
	MOVE PA1,@COMPTR	;CONVERT TO BINARY.
	SUBI PA1,"0"
	JUMPL PA1,CPOPJ	;IF LESS THAN ZERO, ERROR.
	CAML PA1,NRADIX	;IS IT WITHIN RADIX?
CPOPJ:	POPJ P,		;NO, EXIT.
	IMUL NM,NRADIX	;NUMBER=
	ADD NM,PA1	;NUMBER*RADIX + DIGIT.
	JRST RDOCTL	;GET NEXT DIGIT.


RDSW:	MCH <"(">	;IS OUTSTANDING CHARACTER A START OF SWITCH GROUP CHAR?
	FAIL SINGSW	;NO, LOOK FOR SINGLE SWITCH.
	PUSHJ P,LOOKSW	;LOOK FOR ONE SWITCH.
	SKP		;NOT FOUND.
	JRST .-2	;FOUND, GO LOOK FOR ANOTHER.
	GETCHR		;LOOKSW STARTS AND ENDS UNPRIMED.  GET NEXT CHAR.
	MCH <")">	;DID SWITCHES END IN )?
	FAIL BADSW+1	;NO, ERROR
	JRST CPOPJ1	;YES, EXIT OK.

SINGSW:	MCH "/"		;IS OUTSTANDING CHAR A SWITCH INDICATOR?
	POPJ P,		;NO, NO SWITCHES, FAIL.
	PUSHJ P,LOOKSW	;YES, LOOK FOR SWITCH.
	JRST BADSW	;NOT FOUND, BAD SWITCH.
	JRST CPOPJ1	;OK, EXIT.
;LEXEC B, PAGE 4
;ROUTINES FOR SWITCH PROCESSING.
;LOOKSW---	LOOK FOR SWITCH (UNPRIMED)
;MATCH---	LOOK FOR SWITCH GIVEN A SWITCH TABLE.

LOOKSW:	MOVEI ARG,$USRSW	;USING FIRST THE USER'S SWITCH TABLE,
	PUSHJ P,MATCH	;TRY TO MATCH ONE SWITCH.
	SKP		;NOT FOUND.
	JRST CPOPJ1	;FOUND, TAKE SKIP RETURN.
	MOVE ARG,SWTARG	;USING IINTERNAL SWITCH TABLE,
	MOVE ARG,FSWT(ARG)	;WHICH WE GET FROM THE ARGUMENT BLOCK,
	PUSHJ P,MATCH	;TRY TO MATCH ONE SWITCH.
	POPJ P,		;NOT FOUND, FAIL.
	JRST CPOPJ1	;FAIL, TAKE SKIP RETURN.


MATCH:	SKIPN ,(ARG)	;DOES POINTER POINT TO END OF TABLE?
	POPJ P,		;YES, EXIT, NO MATCH.
	PUSH P,ARG	;NO, SAVE ARGUMENT.
	HRLI ARG,(POINT 7,)	;CONVERT ARGUMENT TO BYTE PTR.
	MOVE PA1,COMPTR	;GET BYTE POINTER TO COMMAND STRING.

MCHLP:	ILDB PA2,ARG	;GET CHARACTER FROM TABLE ENTRY.
	JUMPE PA2,MCHFND	;IF END, THEN MATCHED.
	ADDI PA1,1	;NOT END, GET NEXT CHARACTER FROM COMMAND
	CAMN PA2,(PA1)	;STRING.  MATCH?
	JRST MCHLP	;YES, CONTINUE COMPARISON.
	POP P,ARG	;NO, RECOVER ARGUMENT.
	ADDI ARG,2	;ADVANCE TO NEXT TABLE ENTRY.
	JRST MATCH

MCHFND:	MOVEM PA1,COMPTR	;SAVE ADVANCED PTR IN COMMAND STRING.
	POP P,ARG	;GET RID OF SAVED ARGUMENT.
	XCT 1(ARG)	;EXECUTE SWITCH INSTRUCTION.
	JFCL
	JRST CPOPJ1	;EXIT OK.


;LEXEC B, PAGE 5
;MASTER SWITCH TABLE

SWTBL:	SW R:,<PUSHJ P,SETORG>	;/R:XXXXX= SET REL. CONSTANT
	SW LO:,<PUSHJ P,SETLO>	;/LO:XXXXX= SET LOWER LIMIT
	SW HI:,<PUSHJ P,SETHI>	;/HI:XXXXX= SET UPPER LIMIT
	SW E:,<PUSHJ P,DOEXMN>	;/E:XXXXX= EXAMINE
	SW D:,<PUSHJ P,DODPST>	;/D:XXXXX[,XXXXX]= DEPOSIT
	SW LO,<PUSHJ P,TYPLO>	;/LO= TYPE LOWER LIMIT
	SW HI,<PUSHJ P,TYPHI>	;/HI= TYPE UPPER LIMIT
	SW R,<PUSHJ P,TYPORG>	;/R= TYPE RELOCATION CONSTANT
	SW T,<PUSHJ P,TYPSYM>	;/T= TYPE SYMBOLS
	SW M,<TLO F,QMAP>	;/M= SET MAP REQUEST
	SW -M,<TLZ F,QMAP>	;/-M= KILL MAP REQUEST
	SW F,<JRST DODIAL>	;/F= FORCE END OF LOAD
	SW U,<PUSHJ P,TYPUND>	;/U= TYPE UNDEFINED GLOBALS
	SW C,<PUSHJ P,CNTUND>	;/C= TYPE #OF UNDEFINED GLOBALS
	SW D,<TLO F,QSMRQ>	;/D= PRODUCE OUTPUT SYMBOL FILE
	SW -D,<TLZ F,QSMRQ>	;/-D= NO SYMBOL FILE
	SW S,<TLO F,QLOCAL>	;/S= LOAD LOCAL SYMBOLS
	SW -S,<TLZ F,QLOCAL>	;/-S= NO LOCAL SYMBOLS
	Z

	ENTRY $RDNUM
	EXTERN $RELOC
$RDNUM:	PUSHJ P,RDNUM	;READ A SWITCH DIGIT STRING.
	SOS ,COMPTR	;"UNPRIME" THE CHARACTER POINTER,
	POPJ P,		;SINCE A SWITCH SUPPOSEDLY LEAVES IT THAT WAY.

CNTUND:	CLEAR A,	;COUNT UNDEFINED GLOBALS.
	MOVE T2,$EMASK	;MASK FOR UNDEFINED IS GLOBAL MASK
	TLZ T2,QENT+QINT	;MINUS ENTRY/INTERN FLAGS.
	SKIPA T,SYMBEG	;CLEAR COUNTER, SET UP TABLE POINTER.
CNTLP:	ADDI T,SYMLNT	;INCREMENT TABLE POINTER EXCEPT ON 1ST TIME.
	CAML T,JOBFF	;END OF TABLE?
	JRST ENDCNT	;YES, DONE.
	MOVE T1,SYMF(T)	;GET SYMBOL FLAGS.
	TDNN T1,T2	;UNDEFINED GLOBAL?
	JRST CNTLP	;NO.
	AOJA A,CNTLP	;YES, INCREMENT COUNT AND BRANCH BACK.

ENDCNT:	JUMPN A,SOMUND	;ANY UNDEFINED? YES, GO PRINT #.
	OUTSTR [ASCIZ /NO/]	;NO, NUMBER IS ZERO.
	JRST PMSG

SOMUND:	PUSHJ P,PRDEC	;SOME UNDEFINED.. PRINT AS INTEGER.
	AOS ,(P)	;SET UP SKIP RETURN.
PMSG:	OUTSTR UNDMSG	;OUTPUT REST OF MESSAGE.
	POPJ P,

UNDMSG:	ASCIZ / UNDEFINED GLOBALS
/
;LEXEC B, PAGE 6
;CORE ALLOCATOR
	SUBTTL CORE IMAGE MAINTENANCE ROUTINES
;
;THE CORE IMAGE ROUTINES ARE RESPONSIBLE FOR INSERTING AND
;READING WORDS OUT OF THE CORE IMAGE WHICH THE LOADER IS
;BUILDING.  THE MAIN ROUTINES IS $PTWRD, WHICH IS CALLED BY:
;	MOVE A,WORD	;WORD TO BE INSERTED
;	PUSHJ P,$PTWRD	;$ORIGN CONTAINS ADDR
;	...	;ERROR
;	...	;INSERTED
;$PTWRD ATTEMPTS TO MAINTAIN A MINIMAL CORE IMAGE, THAT IS,
;IF LOADED CORE EXTENDS FROM 1040-2657, SIMULATED CORE CONTAINS
;ONLY ADDRESS SPACE 1000-2777, OR THEREABOUTS.
;$PTWRD MAINTAINS A NUMBER OF IMPORTANT POINTERS:
;$MAX:	HIGHEST LEGAL CURRENT ADDRESS (+1)
;$MIN:	LOWEST LEGAL CURRENT ADDRESS
;$HI:	HIGHEST ADDRESS WRITTEN INTO
;$LO:	LOWEST ADDRESS WRITTEN INTO

	ENTRY $GTWRD,$PTWRD
	INTERN $MAX,$MIN,$HI,$LO
	EXTERN $ORIGN,$RELOC
$PTWRD:	MOVEM A,TMPPTR	;SAVE WORD TO BE STORED.
	MOVE A,$ORIGN	;GET CURRENT ORIGIN.
	CAMGE A,$MAX	;IS IS > HIGHEST LEGAL ADDRESS?
	JRST MAXOK	;NO, MAX IS OK.
	SKIPG ,$MAX	;NO, IS MAXIMUM ZERO (UNDEFINED)?
	JRST UNDEFM	;YES, SPECIAL CASE.
	SUB A,$MAX	;COMPUTE AMOUNT OF SPACE MISSING.
	ADDI A,CORINC	;ROUND TO THE NEXT HIGHER MULTIPLE OF
	TRZ A,CORINC-1	;CORE INCREMENT (A POWER OF 2).
GETCOR:	PUSH P,A	;SAVE INCREMENT.
	PUSHJ P,SALLOC	;ALLOCATE CORE.
	JRST EREXIT	;ERROR, DIE.
	MOVE T,A	;SAVE STARTING ADDRESS OF NEW AREA.
	POP P,A		;OK, RECOVER INCREMENT.
	ADDM A,$MAX	;EXPAND MAXIMUM ACCORDINGLY.
CLRCOR:	CLEARM ,(T)	;ZERO "A" WORDS, BEGINNING
	ADDI T,1	;AT LOCATION POINTED TO BY "T".
	SOJG A,.-2
MINOK:	MOVE T,$ORIGN	;GET CURRENT ORIGIN, SUBTRACT OFF BASE
	CAMLE T,$HI	;BUT FIRST UPDATE $HI AND $LO. THEN
	MOVEM T,$HI
	CAMGE T,$LO
	MOVEM T,$LO
	SUB T,$MIN	;TO GET OFFSET INTO CORE ARRAY, COMPUTE
	ADD T,FRESTR	;ACTUAL ADDRESS OF ELEMENT.
	MOVE A,TMPPTR	;COPY WORD
	MOVEM A,(T)	;INTO PSEUDO CORE.
	AOSA ,(P)	;EFFECT SKIP.
EREXIT:	POP P,T		;ON ERROR, POP INCREMENT OFF STACK.
	POPJ P,		;EXIT.

MAXOK:	CAML A,$MIN	;MAXIMUM CHECK OKAY.  IS ORIGIN >
	JRST MINOK	;MINIMUM? YES, GO STORE.
	SUB A,$MIN	;COMPUTE HOW MANY WORDS ARE MISSING.
	MOVM A,A	;CONVERT IT TO POSITIVE FORM AND
	ADDI A,CORINC-1	;ROUND IT UP TO THE NEAREST MULTIPLE
	TRZ A,CORINC-1	;OF THE CORE INCREMENT.
	PUSH P,A	;SAVE THIS INCREMENT.
	PUSHJ P,SALLOC	;TRY FOR CORE.
	JRST EREXIT	;NO GO.
;AT THIS POINT, A CONTAINS THE ADDRESS OF THE NEW INCREMENT=
; LAST ADDRESS IN OLD CORE ARRAY+1
;FREEND CONTAINS THE ADDRESS+1 OF THE END OF THE NEW INCREMENT.
;HENCE WE CAN CONSTRUCT A POP TO DO THE PROPER MOVING.

	MOVE T,$MAX	;MOVE COUNT IS LENGTH OF OLD CORE ARRAY=
	SUB T,$MIN	;MAX-MIN.
	MOVE T1,FREEND	;"TO" ADDR IS END OF FREE STORAGE.
	HRLI A,-1	;SET UP DUMMY POP COUNT.
	SUBI A,1	;ARG POINTS TO LAST WORD+1
	SUBI T1,1	;SO DOES T1.
	POP A,(T1)	;MOVE WORD.
	SOJG T,.-2	;DECREMENT COUNT AND CONTINUE.
	POP P,A		;RECOVER INCREMENT FROM STACK.
	MOVN T,A	;DECREMENT $MIN ACCORDINGLY.
	ADDM T,$MIN
	MOVE T,FRESTR	;NEW AREA BEGINS AT START OF FREE STORAGE.
	JRST CLRCOR	;GO CLEAR CORE AND STORE WORD.

UNDEFM:			;UNDEFINED MAX/MIN.
	MOVEM A,$HI	;DEFINE INITIAL HIGH AND LOW.
	MOVEM A,$LO
	TRZ A,CORINC-1	;SET MIN AND MAX TO NEAREST
	MOVEM A,$MAX	;MULTIPLE OF CORINC.
	MOVEM A,$MIN
	MOVEI A,CORINC	;INITIALLY ALLOCATE 1K.
	JRST GETCOR

	CORINC=2000	;CORE INCREMENT IS 1K (DECIMAL)
;LEXEC B, PAGE 7
;$GTWRD IS FAR EASIER.

$GTWRD:	MOVE T,$ORIGN	;GET CURRENT ORIGIN.
	CAML T,$MIN	;IS IT IN DEFINED RANGE?
	CAML T,$MAX
	JRST NTINC	;NO, RETURN ZERO.
	SUB T,$MIN	;COMPUTE ADDRESS OF ENTRY.
	ADD T,FRESTR
	SKIPA A,(T)	;RETURN WORD.
NTINC:	SETZ A,		;ON ERROR, RETURN ZERO.
	POPJ P,
	SUBTTL SWITCH PROCESSORS
;LEXEC B, PAGE 8
;SWITCH PROCESSING ROUTINES.

	DEFINE SETSW(B)	;READ VALUE FOR SWITCH AND STORE
<	PUSHJ P,$RDNUM
	MOVEM A,B
	POPJ P,>

	DEFINE TYPSW(B,C)	;TYPE VALUE FOR SWITCH
<	OUTSTR .+5
	MOVE A,C
	PUSHJ P,$PRVAL
	OUTSTR CRLF
	POPJ P,
	ASCIZ \B\>

SETORG:	SETSW $RELOC	;/R:

SETHI:	SETSW $HI	;/HI:

SETLO:	SETSW $LO	;/LO:

TYPORG:	TYPSW <REL CONST/	>,$RELOC

TYPHI:	TYPSW <HIGH/	>,$HI

TYPLO:	TYPSW <LOW/	>,$LO

DOEXMN:	PUSHJ P,$RDNUM	;READ EXAMINE ADDRESS.
	MOVEM A,EXAMIN	;SAVE IT FOR FUTURE DEPOSIT
	MOVEM A,$ORIGN	;USE IT AS ORIGIN FOR WORD FETCH.
	PUSHJ P,$PRVAL	;PRINT IT AS ADDRESS.
	OUTSTR [ASCIZ \/	\]	;FOLLOW WITH SLASH-TAB.
	PUSHJ P,$GTWRD	;FETCH INDICATED WORD.
	PUSHJ P,$PRVAL	;PRINT IT.
	OUTSTR CRLF	;TERMINATE WITH CR-LF.
	POPJ P,	;EXIT.

DODPST:	PUSHJ P,RDNUM	;READ DEPOSIT VALUE.
	MCH <",">	;DID IT END IN COMMA?
	JRST NODADR	;NO, NO ADDRESS WILL BE SPECIFIED.
	PUSH P,A	;PUSH DEPOSIT VALUE.
	PUSHJ P,RDNUM	;READ DEPOSIT ADDRESS.
	MOVEM A,$ORIGN	;SAVE AS ORIGIN.
	POP P,A		;RECOVER DEPOSIT VALUE.
PUTIT:	SOS ,COMPTR	;DECREMENT COMMAND POINTER $$KLUDGE$$
	AOS ,EXAMIN	;INCREMENT EXAMINE ADDRESS.
	PUSHJ P,$PTWRD	;STORE WORD.
	OUTSTR ERROR	;ON ERROR, PUNT
	POPJ P,		;EXIT.

NODADR:	CPY EXAMIN,$ORIGN	;ON NO SPECIFIED ADDRESS, USE
	JRST PUTIT	;ADDRESS OF LAST EXAMINE.
ERROR:	ASCIZ /?
/
