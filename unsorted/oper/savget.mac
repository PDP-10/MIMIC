	TITLE	SAVGET - MIMIC SAVE FILE CREATE AND READ
	HISEG

;EXTERNAL SUBROUTINES

	EXTERN	FNDCON,FNDUNT,FNDAUNT,FNDREG
	EXTERN	ANLFIL,.ATTAC,.DETAC
	EXTERN	NXTCON,NXTREG,NXTUNT
	EXTERN	WRTNAM
	EXTERN	BRKINS,QAJAM
	EXTERN	.ACTVT,.CNCEL
	EXTERN	.WRITE,.READ,PUTFRM,CIOFAIL,GETFRM

;EXTERNAL DATA

	EXTERN	.ACTVQ
	EXTERN	SAVUCB,ERROR
	EXTERN	SYSLSP,BCTBOT,BCTTOP,ACTPTR
	EXTERN	UNSTAT
	EXTERN	JUNK
	EXTERN	CONFLG,UNTFLG,CORFLG
	EXTERN	SMGR	;TO KEEP P.MAC HAPPY

;INTERNAL SUBROUTINES

	INTERN	SAVSUB
	INTERN	GETSUB

;AC'S

SUCB=1	;POINTER TO SAVE FILE UCB
SWRD=2	;I/O WORD FOR SAVE FILE READ/WRITE ROUTINES
UNIT=3	;UCB ADDRESS OF CURRENT UNIT
CON=4	;DDM ADDRESS OF CURRENT CONTROLLER
RDB=5	;RDB ADDRESS OF CURRENT REGISTER
BCT=5	;POINTER TO CURRENT BCT ENTRY
FABADR=5	;POINTER TO CURRENT FAB
ACT=5	;POINTER TO FIRST WORD OF CURRENT ACTION BUFFER
ACTWRD=6	;CURRENT WORD NUMBER WITHIN ACTION BUFFER
AC1=7	;TEMP
AC2=10	;TEM
STK=17	;PUSHDOWN STACK POINTER


	PAGE
	SUBTTL	SAVSUB - SUBROUTINE FOR SAVING MIMIC STATE

SAVSUB:	CSSF	ANLFIL,I	;SET UP FILE THINGS
	SGD	.LEBLK+1,0,I	;IS EXTENSION NULL?
	LDG	.LEBLK+1,[SIXBIT /MIM/],D	;IF SO, SET TO "MIM"
	ASMF	RETURN,I	;AND TERMINATING CARRIAGE RETURN
	LDG	.UCBAD,SAVUCB,I	;SET UP .ATTAC ARGUMENT
	LSM			;BACK TO 10 MODE
	MOVSI	AC1,QRD		;CLEAR THE "READ ONLY" BIT IN
	ANDCAM	AC1,SAVUCB+USTAT	;SAVE-UCB STATUS.
	PUSHJ	STK,.ATTAC	;ATTACH (AND CREATE) THE SAVE FILE
	JRST	,SAVERR
	MOVE	SWRD,SYSLSP	;GET POINTER TO SYSTEM LIST
	MOVE	SWRD,SYNAME(SWRD)	;GET SYSTEM NAME
	PUSHJ	STK,WRTSAV	;AND SAVE
	MOVE	SWRD,DFUADR	;GET ADRESS OF DEFAULT UNIT
	MOVE	SWRD,UNAM(SWRD)	;GET IT'S NAME
	PUSHJ	STK,WRTSAV	;AND WRITE INTO SAVE FILE
	SETZM	,CONADR		;SET UP NXTCON TO GET FIRST CONTROLLER
SAVCON:	PUSHJ	STK,NXTCON	;GET NEXT CONTROLLER
	JRST	,BRKSAV		;NO MORE CONTROLLERS, SAVE BREAK THINGS
	MOVE	CON,CONADR	;GET ADDRESS OF CDM
	MOVE	SWRD,DNAM(CON)	;GET CONTROLLER'S NAME
	PUSHJ	STK,WRTSAV	;AND WRITE INTO SAVE FILE
	SETZM	,REGADR		;SET UP NXTREG TO GET FIRST REGISTER
SAVREG:	PUSHJ	STK,NXTREG	;GET NEXT REGISTER
	JRST	,UNTSAV		;NO MORE REGISTERS, SAVE UCBS
	MOVE	RDB,REGADR	;GET RDB'S ADDRESS
	MOVE	SWRD,RNAM(RDB)	;GET REGISTER'S NAME
	PUSHJ	STK,WRTSAV	;AND SAVE
	LDB	SWRD,RPTR(RDB)	;GET REGISTER'S CONTENTS
	PUSHJ	STK,WRTSAV	;AND SAVE
	JRST	,SAVREG		;GO BACK FOR NEXT REGISTER

	PAGE
UNTSAV:	PUSHJ	STK,WRTZRO	;WRITE A ZERO TO MARK END OF REGISTERS.
	SETZM	,UNTADR		;SET UP NXTUNT TO GET FIRST UNIT
SAVUNT:	PUSHJ	STK,NXTUNT	;GET NEXT UNIT
	JRST	,CONSAV		;NO MORE UNITS, WRITE A ZERO, AND GO ON TO NEXT CONTROLLER
	HRRZ	UNIT,UNTADR	;GET UCB ADDRESS
	MOVE	SWRD,UNAM(UNIT)	;GET UNIT NAME
	PUSHJ	STK,WRTSAV	;AND SAVE
	MOVE	SWRD,UTIM(UNIT)	;GET UNIT'S SERVICE TIME
	MOVE	AC1,SYSLSP
	SUB	SWRD,@SYTIM(AC1)	;COMPUTE INCREMENTAL SERVICE TIME
	SKIPN	,UACT(UNIT)	;IS UNIT ACTIVE?
	SETOM	,SWRD		;NO, SAVE ALL ONES AS TIME
	PUSHJ	STK,WRTSAV	;WRITE TIME INTO SAVE FILE
	HLRZ	SWRD,USTAT(UNIT)	;GET MIMIC STATUS FLAGS
	PUSHJ	STK,WRTSAV	;AND SAVE
	TRNE	SWRD,QTTY	;IS UNIT ATTACHED TO CTY?
	JRST	,SAVTTY		;YES, GO SAVE DUMMY NAME.
	TRNN	SWRD,QDSK	;IS UNIT ATTACHED TO DISK?
	JRST	,CHKCOR		;NO, FAB IS IRRELEVANT, NEED TO SAVE FRAMES?
	HLRZ	FABADR,UFAB(UNIT)	;GET POINTER TO FAB FROM UCB
	MOVE	SWRD,FNAME(FABADR)	;GET FILE NAME
	PUSHJ	STK,WRTSAV		;AND SAVE
	HLRZ	SWRD,FEXT(FABADR)	;GET FILE EXTENSION
	PUSHJ	STK,WRTSAV		;AND SAVE
	MOVE	SWRD,FPJ(FABADR)	;FINALLY PROJ AND PROG NUMBERS
	PUSHJ	STK,WRTSAV		;AND SAVE
SAVTTF:	MOVE	SWRD,UFRM(UNIT)	;LAST BUT NOT LEAST, I/O FRAME NUMBER
	PUSHJ	STK,WRTSAV
CHKCOR:	HLRZ	AC1,DSTAT(CON)	;GET DEVICE FLAGS
	TRNN	AC1,QATBL	;IS DEVICE ATTACHABLE?
	TRNN	AC1,QADR	;NO, IS IT ADDRESSABLE?
	JRST	,SAVUNT		;NO, DON'T BOTHER
	MOVE	SWRD,DNFRM(CON)	;YES, GET NUMBER OF FRAMES ON DEVICE
	PUSHJ	STK,WRTSAV	;AND SAVE
	MOVEM	SWRD,ULIMIT	;SET UP UPPER LIMIT
	SETZB	AC1,LLIMIT	;START AT FRAME 0
	SETZM	,CORFLG		;CLEAR ZERO'S COUNTER.
SAVFRM:	MOVEM	AC1,FRMNUM	;SET FRAME# FROM LOWER LIMIT.
	PUSHJ	STK,GETFRM	;GET THAT FRAME!
	JRST	,SAVERR
	SKIPN	,VALUE		;IS IT ZERO?
	JRST	,FNDZRO		;YES
	PUSHJ	STK,OUTZRO	;NO, OUTPUT ANY ACCUMULATED ZEROS AND
	MOVE	SWRD,VALUE	;OUTPUT NEW VALUE.
	PUSHJ	STK,WRTSAV
NXTSAV:	AOS	AC1,LLIMIT	;BUMP LOWER LIMIT AND CONTINUE IF
	CAMGE	AC1,ULIMIT	;NOT DONE.
	JRST	,SAVFRM
	PUSHJ	STK,OUTZRO	;DONE, OUTPUT ANY ACCUMULATED ZEROES.
	JRST	,SAVUNT		;ON TO NEXT UNIT.
;
FNDZRO:	SOS	,CORFLG		;ZERO FOUND, DECREMENT COUNT
	JRST	,NXTSAV		;AND CONTINUE
;
OUTZRO:	SKIPE	SWRD,CORFLG	;GET ACCUMULATED ZEROES.
	PUSHJ	STK,WRTSAV	;OUTPUT IF ANY FOUND.
	SETZM	,CORFLG		;ZERO COUNTER.
	POPJ	STK,
;
SAVTTY:	PUSHJ	STK,WRTZRO	;ATTACHED TO CTY, WRITE FILE NAME OF
	PUSHJ	STK,WRTZRO	;ZEROS.
	PUSHJ	STK,WRTZRO
	JRST	,SAVTTF		;GO SAVE I/O FRAME NUMBER.

	PAGE
;A HANDFUL OF SUBROURINES ENCOUNTERED SO FAR

WRTZRO:	SETZ	SWRD,		;WRITE ZERO:  CLEAR WORD TO WRITE.
WRTSAV:	MOVEM	SWRD,UBUF+SAVUCB	;PUT WORD INTO BUFFER OF SAVE FILE'S UCB
	MOVEI	SUCB,SAVUCB	;SET UP .WRITE ARGUMENT.
	MOVEM	SUCB,.UCBAD
	PUSHJ	STK,.WRITE	;CALL CIO WRITE ROUTINE
	JRST	,WRTERR
	AOS	,UFRM+SAVUCB	;BUMP SAVE FILE FRAME POINTER
	POPJ	STK,		;AND RETURN

CONSAV:	PUSHJ	STK,WRTZRO	;WRITE ZERO, INDICATING END OF CTLR,
	JRST	,SAVCON		;AND GO ON TO NEXT

WRTERR:	POP	STK,JUNK	;GET RID OF RETURN FROM WRTSAV
SAVERR:	RSM			;REENTER SM
	CHMAF	CIOFAIL,I	;CALL CIOFAIL TO DIAGNOSE ERROE, AND GIVE FAIL RETURN

	PAGE
BRKSAV:	PUSHJ	STK,WRTZRO	;WRITE ZERO TO MARK END OF CTLRS.
	MOVE	BCT,BCTBOT	;INIT POINTER INTO BCT
SAVBRK:	ADDI	BCT,ENTSIZ	;BUMP POINTER TO NEXT ENTRY
	HRRZ	SWRD,BCTUCB(BCT)	;NO, GET UCB ADDRESS
	CAIN	SWRD,-1		;IS IT PHONY ENTRY?
	JRST	,ACTSAV		;YES, BREAKS ALL DONE, GO DO ACTIONS
	MOVE	SWRD,UNAM(SWRD)	;GET UCB'S NAME
	PUSHJ	STK,WRTSAV	;AND SAVE IT
	MOVE	SWRD,BCTLO(BCT)	;GET LOW FRAME
	PUSHJ	STK,WRTSAV	;AND SAVE
	MOVE	SWRD,BCTHI(BCT)	;GET HIGH FRAME
	PUSHJ	STK,WRTSAV	;AND SAVE
	HLLZ	SWRD,BCTBRK(BCT)	;GET BREAK BITS
	PUSHJ	STK,WRTSAV	;AND SAVE
	MOVE	SWRD,BCTACT(BCT)	;NOW, GET ACTION BITS
	PUSHJ	STK,WRTSAV		;AND SAVE
	MOVE	SWRD,BCTCNT(BCT)	;FINALLY, GET COUNT
	PUSHJ	STK,WRTSAV		;AND SAVE
	JRST	,SAVBRK		;GO GET NEXT ENTRY

	PAGE
ACTSAV:	PUSHJ	STK,WRTZRO	;WRITE ZERO TO MARK END OF BCT.
	MOVSI	ACT,-ACTMAX	;SAVE ACTIONS:  SET UP COUNTER/PTR IN TABLE.
SAVACT:	HRRZ	ACTWRD,ACTPTR(ACT)	;GET PTR TO ACTION.
	HRLI	ACTWRD,-ACTSIZ-1	;SET UP COUNTER IN LEFT HALF.
	SKIPN	,0(ACTWRD)	;IS ACTION EMPTY?
	JRST	,WNOACT	;YE WRITE A ZERO TO SIGNIFY THIS.
CHKACT:	MOVE	SWRD,0(ACTWRD)	;GET NEXT WORD OF ACTION.
	PUSHJ	STK,WRTSAV	;WRITE IT OUT.
	AOBJN	ACTWRD,CHKACT	;ADVANCE PTR IN ACTION. END? NO, GO BACK.
NXTOUT:	AOBJN	ACT,SAVACT	;YES, ADVANCE PTR IN ACTION TABLE.  END?
				;NO, GO ON TO NEXT ACTION.

SAVDON:	PUSHJ	STK,.DETAC	;DETACH (AND CLOSE, ETC.) SAVE FILE
	JRST	,SAVERR
	RSM			;BACK INTO SM
	RSS			;FOR SUCESS RETURN


WNOACT:	PUSHJ	STK,WRTZRO	;NO ACTION, WRITE 1 WORD OF ZEROES.
	JRST	,NXTOUT		;GO ON TO NEXT ACTION.
	PAGE
	SUBTTL	GETSUB - SUBROUTINE TO RESTORE A SAVE FILE

GETSUB:	CSSF	ANLFIL,I	;SET UP FILE THINGS
	SGD	.LEBLK+1,0,I	;IS EXTENSION NULL?
	LDG	.LEBLK+1,[SIXBIT /MIM/],D	;IF SO, SET TO "MIM"
	ASMF	RETURN,I	;GET TERMINATING CARRIAGE RETURN
	LDG	.UCBAD,SAVUCB,I	;SET UP .ATTAC ARGUMENT.
	LSM			;BACK TO 10 MODE
	SETZM	,QGO		;CLEAR 'GO-ABLE' FLAG
	MOVSI	AC1,QRD		;TURN ON READ-ONLY FLAG IN
	IORM	AC1,USTAT+SAVUCB	;SAVE-UCB.
	PUSHJ	STK,.ATTAC	;ATTACH THE SAVE FILE
	JRST	,SAVERR
	MOVE	AC1,SYSLSP	;GET POINTER TO SYSTEM LIST
	PUSHJ	STK,REDSAV	;READ SYSTEM NAME FROM SAVE FILE
	CAME	SWRD,SYNAME(AC1)	;COMPARE WITH THIS SYSTEM'S NAME
	JRST	,BADSYS		;DIFFERENT, COMPLAIN
	PUSHJ	STK,REDSAV	;GET DEFAULT UNIT NAME
	MOVEM	SWRD,NAME	;SET UP FNDUNT TO FIND IT
	PUSHJ	STK,FNDAUNT	;GO LOOK FOR IT , UNDER ALL CONTROLLERS
	JRST	,BADDEF		;NOT IN THIS MIMIC
	MOVE	UNIT,UNTADR	;GET UNITS ADDRESS
	MOVEM	UNIT,DFUADR	;AND SET UP AS DEFAULT
	HRRZ	AC1,UDDM(UNIT)	;GET PARENT DDM OF DEFAULT UNIT
	MOVEM	AC1,DFCADR	;AND SAVE

GETCON:	SETZM	,CONFLG		;CLEAR BAD CONTROLLER FLAG
	PUSHJ	STK,REDSAV	;GET A CONTROLLER NAME
	JUMPE	SWRD,BRKGET	;NO MORE CONTROLLERS, RESTORE BCT
	MOVEM	SWRD,NAME	;SET UP FNDCON TO FIND NAMED CONTROLLER
	PUSHJ	STK,FNDCON	;GO LOOK FOR IT
	JRST	,BADCON		;NOT FOUND, SAY SO

GETREG:	PUSHJ	STK,REDSAV	;NOW GET REGISTER NAME
	JUMPE	SWRD,GETUNT	;NO MORE REGISTERS, GET UNITS
	SKIPE	,CONFLG		;IS CONTROLLER BAD?
	JRST	,SKPREG		;IF SO, DON'T TRY TO RESTORE REGISTER
	MOVEM	SWRD,NAME	;SET UP FNDREG TO FIND NAMED REGISTER
	PUSHJ	STK,FNDREG	;LOOK FOR IT
	JRST	,BADREG		;COULDN'T, SAY SO
	MOVE	RDB,REGADR	;GET RDB'S ADDRESS
	PUSHJ	STK,REDSAV	;GET REGISTER CONTENTS
	DPB	SWRD,RPTR(RDB)	;AND RESTORE TO REGISTER
	JRST	,GETREG		;ON TO NEXT REGISTER

	PAGE
GETUNT:	MOVE	AC1,CONFLG	;USE GOOD/BAD CTLR FLAG AS
	MOVEM	AC1,UNTFLG	;INITIAL SETTING OF GOOD/BAD UNIT FLAG.
	PUSHJ	STK,REDSAV	;GET UNIT NAME
	JUMPE	SWRD,GETCON	;NO MORE UNITS, GO ON TO NEXT CONTROLLER
	SKIPE	,UNTFLG		;IS UNIT BAD?
	JRST	,SKPTIM		;IF SO, DON'T RESTORE SERVICE TIME
	MOVEM	SWRD,NAME	;SET UP FNDUNT TO FIND NAMED UNIT
	PUSHJ	STK,FNDUNT	;GO LOOK FOR IT
	JRST	,BADUNT		;COULDN'T, SAY SO
	MOVE	UNIT,UNTADR	;GET UCB'S ADDRESS
	MOVEM	UNIT,.UCBAD	;GIVE CIO UNIT'S ADDRESS
	PUSHJ	STK,.CNCEL	;AND DEACTIVATE UNIT
	PUSHJ	STK,REDSAV	;GET INCREMENTAL SERVICE TIME
	JUMPL	SWRD,GTUFRM	;UNIT NOT ACTIVE IF NEGATIVE
	MOVE	AC1,SYSLSP	;GET POINTER TO SYATEM LIST
	ADD	SWRD,@SYTIM(AC1)		;COMPUTE ABSOLUTE SERVICE TIME
	MOVEM	SWRD,UTIM(UNIT)	;AND GIVE TO UCB
	MOVEM	UNIT,.UCBAD	;GIVE CIO UNIT'S ADDRESS
	PUSHJ	STK,.ACTVT	;ACTIVATE THE UNIT

	PAGE

GTUFRM:
GTUSTA:	PUSHJ	STK,REDSAV	;GET MIMIC STATUS FLAGS
	MOVEM	SWRD,UNSTAT	;SAVE STATUS FOR LATER
	TRNN	SWRD,QATT	;WAS UNIT ATTACHED?
	JRST	,GETCOR		;NO, FAB IS IRRELEVANT
	SKIPE	,UNTFLG		;IS UNIT BAD?
	JRST	,SKPFAB		;IF SO, DON'T RESTORE FAB
	PUSHJ	STK,REDSAV	;GET FILE NAME
	MOVEM	SWRD,.LEBLK+0	;SETUP .LEBLK FOR ATTACH
	PUSHJ	STK,REDSAV	;GET FILE EXTENSION
	HRLZM	SWRD,.LEBLK+1	;SETUP EXTENSION
	PUSHJ	STK,REDSAV	;GET PROJRCT AND PROGRAMMER NUMBERS
	MOVEM	SWRD,.LEBLK+3	;AND FINALLY PROJ,PROG
	MOVEM	UNIT,.UCBAD	;GIVE UNIT'S ADDRESS TO CIO
	PUSHJ	STK,QAJAM	;JAM THIS FILE INTO ATTACH HANDLER.
	JFCL			;IGNORE ERRORS (QAJAM PRINTS MESSAGE)
	PUSHJ	STK,REDSAV	;GET I/O FRAME NUMBER
	MOVE	UNIT,UNTADR	;GET UNIT IT CAME FROM
	MOVEM	SWRD,UFRM(UNIT)	;AND RESTORE
	JRST	,GETUNT


SKPFAB:	MOVEI	AC1,4		;SKIP OVER FILE PARAMETERS
	ADDM	AC1,UFRM+SAVUCB
	JRST	,GETUNT		;UNIT WAS ATTACHED BUT BAD, CORE CAN'T HAVE BEEN SAVED

	PAGE
GETCOR:	MOVE	AC1,UNTFLG	;USE GOOD/BAD UNIT FLAG AS INITIAL
	MOVEM	AC1,CORFLG	;SETTING OF GOOD/BAD CORE FLAG.
	MOVE	AC1,UNSTAT	;GET DEVICE FLAGS
	TRNN	AC1,QATBL	;IS DEVICE ATTACHABLE?
	TRNN	AC1,QADR	;IS DEVICE ADDRESSABLE?
	JRST	,GETUNT		;NO, SAME THING
	PUSHJ	STK,REDSAV	;GET NUMBER OF FRAMES SAVED
SETCNT:	MOVEM	SWRD,ULIMIT	;SET UP COUNT
	SETZB	AC1,LLIMIT	;AND START AT FRAME 0
	SETZM	,UNTFLG		;ZERO THE BLOCK COUNTER.

FRMGET:	MOVEM	AC1,FRMNUM	;SET FRAME# FROM LOWER LIMIT.
	SKIPE	,UNTFLG		;ARE WE EXPANDING A ZERO BLOCK?
	JRST	,PUTZRO		;YES.
	PUSHJ	STK,REDSAV	;NO, READ SAVE FILE.
	JUMPL	SWRD,NEWZRO	;NEW BLOCK OF ZEROES?
	MOVEM	SWRD,VALUE	;NO, PREPARE TO STORE IN CORE.
PUTAWY:	SKIPE	,CORFLG		;CORE BAD?
	JRST	,CNTFRM		;THEN DON'T STORE
	PUSHJ	STK,PUTFRM	;PUT FRAME AWAY.
	JRST	,BADCOR		;ERROR.
CNTFRM:	AOS	AC1,LLIMIT	;BUMP LOWER LIMIT AND CONTINUE IF NOT
	CAMGE	AC1,ULIMIT	;DONE.
	JRST	,FRMGET
	JRST	,GETUNT		;ONTO NEXT UNIT.
;
NEWZRO:	MOVEM	SWRD,UNTFLG	;ZERO BLOCK, SAVE COUNT.
PUTZRO:	AOS	,UNTFLG		;INCREMENT COUNT.
	SETZM	,VALUE		;VALUE TO STORE IS ZERO.
	JRST	,PUTAWY		;GO PUT IT AWAY.

	PAGE
BRKGET:	PUSHJ	STK,REDSAV	;GET UNIT NAME OF BCT ENTRY
	JUMPE	SWRD,ACTGET	;IF 0, NO MORE ENTRIES
	MOVEM	SWRD,NAME	;SET UP FNDAUNT TO FIND NAMED UNIT
	PUSHJ	STK,FNDAUNT	;GO LOOK FOR IT
	JRST	,BADBRK		;COULDN'T FIND IT
	MOVE	AC1,UNTADR	;GOT IT, GET UCB ADDRESS
	HRRM	AC1,BRKBLK+BUCB	;AND SET UP
	PUSHJ	STK,REDSAV	;GET LOW FRAME OF BREAK
	MOVEM	SWRD,BRKBLK+BLO	;AND SET UP
	PUSHJ	STK,REDSAV	;GET HIGH FRAME
	MOVEM	SWRD,BRKBLK+BHI	;AND SET UP
	PUSHJ	STK,REDSAV	;NOW GET BREAK BITS
	HLLM	SWRD,BRKBLK+BBRK	;AND SET UP
	PUSHJ	STK,REDSAV	;NOW GET ACTIONS
	MOVEM	SWRD,BRKBLK+BACT
	PUSHJ	STK,REDSAV		;FINALLY GET THE BREAK COUNT
	MOVEM	SWRD,BRKBLK+BCNT
	PUSHJ	STK,BRKINS	;INSERT THE BREAK
BITLP:	MOVE	AC1,CONADR	;GET CURRENT CONTROLLER
	HLRZ	AC1,DBST(AC1)	;GET BREAK SET ROUTINE
	PUSHJ	STK,@AC1	;CALL IT
	JRST	BDBRK1		;ON ERROR, DIE
	AOS	AC1,BRKBLK+BLO	;GO TO NEXT FRAME IN RANGE
	CAMG	AC1,BRKBLK+BHI	;RANGE DONE?
	JRST	BITLP		;NO, GO BACK
	JRST	,BRKGET		;AND GET THE NEXT ONE

ACTGET:	MOVSI	ACT,-ACTMAX	;SET UP COUNTER/PTR IN ACTION TABLE.
GETACT:	HRRZ	ACTWRD,ACTPTR(ACT)	;GET NEXT ACTION ADDRESS
	HRLI	ACTWRD,-ACTSIZ-1	;SET UP COUNTER/PTR IN ACTION.
	PUSHJ	STK,REDSAV	;GET FIRST WORD OF ACTION.
	JUMPE	SWRD,NXTACT	;ZERO?  GO TO NEXT ACTION.
	JRST	,.+2	;NON-ZERO, JUMP INTO LOOP.
RSTACT:	PUSHJ	STK,REDSAV	;GET NEXT WORD OF ACTION.
	MOVEM	SWRD,0(ACTWRD)	;STORE IT IN ACTION BUFFER.
	AOBJN	ACTWRD,RSTACT	;ADVANCE PTR IN ACTION? END?  NO, GO BACK.
NXTACT:	AOBJN	ACT,GETACT	;YES, ADVANCE PTR IN ACTION TABLE.  END?
	JRST	,SAVDON		;YES, END OF SAVE.  NO, TO NEXT ACTION.

	PAGE
;ERROR HANDLERS FOR GET

BADSYS:	TTCALL	3,SYSTXT	;OUTPUT BAD SYSTEM NAME MESSAGE
	MOVEM	SWRD,NAME	;GET SYSTEM NAME
	PUSHJ	STK,WRTNAM	;AND OUTPUT IT
	TTCALL	3,CRLFST
	RSM
	RSRN			;GIVE FAIL RETURN

SYSTXT:	ASCIZ	/SYS: /

CRLFST:	ASCIZ	/
/


BADDEF:	TTCALL	3,DEFTXT	;OUTPUT BAD DEF UNIT MESSAGE
	PUSHJ	STK,WRTNAM	;AND NAME
	TTCALL	3,CRLFST
	JRST	,GETCON		;AND CONTINUE

DEFTXT:	ASCIZ	/DEF UNIT: /


BADCON:	TTCALL	3,CONTXT	;OUTPUT BAD CONTROLLER MESSAGE
	PUSHJ	STK,WRTNAM	;AND NAME
	TTCALL	3,CRLFST
	SETOM	,CONFLG		;SET BAD CONTROLLER FLAG
	JRST	,GETREG		;AND CONTINUE

CONTXT:	ASCIZ	/CON: /


BADREG:	TTCALL	3,REGTXT	;OUTPUT BAD REGISTER MESSAGE
	PUSHJ	STK,WRTNAM	;AND NAME
	TTCALL	3,CRLFST
SKPREG:	AOS	,UFRM+SAVUCB	;SKIP OVER REGISTER CONTENTS
	JRST	,GETREG		;AND CONTINUE

REGTXT:	ASCIZ	/REG: /


	PAGE

BADUNT:	TTCALL	3,UNTTXT	;OUTPUT BAD UNIT MESSAGE
	PUSHJ	STK,WRTNAM	;AND NAM@
	TTCALL	3,CRLFST
	SETOM	,UNTFLG		;TURN ON BAD UNIT FLAG
SKPTIM:	AOS	,UFRM+SAVUCB	;SKIP OVER SERVICE TIMG
	JRST	,GTUSTA		;AND GO GET STATUS TO SEE IF THERE'S A FAB

UNTTXT:	ASCIZ	/UNIT: /


BADCOR:	TTCALL	3,CORTXT	;OUTPUT CORE TOO LARGE MESSAGE
	PUSHJ	STK,WRTNAM	;OUTPUT UNIT NAME
	TTCALL	3,CRLFST	;FOLLOWED BY CR-LF.
	SETOM	,CORFLG		;TURN ON BAD CORE FLAG
	JRST	CNTFRM		;AND CONTINUE.

CORTXT:	ASCIZ	/FRAMES: /


BADBRK:	MOVEI	AC1,ENTSIZ
	ADDM	AC1,UFRM+SAVUCB	;SKIP OVER USELESS BREAK STUFF
BDBRK1:	TTCALL	3,BRKTXT	;OUTPUT BAD BREAK MESSAGE
	PUSHJ	STK,WRTNAM	;AND UNIT NAME
	TTCALL	3,CRLFST
	JRST	,BRKGET		;AND CONTINUE

BRKTXT:	ASCIZ	/ILL BRK: /


;READ ROUTINE FOR SAVE FILE

REDSAV:	MOVEI	SUCB,SAVUCB
	MOVEM	SUCB,.UCBAD
	PUSHJ	STK,.READ	;READ FRAME OF SAVE FILE
	JRST	,WRTERR
	AOS	,UFRM+SAVUCB	;BUMP FRAME FOR NEXT TIME
	MOVE	SWRD,UBUF+SAVUCB	;MAKE FRAME HANDY
	POPJ	STK,		;AND RETURN

	END
