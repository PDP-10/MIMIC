	TITLE PLUG	FRAME/REGISTER/BREAK/FILE TRANSMITTERS
	HISEG
	SALL
;
;THE SO-CALLED "PLUG" MODULE CONSISTS OF 4 GROUPS OF SUBROUTINES,
;DEALING WITH REGISTERS, FRAMES, BREAKS, AND FILE NAMES,
;RESPECTIVELY.  EACH GROUP CONSISTS OF FIVE SUBROUTINES:
;GETXXX	--GET ITEM XXX FROM THE VM'S OR MIMIC'S DATA BASE
;PUTXXX	--STORE REVISED ITEM XXX INTO THE DATA BASE
;WRTXXX	--TYPE XXX ON THE CONSOLE TELETYPE
;REDXXX	--READ AND ANALYZE A NEW XXX FROM THE CONSOLE
;ANLXXX --ANALYZE A NEW XXX
;
	INTERN REDFRM,WRTFRM,GETFRM,PUTFRM,ANLFRM
	INTERN INPUT,CINPUT
	INTERN REDREG,WRTREG,GETREG,PUTREG,ANLREG
	INTERN WRTBRK,GETBRK,PUTBRK,ANLBRK
	INTERN GETFIL,WRTFIL,ANLFIL

	EXTERN WRTNOL,REDINT,WRTINT	;REDWRT ROUTINES
	EXTERN REDNAM,WRTNAM,REDSTR

	EXTERN SMGR,BRKIDS,CONUCB	;DATA BASE
	EXTERN COMTXT,REDTXT,WRTTXT	;EDITOR

	EXTERN CIOFAIL,BKSRCH,BRKINS,BRKDEL,BRKPTR	;BREAK TABLE

	INTERN ABSSPC,TRMCR,FNDCR	;CHARACTER SEARCHERS
	INTERN ACTPNT,ACTOUT,USRACT	;ACTIONS

	AC1=10	;AC ASSIGNMENTS
	AC2=11
	AC3=12
	STK=17
	AC=7

;
;PLUG, PAGE 2
;REGISTER TRANSMISSION SUBROUTINES:
;GETREG--	C(SPECIFIED REG) --> VALUE
;WRTREG--	VALUE IS TYPED AS INDICATED BY REGISTER FORMAT
;REDREG--	READ NEW VALUE
;PUTREG--	VALUE --> C(SPECIFIED REG)
;
GETREG:	MOVE AC1,REGADR	;GET RDB ADDRESS.
	LDB AC1,RPTR(AC1)	;USE RDB BYTE PTR TO GET REG CONTENTS.
	MOVEM AC1,VALUE	;SAVE REG CONTENTS IN VALUE.
	POPJ STK,
;
WRTREG:	PUSHJ STK,SETREG	;SET UP RADIX+#BITS FROM RDB.
	PJRST WRTINT	;TYPE OUT VALUE IN INDICATED FORMAT.
;
ANLREG:	PUSHJ STK,SETREG	;SET UP RADIX+#BITS FROM RDB.
	PJRST REDINT	;ANALYZE THE REGISTER INPUT.
;
REDREG:	MOVE AC1,REGADR	;GET THE RDB ADDRESS.
	SKIPGE ,RFLGS(AC1)	;IS READ ONLY FLAG IN RDB SET?
	JRST RDONLY	;YES.
	PUSHJ STK,LINPUT	;NO, GET LOCAL INPUT.
	PUSHJ STK,ANLREG	;ANALYZE THE INPUT.
	PUSHJ STK,GETREG	;NO INPUT, RESTORE "VALUE" SO THAT
				;PUTREG WILL STORE OLD VALUE.
	PJRST FNDLOC	;GO LOOK FOR LOCAL TERMINATORS.
;
PUTREG:	MOVE AC1,REGADR	;GET REG ADDRESS.
	MOVE AC2,VALUE	;GET REGISTER INPUT.
	SKIPL ,RFLGS(AC1)	;IS REG READ-ONLY?
	DPB AC2,RPTR(AC1)	;NO, STORE NEW VALUE.
	POPJ STK,	;EXIT.
;
SETREG:	MOVE AC1,REGADR	;GET RDB ADDRESS.
	MOVE AC2,RFLGS(AC1)	;FROM RDB GET RADIX+#BITS.
	HRRZM AC2,NBITS	;STORE #BITS.
	TLZ AC2,400000	;CLEAR READ-ONLY FLAG AND STORE RADIX.
	HLRZM AC2,NRADIX
	POPJ STK,
;
RDONLY:	TTCALL 3,[BYTE (7)15,12(22)0]	;READ ONLY... SIMULATE
	JRST CPOPJ1	;CR-LF AND TAKE SKIP RETURN.
;
;PLUG, PAGE 3
;THE ANALAGOUS ROUTINES FOR FRAMES ARE RATHER HAIRIER.  SINCE FRAMES
;ARE NOT STORED UNIFORMLY, WE MUST BEHAVE JUST LIKE A CONTROLLER
;IN ATTEMPTING TO ACCESS THEM.  ACCORDINGLY, WE ISSUE A DUMMY CIO-
;READ TO GET FRAMES, AND A DUMMY CIO-WRITE TO STORE THEM.
;
GETFRM:	PUSHJ STK,SETCIO	;SET UP CALL ON CIO.
	MOVE AC1,CONADR	;GET THE CONTROLLER  ADDRESS.
	HLRZ AC1,DREAD(AC1)	;EXTRACT THE READ-ROUTINE ADDR.
	PUSHJ STK,@AC1	;CALL THE READ ROUTINE.
	POPJ STK,	;FAILURE.
	MOVE AC1,CONUCB+UBUF	;SUCCESS, GET FRAME FROM DUMMY-UNIT
	MOVEM AC1,VALUE	;BUFFER AND SAVE.
	JRST CPOPJ1	;TAKE SKIP RETURN.
;
WRTFRM:	PUSHJ STK,SETFRM	;SET UP RADIX/BITS INFORMATION.
	PJRST WRTINT	;TYPE OUT THE VALUE.
;
ANLFRM:	PUSHJ STK,SETFRM	;SET UP RADIX/BITS INFORMATION.
	PJRST REDINT	;ANALYZE THE INPUT.
;
REDFRM:	MOVE AC1,UNTADR	;GET THE UCB ADDR.
	HLRZ AC1,USTAT(AC1)	;GET THE UCB STATUS.
	TRNE AC1,QRD	;READ ONLY?
	JRST RDONLY	;YES.
	PUSHJ STK,LINPUT	;NO, GET INPUT.
	PUSHJ STK,ANLFRM	;ANALYZE IT.
	PUSHJ STK,GETFRM	;ON BAD INPUT, RESTORE THE OLD VALUE.
	JRST .+1	;IF GETFRM FAILS, IGNORE THE ERROR, SINCE
		;SUCH AN ERROR WOULD BE REPORTED AS LOCAL INPUT FAILURE.
		;INSTEAD, SIT BACK, AND LET PUTFRM GENERATE THE ERROR.
	PJRST FNDLOC	;GET THE LOCAL INPUT TERMINATOR.
;
PUTFRM:	MOVE AC1,UNTADR	;GET UCB ADDR.
	HLRZ AC1,USTAT(AC1)	;GET THE UCB STATUS.
	TRNE AC1,QRD	;READ ONLY?
	JRST CPOPJ1	;YES, TAKE SUCCESS RETURN.
	PUSHJ STK,SETCIO	;NO, SET UP CALL ON CIO.
	MOVE AC1,VALUE	;PUT VALUE INTO DUMMY-UNIT'S BUFFER.
	MOVEM AC1,CONUCB+UBUF
	MOVE AC1,CONADR	;GET THE CTLR ADDRESS.
	HRRZ AC1,DWRT(AC1)	;GET THE WRITE ROUTINE ADDR.
	PJRST @AC1	;CALL WRITE.
;
SETFRM:	MOVE AC1,CONADR	;GET CTLR ADDR.
	MOVE AC1,DVAL(AC1)	;GET CTLR RADIX+#BITS.
	HLRZM AC1,NRADIX	;STORE RADIX
	HRRZM AC1,NBITS	;STORE # BITS.
	POPJ STK,
;
SETCIO:	HRL AC1,UNTADR	;SET UP FOR CIO... TRANSFER CONTROL INFORMATION
	HRRI AC1,CONUCB	;FROM REAL UCB TO CONSOLE UCB.
	ADD AC1,[XWD UTIM+1,UTIM+1]	;BE SURE TO PRESERVE DUMMY
	BLT AC1,CONUCB+UFLGS	;UCB'S QUEUE-LINK AND TIME WORDS.
	MOVE AC1,FRMNUM	;SET UP FRAME# FOR TRANSFER.
	MOVEM AC1,CONUCB+UFRM
	MOVEI AC1,CONUCB	;SET UP CIO ARGUMENT WORD.
	MOVEM AC1,.UCBAD
	POPJ STK,
;
;PLUG, PAGE 4
;FOR FILE NAMES, WE HAVE ONLY THREE ROUTINES: GETFIL, WRTFIL, ANLFIL
;PUTFIL IS ACTUALLY ".ATTAC", WHILE REDFIL IS NOT NEEDED.
;
GETFIL:	CLEARM ,.LEBLK	;GETFIL... PUT UNIT'S FILE NAME INTO .LEBLK
	MOVE AC1,UNTADR	;GET THE UCB ADDR.
	HLRZ AC2,USTAT(AC1)	;GET THE STATUS.
	TRNN AC2,QATT	;IS THE UCB ATTACHED?
	POPJ STK,	;NO, FAIL.
	TRNE AC2,QTTY	;YES.  TO THE TTY?
	JRST CPOPJ1	;YES, TAKE SKIP RETURN.
	HLRZ AC1,UFAB(AC1)	;NO, GET FAB ADDRESS.
	MOVE AC2,FNAME(AC1)	;GET THE FILE NAME AND STORE
	MOVEM AC2,.LEBLK	;IN .LEBLK
	MOVE AC2,FEXT(AC1)	;GET THE EXTENSION AND STORE
	HLLZM AC2,.LEBLK+1	;IN .LEBLK
	MOVE AC2,FPJ(AC1)	;GET THE PROJECT#, PROG#
	MOVEM AC2,.LEBLK+3	;AND STORE IN LEBLK+3
	JRST CPOPJ1	;EXIT
;
WRTFIL:	SKIPN AC1,.LEBLK	;IS THERE ANY FILE NAME?
	JRST WRTCTY	;NO, TYPE OUT "CTY"
	MOVEM AC1,NAME	;YES, TYPE OUT THE FILE NAME.
	PUSHJ STK,WRTNAM
	HLLZ AC1,.LEBLK+1	;GET THE EXTENSION.
	JUMPE AC1,NOEXT	;ZERO?
	HLLZM AC1,NAME	;NO, TYPE "." FOLLOWED BY EXTENSION.
	OUTCHR [56]
	PUSHJ STK,WRTNAM
NOEXT:	SKIPN AC1,.LEBLK+3	;ANY PROJ# PROG#?
	POPJ STK,	;NO, EXIT
	HLRZM AC1,VALUE	;STORE PROJECT # FOR TYPING.
	OUTCHR [133]	;TYPE OUT "["
	MOVEI AC2,^D18	;SET UP OUTPUT BITS OF 18,
	MOVEM AC2,NBITS
	MOVEI AC2,^D8	;AND OUTPUT RADIX OF 8.
	MOVEM AC2,NRADIX
	PUSHJ STK,WRTNOL
	OUTCHR [54]	;TYPE ","
	HRRZ AC1,.LEBLK+3	;TYPE OUT PROGRAMMER#
	MOVEM AC1,VALUE
	PUSHJ STK,WRTNOL
	OUTCHR [135]	;TYPE OUT "]".
	POPJ STK,
;
WRTCTY:	OUTSTR [ASCIZ /CTY/]	;CTY... TYPE IT OUT.
	POPJ STK,
;
;PLUG, PAGE 5
;ANLFIL IS WRITTEN IS SM-CODE BECAUSE OF THE HAIR-RAISING
;CHARACTER ANALYSIS.
;
ANLFIL:	LDG .LEBLK+3,0,I
	CHMF REDSTR,I	;READ A NAME
	STG NAME,.LEBLK,D	;AND STORE IT AS FILE NAME.
	LDG NAME,0,I	;SET UP DEFAULT EXTENSION OF ZERO.
	MCHR PERIOD,I	;ANY EXTENSION?
	CHMF REDSTR,I	;YES, READ IT IN.
	MCH LBRACK,I	;ANY PROJECT#, PROGRAMMER#?
	JHM FINRED,I	;NO, GO CLEANUP IN -10 MODE.
	LDG NRADIX,^D8,I	;YES, PREPARE TO READ INTEGERS,
	LDG NBITS,^D17,I	;RADIX 8, LENGTH 17 BITS.
	CHMF REDINT,I	;READ AN INTEGER.
	MCHF COMMA,I	;LOOK FOR TRAILING ",".
	STG VALUE,SCHVAL,D	;STORE THE VALUE TEMPORARILY.
	CHMF REDINT,I	;READ ANOTHER INTEGER.
	MCHF RBRACK,I	;LOOK FOR TRAILING "]".
	LSM		;BACK TO -10 MODE TO PUT IT ALL TOGETHER.
	HRR AC1,VALUE	;AMALGAMATE THE PROJECT#, PROGRAMMER#
	HRL AC1,SCHVAL
	MOVEM AC1,.LEBLK+3	;AND SAVE.
FINRED:	MOVE AC1,NAME	;PUT EXTENSION, IF ANY, INTO PLACE.
	HLLZM AC1,.LEBLK+1
	RSM
	RSS		;DONE.
;
;PLUG, PAGE 6
;BREAK TRANSMISSION IS EVEN MORE COMPLICATED, BUT THE TRULY
;DIRTY WORK, NAMELY THE MANIPULATION OF THE BREAK-TABLE, IS
;DONE IN ANOTHER MODULE.
;
	FNDFLG=UNDO	;DO+BLO IS ACTUALLY BRKBLK+BCNT
	BRKCNT=UNDO+1	;TEMPORARY BREAK COUNT HOLDER
;
GETBRK:	CLEARM ,FNDFLG	;CLEAR "BREAK FOUND" FLAG.
	CLEARM ,BRKBLK+BACT	;CLEAR THE ACTION AND BREAK BITS
	CLEARM ,BRKBLK+BBRK	;IN THE BREAK INTERFACE.
	PUSHJ STK,SETBRK	;SET UP UNIT+ADDRESS.
	PUSHJ STK,BKSRCH	;SEARCH FOR BREAK.
	POPJ STK,	;NOT FOUND.
	SETOM ,FNDFLG	;FOUND, SET "BREAK FOUND" FLAG.
	MOVE AC,BRKPTR	;GET PTR TO BREAK ENTRY.
	MOVE AC1,BCTBRK(AC)	;GET THE BREAK BITS AND
	HLLM AC1,BRKBLK+BBRK	;STORE THEM IN BRKBLK.
	MOVE AC1,BCTACT(AC)	;GET THE ACTION BITS AND
	MOVEM AC1,BRKBLK+BACT	;STORE THEM IN BRKBLK.
	MOVE AC1,BCTCNT(AC)	;GET THE COUNT FIELD
	MOVEM AC1,BRKBLK+BCNT	;AND STORE IT IN BRKBLK.
	JRST CPOPJ1	;FOUND, TAKE SKIP RETURN.
;
PUTBRK:	PUSHJ STK,SETBRK	;SET UP BRKBLK UNIT+ADDRESS FIELDS.
	MOVE AC,BRKBLK+BACT	;GET THE ACTION-WORD.
	IOR AC,DO+BACT	;SET THE INDICATED ACTIONS.
	ANDCM AC,UNDO+BACT	;CLEAR THE INDICATED ACTIONS.
	MOVEM AC,BRKBLK+BACT	;STORE UPDATED ACTION-WORD.
	HLLZ AC,BRKBLK+BBRK	;GET THE BREARK-WORD.
	IOR AC,DO+BBRK	;SET AND CLEAR THE INDICATED BREAKS.
	ANDCM AC,UNDO+BBRK
	HLLM AC,BRKBLK+BBRK	;STORE UPDATED BREAKS-WORD.
	MOVE AC,BRKCNT	;STORE NEW BREAK COUNT.
	MOVEM AC,BRKBLK+BCNT
;
	MOVE AC,CONADR	;WE MUST NOW INFORM THE VM
	HLRZ AC,DBST(AC)	;THAT THE BREAK IS THERE OR GONE.
	PUSHJ STK,@AC	;CALL THE INFORM-VM ROUTINE.
	POPJ STK,	;VM SAYS FUCK YOU.
	HLRZ AC,BRKBLK+BBRK	;IS THERE ANY NEW BREAK OR ACTIONS?
	SKIPN ,BRKBLK+BACT
	JUMPE AC,NOBRK	;NO.
	PUSHJ STK,BRKINS	;YES, INSERT THE NEW BREAK.
	JRST CPOPJ1
NOBRK:	SKIPE ,FNDFLG	;WAS THERE A BREAK ORGINALLY? NO, DO NOTHING.
	PUSHJ STK,BRKDEL	;YES, DELETE THE BREAK.
	JRST CPOPJ1
;
SETBRK:	MOVE AC1,FRMNUM	;SET UP BRKBLK FRAME# AND UNIT FIELDS.
	MOVEM AC1,BRKBLK+BLO
	MOVEM AC1,BRKBLK+BHI
	MOVE AC1,UNTADR
	HRRM AC1,BRKBLK+BUCB
	POPJ STK,
;
;PLUG, PAGE 7
;WRTBRK TYPES OUT THE CURRENTLY SET BREAKS AND ACTIONS.
;
WRTBRK:	HLLZ AC,BRKBLK+BBRK	;GET THE BREAK BITS.
	MOVEI AC1,BRKIDS-1	;SOME ON, SET UP MOVING INDEX IN
	PUSHJ STK,GETBIT	;BREAK-STRING TABLE.  GET FIRST BREAK BIT.
	JRST WRTCNT	;NONE FOUND.
WNXTB:	MOVEM AC1,TXTADR	;FOUND, TABLE INDEX HAS BEEN MOVED
	PUSHJ STK,WRTTXT	;ACCORDINGLY.  TYPE OUT BREAK NAME.
	PUSHJ STK,GETBIT	;GET NEXT BIT.
	JRST WRTCNT	;NONE FOUND.
	OUTCHR [54]	;FOUND, TYPE "," BETWEEN BREAKS.
	JRST WNXTB	;GO TYPE BREAK.
;
WRTCNT:	SKIPN AC1,BRKBLK+BCNT	;GET THE COUNT FIELD.  ZERO?
	JRST WRTACT	;YES, DONT PRINT IT.
	OUTCHR ["("]	;NON-ZERO, PRINT "(".
	PUSHJ STK,ACTOUT	;TYPE OUT COUNT AS DECIMAL NUMBER.
	OUTCHR [")"]	;PRINT CLOSING ")".
;
WRTACT:	MOVE AC,BRKBLK+BACT	;GET THE ACTION BITS.
	CLEAR AC1,	;CLEAR ACTION# COUNTER.
	PUSHJ STK,GETBIT	;GET THE FIRST NON-ZERO BIT.
	POPJ STK,	;NONE FOUND, EXIT.
	OUTCHR [73]	;SOME FOUND, TYPE ; BETWEEN BREAKS AND ACTIONS
WNXTA:	CAIN AC1,^D36	;IS BIT = 36?
	JRST TYPC	;YES, ACTION "C"
	PUSHJ STK,ACTOUT	;NO, TYPE BIT# AS ACTION#.
GTNXTA:	PUSHJ STK,GETBIT	;GET THE NEXT BIT.
	POPJ STK,	;NONE FOUND, EXIT.
	OUTCHR [54]	;TYPE "," BETWEEN ACTIONS, CONTINUE.
	JRST WNXTA
;
TYPC:	OUTCHR ["C"]	;"C" ACTION... TYPE IT.
	JRST GTNXTA	;GO TO NEXT BIT.
;
GETBIT:	JUMPE AC,FAIL10	;ANY BITS LEFT? NO, FAIL.
	JUMPL AC,GOTBIT	;YES, DO WE HAVE THE BIT IN HAND?
	LSH AC,1	;NO, SSHIFT 1, ADD 1 TO COUNT.
	AOJA AC1,GETBIT
;
GOTBIT:	LSH AC,1	;BIT IN HAND, SHIFT ANYWAY.
	AOJA AC1,CPOPJ1	;GO TAKE SKIP RETURN.
;
;A FEW RANDOM TYPING ROUTINES:
;ACTPNT:	PRINT THE ACTION# IN "FRMNUM"
;ACTOUT:	PRINT THE ACTION# IN AC1.
;
ACTPNT:	OUTSTR [ASCIZ /ACTION /]	;IDENTIFY ACTIONS.
	MOVE AC1,FRMNUM	;GET THE BIT #.
	ADDI AC1,1	;ACTION# = BIT #+1
ACTOUT:	MOVEI AC2,^D35	;FOR ACTIONS, SET BIT WIDTH OF ^D35.
	MOVEM AC2,NBITS
	MOVEI AC2,^D10	;FOR ACTIONS, SET TYPING RADIX OF 10.
	MOVEM AC2,NRADIX
	MOVEM AC1,VALUE	;STORE VALUE TO BE TYPED.
	PJRST WRTNOL	;TYPE IT OUT WITHOUT LEADING ZEROES.
;
;PLUG, PAGE 8
;REDBRK AND ANLBRK ARE AGAIN SO COMPLICATED THAT PERFORCE WE
;MUST DO IT WITH SM-CODE.
;
ANLBRK:	CLEARM ,UNDO+BACT	;CLEAR THE "DO" AND "UNDO" BITS
	CLEARM ,UNDO+BBRK	;FOR BOTH BREAKS AND ACTIONS.
	CLEARM ,DO+BACT
	CLEARM ,DO+BBRK
	CLEARM ,BRKCNT	;ALSO CLEAR THE BREAK COUNT.
	RSM		;BACK TO SM-MODE.
BRKSYN:	ASM MINUS,I	;LOOK FOR "-".
	JMP TRYSET,I	;NOT FOUND, TRY FOR BREAK-SET.
	CSS BRKTYP,I	;FOUND, LOOK FOR BREAK IDENTIFIER.
	JMP ALLBRK,I	;NO BREAK, GO SEE IF "CLEAR ALL BREAKS".
	CHMN UNDOBR,I	;BREAK FOUND, SET BIT IN "UNDO BREAK".
MORBRK:	ASMR COMMA,I	;LOOK FOR ",".
	JMP BRKSYN,I	;FOUND, GO BACK TO START OF BREAK SYNTAX.
TRYCNT:	ASM LPAREN,I	;LOOK FOR "(", MEANING COUNT.
	JMP TRYSEM,I	;NOT FOUND, TRY FOR ";".
	LDG NRADIX,^D10,I	;FOUND, SET UP
	LDG NBITS,^D35,I	;REDINT FOR DECIMAL INPUT.
	CHMR REDINT,I	;READ COUNT.
	ASM RPAREN,I	;ABSORB TRAILING ")".
	JHM FAIL10,I	;ON ERROR, DIE.
	STG VALUE,BRKCNT,D	;STORE COUNT.
TRYSEM:	ASM SEMCOL,I	;NOT FOUND, LOOK FOR ";".
	JMP TRYCR,I	;NO ";", WE HAD BETTER FIND CR-LF.
ACTSYN:	ASM MINUS,I	;AFTER ";", LOOK FOR ACTIONS.  ANY "-"?
	JMP ACTSET,I	;NO, TRY FOR ACTION-SET.
	CSS ACTTYP,I	;YES, LOOK FOR AN ACTION#.
	JMP ALLACT,I	;NOT FOUND, GO LOOK FOR CR-LF.
	CHMN UNDOAC,I	;FOUND, SET BIT IN "UNDO ACTIONS".
MORACT:	ASMR COMMA,I	;LOOK FOR ",".
	JMP ACTSYN,I	;COMMA FOUND, START OVER.
TRYCR:	ASM RETURN,I	;NO COMMA, END OF ACTIONS.  BETTER FIND CR-LF.
	JHM FAIL10,I	;NO CR-LF, FAIL.
	JHM GOOD10,I	;OTHERWISE, RETURN TO -10 MODE AND SKIP.
;
TRYSET:	CSS BRKTYP,I	;LOOKING FOR BREAKS... ARE THERE ANY?
	JMP TRYCNT,I	;NO, GO LOOK FOR END OF BREAK FIELD.
	CHMN DOBRK,I	;YES, SET BIT IN "DO BREAK".
	JMP MORBRK,I	;LOOK FOR MORE BREAK INFORMATION.
;
ALLBRK:	ASM SEMCOL,I	;IN BREAK FIELD, "-" WITH OUT A BREAK IDENTIFIER.
	JMP TRYALL,I	;IS IT FOLLOWED BY ";", MEANING CLEAR ALL BREAKS?
			;NO, LOOK FOR CR-LF, MEANING CLEAR EVERYTHING.
	XHMN BCLRAL,D	;YES, CLEAR ALL BREAKS BY SETTING ALL BITS IN UNDO.
	JMP ACTSYN,I	;LOOK FOR ACTIONS.
;
ACTSET:	CSS ACTTYP,I	;LOOKING FOR ACTIONS... ARE THERE ANY?
	JMP TRYCR,I	;NO, GO LOOK FOR END OF ACTION FIELD.
	CHMN DOACT,I	;YES, SET BIT IN "DO ACTION".
	JMP MORACT,I	;GO BACK FOR MORE.
;
TRYALL:	ASM RETURN,I	;"-" FOLLOWED NEITHER BY BREAK ID OR ";"
			;LOOK FOR CR-LF, MEANING CLEAR ALL ACTIONS.
	JHM FAIL10,I	;NOT FOUND, DIE.
	LSM		;FOUND, BACK TO -10 MODE.
BCLRAL:	HRROS ,UNDO+BBRK	;CLEAR ALL BREAKS.
ACLRAL:	SETOM ,UNDO+BACT	;CLEAR ALL ACTIONS.
	JRST GOOD10	;TAKE SKIP RETURN.
;
ALLACT:	ASM RETURN,I	;";-" NOT FOLLOWED BY ACTION#.  CR-LF?
	JHM FAIL10,I	;NO, FAIL.
	JHM ACLRAL,I	;YES, CLEAR ALL BREAKS.
;
;PLUG, PAGE 9
;MISCELLANEOUS ROUTINES FOR BREAKS AND ACTIONS
;
ACTTYP:	ASMR CCC,I	;LOOK FOR ACTION... IS IT "C"?
	JMP CFND,I	;YES, GO SET ACTION #36.
USRACT:	LDG NRADIX,^D10,I	;NO, SET RADIX OF 10, BIT LENGTH OF 6.
	LDG NBITS,6,I
	CHMF REDINT,I	;LOOK FOR INTEGER.
	CHMF VALACT,I	;VALIDATE IT AS AN ACTION#.
	ADG VALUE,[-1],D	;CONVERT ACTION# TO BIT#.
	RSS		;DONE.
CFND:	LDG VALUE,^D35,I	;"C" IS ACTION 36= BIT 35.
	RSS
;
VALACT:	MOVE AC1,VALUE	;VALIDATE ACTION... ACTION #S
	JUMPE AC1,VALFL	;MUST BE >0 AND <36.
	CAIG AC1,^D35
CPOPJ1:
GOOD10:	AOS ,0(STK)
FAIL10:
VALFL:	POPJ STK,
;
BRKTYP:	LDG VALUE,0,I	;SET INDEX OF ZERO.
	SMZRF BRKIDS,XD,VALUE	;END OF TABLE (ZERO ENTRY?). YES, FAIL.
;[NOTE THAT SMZRF IS SKIP ON ZERO REVERSED-FAIL =SKIP ON NON-ZERO FAIL
; =PROCEED ON NON-ZERO, FAIL ON ZERO]
	ASMR BRKIDS,XD,VALUE	;NO, MATCH?
	RSS		;YES, RETURN.
	ADG VALUE,1,I	;NO, ADD 1 TO INDEX AND CONTINUE SEARCH.
	JMP BRKTYP+1,I
;
UNDOAC:	PUSHJ STK,SETBIT	;UNDO ACTION... SET BIT IN UNDO+BACT
	IORM AC+1,UNDO+BACT
	POPJ STK,
;
UNDOBRK:	PUSHJ STK,SETBIT
	IORM AC+1,UNDO+BBRK
	POPJ STK,
;
DOACT:	PUSHJ STK,SETBIT
	IORM AC+1,DO+BACT
	POPJ STK,
;
DOBRK:	PUSHJ STK,SETBIT
	IORM AC+1,DO+BBRK
	POPJ STK,
;
SETBIT:	HRLZI AC+1,400000	;SET BIT... CONVERT VALUE TO A BIT
	MOVN AC,VALUE	;POSITION.
	LSH AC+1,(AC)
	POPJ STK,
;
;PLUG, PAGE 10
;UTILITY ROUTINES FOR CONSYN AND PLUG:
;ABSSPC		ABSORB SPACES
;INPUT		READ NEW NON-LOCAL INPUT
;LINPUT		READ NEW LOCAL INPUT
;FNDCR		LOOK FOR CR.
;TRMCR		LOOK FOR / ? : _
;FNDLOC		LOOK FOR LOCAL INPUT TERMINATOR.
;
CINPUT:	MOVEI AC1,COMTRM
	JRST INPUT+1
LINPUT:	SKIPA AC1,[LCTRM]	;SET UP LOCAL-INPUT TERMINATORS.
INPUT:	MOVEI AC1,NLOCTRM	;SET UP NON-LOCAL TERMINATORS.
	MOVEM AC1,TXTTRM
	MOVE AC1,[POINT 6,COMTXT,5]	;SET UP NEW SYNTAX
	MOVEM AC1,SMPTR	;INPUT POINTER AND ALSO INPUT BUFFER ADDRESS.
	HRRZM AC1,TXTADR
	PJRST REDTXT	;GET THE INPUT.
;
NLOCAL:	TCRTN	;SYNTAX TERMINATOR.... NON-LOCAL INPUT.
	Z
NLOCTRM:	TLNFEED	;INPUT TERMINATOR... NON-LOCAL INPUT.
	Z
;
LOCAL:	TCRTN	;SYNTAX TERMINATORS... LOCAL INPUT
LCTRM:	TINDCT	;INPUT TERMINATORS... LOCAL INPUT
	TEFA
	TFWD
	TBKWD
	Z
;
COMTRM:	TLNFEED	;INPUT TERMINATORS... COMMAND INPUT
	TDSPLY
	TOPEN
	TINPT
	Z
COMMND:	TDSPLY	;SYNTAX TERMINATORS... COMMAND INPUT.
	TOPEN
	TJAM
	TINPT
	Z
;
FNDCR:	MOVEI AC1,NLOCAL	;SET UP SEARCH FOR CR.
MSTSCH:	PUSHJ STK,ABSSPC	;ABSORB LEADING SPACES.
	LDB AC3,SMPTR	;GET NEXT CHARACTER (DO NOT MOVE SMPTR).
MLOOP:	SKIPN ,(AC1)	;END OF TERMINATOR TABLE?
	POPJ STK,	;YES, FAIL.
	CAME AC3,(AC1)	;NO, DOES CHAR= TABLE ENTRY.
	AOBJP AC1,MLOOP	;NO, ADD 1 TO INDEX AND LOOP.
	IBP ,SMPTR	;YES, ADVANCE SMPTR OVER CHARACTER.
	JRST CPOPJ1
;
FNDLOC:	MOVEI AC1,LOCAL	;SEARCH FOR LOCAL INPUT TERMINATORS...
	PUSHJ STK,MSTSCH	;DO MASTER SEARCH.
	POPJ STK,	;FAILS.
	HLRZM AC1,LOCTRM	;OK, STORE TERMINATOR #.
	JRST CPOPJ1
;
TRMCR:	MOVEI AC1,COMMND	;SEARCH FOR COMMAND INPUT TERMINATORS...
	PUSHJ STK,MSTSCH	;DO MASTER SEARCH.
	POPJ STK,
	HLRZM AC1,TRM
	JRST CPOPJ1
;
ABSSLP:	IBP ,SMPTR	;GO TO NEXT CHARACTER...
ABSSPC:	LDB AC2,SMPTR	;GET NEXT CHARACTER (DO NOT CHANGE SMPTR).
	CAIE AC2,TSPACE	;IS IT SPACE?
	CAIN AC2,TTAB	;NO, IS IT TAB?
	JRST ABSSLP	;YES, GO TO NEXT CHAR.
	POPJ STK,	;NO, EXIT.
;
	END
