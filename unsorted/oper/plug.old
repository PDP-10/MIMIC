	TITLE PLUG	FRAME/REGISTER/BREAK/FILE TRANSMITTERS
	HISEG
	SALL
;
;THE SO-CALLED "PLUG" MODULE CONSISTS OF 4 GROUPS OF SUBROUTINES,
;DEALING WITH REGISTERS, FRAMES, BREAKS, AND FILE NAMES,
;RESPECTIVELY.  EACH GROUP CONSISTS OF FIVE SUBROUTINES:
;GETXXX	--GET ITEM XXX FROM THE VM'S OR MIMIC'S DATA BASE
;PUTXXX	--STORE REVISED ITEM XXX INTO THE DATA BASE
;WRTXXX	--TYPE XXX ON THE CONSOLE TELETYPE
;REDXXX	--READ AND ANALYZE A NEW XXX FROM THE CONSOLE
;ANLXXX --ANALYZE A NEW XXX
;
	INTERN REDFRM,WRTFRM,GETFRM,PUTFRM,ANLFRM
	INTERN INPUT,CINPUT
	INTERN REDREG,WRTREG,GETREG,PUTREG,ANLREG
	INTERN WRTBRK,GETBRK,PUTBRK,ANLBRK
	INTERN GETFIL,WRTFIL,ANLFIL

	EXTERN WRTNOL,REDINT,WRTINT	;REDWRT ROUTINES
	EXTERN REDNAM,WRTNAM,REDSTR

	EXTERN SMGR,BRKIDS,CONUCB	;DATA BASE
	EXTERN COMTXT,REDTXT,WRTTXT	;EDITOR

	EXTERN CIOFAIL,BKSRCH,BRKINS,BRKDEL,BRKPTR	;BREAK TABLE

	INTERN ABSSPC,TRMCR,FNDCR	;CHARACTER SEARCHERS
	INTERN ACTPNT,ACTOUT,USRACT	;ACTIONS

	AC1=10	;AC ASSIGNMENTS
	AC2=11
	AC3=12
	STK=17
	AC=7

;
;PLUG, PAGE 2
;REGISTER TRANSMISSION SUBROUTINES:
;GETREG--	C(SPECIFIED REG) --> VALUE
;WRTREG--	VALUE IS TYPED AS INDICATED BY REGISTER FORMAT
;REDREG--	READ NEW VALUE
;PUTREG--	VALUE --> C(SPECIFIED REG)
;
GETREG:	MOVE AC1,REGADR	;GET RDB ADDRESS.
	LDB AC1,RPTR(AC1)	;USE RDB BYTE PTR TO GET REG CONTENTS.
	MOVEM AC1,VALUE	;SAVE REG CONTENTS IN VALUE.
	POPJ STK,
;
WRTREG:	PUSHJ STK,SETREG	;SET UP RADIX+#BITS FROM RDB.
	PJRST WRTINT	;TYPE OUT VALUE IN INDICATED FORMAT.
;
ANLREG:	PUSHJ STK,SETREG	;SET UP RADIX+#BITS FROM RDB.
	PJRST REDINT	;ANALYZE THE REGISTER INPUT.
;
REDREG:	MOVE AC1,REGADR	;GET THE RDB ADDRESS.
	SKIPGE ,RFLGS(AC1)	;IS READ ONLY FLAG IN RDB SET?
	JRST RDONLY	;YES.
	PUSHJ STK,LINPUT	;NO, GET LOCAL INPUT.
	PUSHJ STK,ANLREG	;ANALYZE THE INPUT.
	PUSHJ STK,GETREG	;NO INPUT, RESTORE "VALUE" SO THAT
				;PUTREG WILL STORE OLD VALUE.
	PJRST FNDLOC	;GO LOOK FOR LOCAL TERMINATORS.
;
PUTREG:	MOVE AC1,REGADR	;GET REG ADDRESS.
	MOVE AC2,VALUE	;GET REGISTER INPUT.
	SKIPL ,RFLGS(AC1)	;IS REG READ-ONLY?
	DPB AC2,RPTR(AC1)	;NO, STORE NEW VALUE.
	POPJ STK,	;EXIT.
;
SETREG:	MOVE AC1,REGADR	;GET RDB ADDRESS.
	MOVE AC2,RFLGS(AC1)	;FROM RDB GET RADIX+#BITS.
	HRRZM AC2,NBITS	;STORE #BITS.
	TLZ AC2,400000	;CLEAR READ-ONLY FLAG AND STORE RADIX.
	HLRZM AC2,NRADIX
	POPJ STK,
;
RDONLY:	TTCALL 3,[BYTE (7)15,12(22)0]	;READ ONLY... SIMULATE
	JRST CPOPJ1	;CR-LF AND TAKE SKIP RETURN.
;
;PLUG, PAGE 3
;THE ANALAGOUS ROUTINES FOR FRAMES ARE RATHER HAIRIER.  SINCE FRAMES
;ARE NOT STORED UNIFORMLY, WE MUST BEHAVE JUST LIKE A CONTROLLER
;IN ATTEMPTING TO ACCESS THEM.  ACCORDINGLY, WE ISSUE A DUMMY CIO-
;READ TO GET FRAMES, AND A DUMMY CIO-WRITE TO STORE THEM.
;
GETFRM:	PUSHJ STK,SETCIO	;SET UP CALL ON CIO.
	MOVE AC1,CONADR	;GET THE CONTROLLER  ADDRESS.
	HLRZ AC1,DREAD(AC1)	;EXTRACT THE READ-ROUTINE ADDR.
	PUSHJ STK,@AC1	;CALL THE READ ROUTINE.
	POPJ STK,	;FAILURE.
	MOVE AC1,CONUCB+UBUF	;SUCCESS, GET FRAME FROM DUMMY-UNIT
	MOVEM AC1,VALUE	;BUFFER AND SAVE.
	JRST CPOPJ1	;TAKE SKIP RETURN.
;
WRTFRM:	PUSHJ STK,SETFRM	;SET UP RADIX/BITS INFORMATION.
	PJRST WRTINT	;TYPE OUT THE VALUE.
;
ANLFRM:	PUSHJ STK,SETFRM	;SET UP RADIX/BITS INFORMATION.
	PJRST REDINT	;ANALYZE THE INPUT.
;
REDFRM:	MOVE AC1,UNTADR	;GET THE UCB ADDR.
	HLRZ AC1,USTAT(AC1)	;GET THE UCB STATUS.
	TRNE AC1,QRD	;READ ONLY?
	JRST RDONLY	;YES.
	PUSHJ STK,LINPUT	;NO, GET INPUT.
	PUSHJ STK,ANLFRM	;ANALYZE IT.
	PUSHJ STK,GETFRM	;ON BAD INPUT, RESTORE THE OLD VALUE.
	JRST .+1	;IF GETFRM FAILS, IGNORE THE ERROR, SINCE
		;SUCH AN ERROR WOULD BE REPORTED AS LOCAL INPUT FAILURE.
		;INSTEAD, SIT BACK, AND LET PUTFRM GENERATE THE ERROR.
	PJRST FNDLOC	;GET THE LOCAL INPUT TERMINATOR.
;
PUTFRM:	MOVE AC1,UNTADR	;GET UCB ADDR.
	HLRZ AC1,USTAT(AC1)	;GET THE UCB STATUS.
	TRNE AC1,QRD	;READ ONLY?
	JRST CPOPJ1	;YES, TAKE SUCCESS RETURN.
	PUSHJ STK,SETCIO	;NO, SET UP CALL ON CIO.
	MOVE AC1,VALUE	;PUT VALUE INTO DUMMY-UNIT'S BUFFER.
	MOVEM AC1,CONUCB+UBUF
	MOVE AC1,CONADR	;GET THE CTLR ADDRESS.
	HRRZ AC1,DWRT(AC1)	;GET THE WRITE ROUTINE ADDR.
	PJRST @AC1	;CALL WRITE.
;
SETFRM:	MOVE AC1,CONADR	;GET CTLR ADDR.
	MOVE AC1,DVAL(AC1)	;GET CTLR RADIX+#BITS.
	HLRZM AC1,NRADIX	;STORE RADIX
	HRRZM AC1,NBITS	;STORE # BITS.
	POPJ STK,
;
SETCIO:	HRL AC1,UNTADR	;SET UP FOR CIO... TRANSFER CONTROL INFORMATION
	HRRI AC1,CONUCB	;FROM REAL UCB TO CONSOLE UCB.
	ADD AC1,[XWD UTIM+1,UTIM+1]	;BE SURE TO PRESERVE DUMMY
	BLT AC1,CONUCB+UFLGS	;UCB'S QUEUE-LINK AND TIME WORDS.
	MOVE AC1,FRMNUM	;SET UP FRAME# FOR TRANSFER.
	MOVEM AC1,CONUCB+UFRM
	MOVEI AC1,CONUCB	;SET UP CIO ARGUMENT WORD.
	MOVEM AC1,.UCBAD
	POPJ STK,
;
;PLUG, PAGE 4
;FOR FILE NAMES, WE HAVE ONLY THREE ROUTINES: GETFIL, WRTFIL, ANLFIL
;PUTFIL IS ACTUALLY ".ATTAC", WHILE REDFIL IS NOT NEEDED.
;
GETFIL:	CLEARM ,.LEBLK	;GETFIL... PUT UNIT'S FILE NAME INTO .LEBLK
	MOVE AC1,UNTADR	;GET THE UCB ADDR.
	HLRZ AC2,USTAT(AC1)	;GET THE STATUS.
	TRNN AC2,QATT	;IS THE UCB ATTACHED?
	POPJ STK,	;NO, FAIL.
	TRNE AC2,QTTY	;YES.  TO THE TTY?
	JRST CPOPJ1	;YES, TAKE SKIP RETURN.
	HLRZ AC1,UFAB(AC1)	;NO, GET FAB ADDRESS.
	MOVE AC2,FNAME(AC1)	;GET THE FILE NAME AND STORE
	MOVEM AC2,.LEBLK	;IN .LEBLK
	MOVE AC2,FEXT(AC1)	;GET THE EXTENSION AND STORE
	HLLZM AC2,.LEBLK+1	;IN .LEBLK
	MOVE AC2,FPJ(AC1)	;GET THE PROJECT#, PROG#
	MOVEM AC2,.LEBLK+3	;AND STORE IN LEBLK+3
	JRST CPOPJ1	;EXIT
;
WRTFIL:	SKIPN AC1,.LEBLK	;IS THERE ANY FILE NAME?
	JRST WRTCTY	;NO, TYPE OUT "CTY"
	MOVEM AC1,NAME	;YES, TYPE OUT THE FILE NAME.
	PUSHJ STK,WRTNAM
	HLLZ AC1,.LEBLK+1	;GET THE EXTENSION.
	JUMPE AC1,NOEXT	;ZERO?
	HLLZM AC1,NAME	;NO, TYPE "." FOLLOWED BY EXTENSION.
	OUTCHR [56]
	PUSHJ STK,WRTNAM
NOEXT:	SKIPN AC1,.LEBLK+3	;ANY PROJ# PROG#?
	POPJ STK,	;NO, EXIT
	HLRZM AC1,VALUE	;STORE PROJECT # FOR TYPING.
	OUTCHR [133]	;TYPE OUT "["
	MOVEI AC2,^D18	;SET UP OUTPUT BITS OF 18,
	MOVEM AC2,NBITS
	MOVEI AC2,^D8	;AND OUTPUT RADIX OF 8.
	MOVEM AC2,NRADIX
	PUSHJ STK,WRTNOL
	OUTCHR [54]	;TYPE ","
	HRRZ AC1,.LEBLK+3	;TYPE OUT PROGRAMMER#
	MOVEM AC1,VALUE
	PUSHJ STK,WRTNOL
	OUTCHR [135]	;TYPE OUT "]".
	POPJ STK,
;
WRTCTY:	OUTSTR [ASCIZ /CTY/]	;CTY... TYPE IT OUT.
	POPJ STK,
;
;PLUG, PAGE 5
;ANLFIL IS WRITTEN IS SM-CODE BECAUSE OF THE HAIR-RAISING
;CHARACTER ANALYSIS.
;
ANLFIL:	LDG .LEBLK+3,0,I
	CHMF REDSTR,I	;READ A NAME
	STG NAME,.LEBLK,D	;AND STORE IT AS FILE NAME.
	LDG NAME,0,I	;SET UP DEFAULT EXTENSION OF ZERO.
	MCHR PERIOD,I	;ANY EXTENSION?
	CHMF REDSTR,I	;YES, READ IT IN.
	MCH LBRACK,I	;ANY PROJECT#, PROGRAMMER#?
	JHM FINRED,I	;NO, GO CLEANUP IN -10 MODE.
	LDG NRADIX,^D8,I	;YES, PREPARE TO READ INTEGERS,
	LDG NBITS,^D17,I	;RADIX 8, LENGTH 17 BITS.
	CHMF REDINT,I	;READ AN INTEGER.
	MCHF COMMA,I	;LOOK FOR TRAILING ",".
	STG VALUE,SCHVAL,D	;STORE THE VALUE TEMPORARILY.
	CHMF REDINT,I	;READ ANOTHER INTEGER.
	MCHF RBRACK,I	;LOOK FOR TRAILING "]".
	LSM		;BACK TO -10 MODE TO PUT IT ALL TOGETHER.
	HRR AC1,VALUE	;AMALGAMATE THE PROJECT#, PROGRAMMER#
	HRL AC1,SCHVAL
	MOVEM AC1,.LEBLK+3	;AND SAVE.
FINRED:	MOVE AC1,NAME	;PUT EXTENSION, IF ANY, INTO PLACE.
	HLLZM AC1,.LEBLK+1
	RSM
	RSS		;DONE.
;
;PLUG, PAGE 6
;BREAK TRANSMISSION IS EVEN MORE COMPLICATED, BUT THE TRULY
;DIRTY WORK, NAMELY THE MANIPULATION OF THE BREAK-TABLE, IS
;DONE IN ANOTHER MODULE.
;
	FNDFLG=UNDO	;DO+BLO IS ACTUALLY BRKBLK+BCNT
	BRKCNT=UNDO+1	;TEMPORARY BREAK COUNT HOLDER
;
GETBRK:	CLEARM ,FNDFLG	;CLEAR "BREAK FOUND" FLAG.
	CLEARM ,BRKBLK+BACT	;CLEAR THE ACTION AND BREAK BITS
	CLEARM ,BRKBLK+BBRK	;IN THE BREAK INTERFACE.
	PUSHJ STK,SETBRK	;SET UP UNIT+ADDRESS.
	PUSHJ STK,BKSRCH	;SEARCH FOR BREAK.
	POPJ STK,	;NOT FOUND.
	SETOM ,FNDFLG	;FOUND, SET "BREAK FOUND" FLAG.
	MOVE AC,BRKPTR	;GET PTR TO BREAK ENTRY.
	MOVE AC1,BCTBRK(AC)	;GET THE BREAK BITS AND
	HLLM AC1,BRKBLK+BBRK	;STORE THEM IN BRKBLK.
	MOVE AC1,BCTACT(AC)	;GET THE ACTION BITS AND
	MOVEM AC1,BRKBLK+BACT	;STORE THEM IN BRKBLK.
	MOVE AC1,BCTCNT(AC)	;GET THE COUNT FIELD
	MOVEM AC1,BRKBLK+BCNT	;AND STORE IT IN BRKBLK.
	JRST CPOPJ1	;FOUND, TAKE SKIP RETURN.
;
PUTBRK:	PUSHJ STK,SETBRK	;SET UP BRKBLK UNIT+ADDRESS FIELDS.
	MOVE AC,BRKBLK+BACT	;GET THE ACTION-WORD.
	IOR AC,DO+BACT	;SET THE INDICATED ACTIONS.
	ANDCM AC,UNDO+BACT	;CLEAR THE INDICATED ACTIONS.
	MOVEM AC,BRKBLK+BACT	;STORE UPDATED ACTION-WORD.
	HLLZ AC,BRKBLK+BBRK	;GET THE BREARK-WORD.
	IOR AC,DO+BBRK	;SET AND CLEAR THE INDICATED BREAKS.
	ANDCM AC,UNDO+BBRK
	HLLM AC,BRKBLK+BBRK	;STORE UPDATED BREAKS-WORD.
	MOVE AC,BRKCNT	;STORE NEW BREAK COUNT.
	MOVEM AC,BRKBLK+BCNT
;
	MOVE AC,CONADR	;WE MUST NOW INFORM THE VM
	HLRZ AC,DBST(AC)	;THAT THE BREAK IS THERE OR GONE.
	PUSHJ STK,@AC	;CALL THE INFORM-VM ROUTINE.
	POPJ STK,	;VM SAYS FUCK YOU.
	HLRZ AC,BRKBLK+BBRK	;IS THERE ANY NEW BREAK OR ACTIONS?
	SKIPN ,BRKBLK+BACT
	JUMPE AC,NOBRK	;NO.
	PUSHJ STK,BRKINS	;YES, INSERT THE NEW BREAK.
	JRST CPOPJ1
NOBRK:	SKIPE ,FNDFLG	;WAS THERE A BREAK ORGINALLY? NO, DO NOTHING.
	PUSHJ STK,BRKDEL	;YES, DELETE THE BREAK.
	JRST CPOPJ1
;
SETBRK:	MOVE AC1,FRMNUM	;SET UP BRKBLK FRAME# AND UNIT FIELDS.
	MOVEM AC1,BRKBLK+BLO
	MOVEM AC1,BRKBLK+BHI
	MOVE AC1,UNTADR
	HRRM AC1,BRKBLK+BUCB
	POPJ STK,
;
;PLUG, PAGE 7
;WRTBRK TYPES OUT THE CURRENTLY SET BREAKS AND ACTIONS.
;
WRTBRK:	HLLZ AC,BRKBLK+BBRK	;GET THE BREAK BITS.
	MOVEI AC1,BRKIDS-1	;SOME ON, SET UP MOVING INDEX IN
	PUSHJ STK,GETBIT	;BREAK-STRING TABLE.  GET FIRST BREAK BIT.
	JRST WRTCNT	;NONE FOUND.
WNXTB:	MOVEM AC1,TXTADR	;FOUND, TABLE INDEX HAS BEEN MOVED
	PUSHJ STK,WRTTXT	;ACCORDINGLY.  TYPE OUT BREAK NAME.
	PUSHJ STK,GETBIT	;GET NEXT BIT.
	JRST WRTCNT	;NONE FOUND.
	OUTCHR [54]	;FOUND, TYPE "," BETWEEN BREAKS.
	JRST WNXTB	;GO TYPE BREAK.
;
WRTCNT:	SKIPN AC1,BRKBLK+BCNT	;GET THE COUNT FIELD.  ZERO?
	JRST WRTACT	;YES, DONT PRINT IT.
	OUTCHR ["("]	;NON-ZERO, PRINT "(".
	PUSHJ STK,ACTOUT	;TYPE OUT COUNT AS DECIMAL NUMBER.
	OUTCHR [")"]	;PRINT CLOSING ")".
;
WRTACT:	MOVE AC,BRKBLK+BACT	;GET THE ACTION BITS.
	CLEAR AC1,	;CLEAR ACTION# COUNTER.
	PUSHJ STK,GETBIT	;GET THE FIRST NON-ZERO BIT.
	POPJ STK,	;NONE FOUND, EXIT.
	OUTCHR [73]	;SOME FOUND, TYPE ; BETWEEN BREAKS 