	TITLE SM - INTERPRETIVE SYNTAX PROCESSOR
	HISEG

;LGF - 10/70
;THIS VERSION OF SM IS COMPLETELY IMCOMPATABLE WITH THE OLDER VERSION
;SM IS DOCUMENTED IN TWO MEMOS
;USAGE IS EXPLAINED IN THE 'SM USERS GUIDE' , MIMIC MEMO #2
;INTERNAL DESIGN IS EXPLAINED IN THE 'SM INTERNAL DESIGN GUIDE'
;
;DEFINITIONS, EXTERNS, ETC.
;
	SALL
STK=17
AC=12
AC1=1
NOGR=27
NOINDX=10
NOADDR=4
FSTCHR=360600
TAB=6
SPACE=2
SMXR0=GRTBL
;
	INTERN	SM,SMRSME,SMREEN
;
	EXTERN	SMGR	;TO KEEP P.MAC HAPPY
	EXTERN	CSSLVL
	EXTERN	SMOLDPC
	EXTERN	WRTTXT
	EXTERN	WRTINT
	EXTERN	ERROR
	EXTERN	GRTBL
	EXTERN	JUNK

	PAGE
;
;
;SM'S FAST AC'S
;MOST OF SM'S IMPORTANT VARIABLES ARE FAST AC'S, PERMITTING ALL
;KINDS OF NICE OPERATIONS
;
SMPC=2		;SM'S PROGRAM COUNTER. 
SMILC=3		;INSTRUCTION LOCATION COUNTER. POINTS AT THE INSTRUCTION
		;CURRENTLY BEING INTERPRETED
XFIELD=4	;INDEX FIELD. CONTAINS THE INDEX REGISTER NUMBER OR
		;IMMEDIATE INDEX USED IN ADDRESSING
YFIELD=5	;INTERIM ADDRESS FIELD. CONTAINS THE INTERIM AND
		;ULTIMATELY FINAL 18 BIT EFFECTIVE ADDRESS OF AN OPERAND
MODE=6		;ADDRESSING MODE.
OPCODE=7	;OPERATION CODE
OPRAND=10	;INSTRUCTION OPERAND
GR=11		;GENERAL REGISTER NUMBER
;
;BYTE POINTERS FOR INSTRUCTION FIELDS
;
OPPTR:	POINT	5,0(SMILC),5	;OP CODE FIELD
MODPTR:	POINT	5,0(SMILC),10	;ADDRESSING MODE FIELD
XPTR:	POINT	4,0(SMILC),17	;INDEX FIELD
GPTR:	POINT	3,0(SMILC),13	;SHORT GENERAL REGISTER FIELD
SKPPTR:	POINT	3,0(SMILC),13	;SKIP CODE
GRPTR:	POINT	6,0(SMILC),17	;LONG GENERAL REGISTER FIELD
;
	PAGE

;ENTRY TO SM
;SET UP PC AND STRING POINTER
;
SM:	HRRZ	AC,-1(STK)	;GET STRING POINTER FROM STACK
	HRLI	AC,FSTCHR	;AND MAKE IT INTO A BYTE POINTER
	MOVEM	AC,SMPTR
	HRRZ	SMPC,-2(STK)	;PC IS SYNTAC POINTER
	SETZM	,CSSLVL		;INIT PUSHDOWN LEVEL
	JRST	,DOINS		;AND START INTERPRETING
;
;REENTRY TO SM
;
SMREEN:
SMRSME:	POP	STK,SMPC	;GET ADDRESS OF REENTRY CALL
	HRRZ	SMPC,SMPC	;GET RID OF COUNT
	JRST	,DOINS		;SMPC IS POINTING AT WORD AFTE@ RSM
				;AND START INTERPRETING
;
OPXEQ:	SKIPA	SMILC,YFIELD	;FOR XEQ, INS ADR IS EFF ADR
DOINS:	MOVE	SMILC,SMPC	;FOR REGULAR INS, INS ADR IS IN PC
	LDB	OPCODE,OPPTR	;SET UP OPERATION CODE
	CAIG	OPCODE,NOADDR	;CHECK IF ADDRESSING NEEDED
	JRST	,QSMBRK		;DON'T DO ADDRESSING IF NOT NEEDED
	LDB	MODE,MODPTR	;SET UP ADDRESSING MODE
	LDB	XFIELD,XPTR	;AND INDEX FIELD JUST IN CASE
	HRRZ	YFIELD,0(SMILC)	;BASE ADDRESS FIELD
	CAIG	OPCODE,NOGR	;CHECK IF GENERAL REGISTER NEEDED
	JRST	,SMADDR		;IF NOT, DON'T BOTHER WITH FIELD
	LDB	GR,GRPTR	;PROVISIONALY GET LONG GR FIELD
	CAILE	MODE,NOINDX	;OK IF NO INDEX USED
	LDB	GR,GPTR		;INDEXED, USE SHORT FIELD
;
SMADDR:	XCT	,PHASE1(MODE)	;DO FIRST ADDRESSING PHASE
	XCT	,PHASE2(MODE)	;SECOND PHASE, IF ANY
	XCT	,PHASE3(MODE)	;THIRD PHASE, IF ANY
DTERM:	SKIPA	OPRAND,0(YFIELD)	;THREE PHASE MODES TERMINATED
				;AS IF DIRECT
ITERM:	HRRZ	OPRAND,YFIELD	;IMMEDIATE MODE TERMINATION
QSMBRK:	SKIPGE	,0(SMILC)	;CHECK BREAK BIT
	JFCL			;PUT DDT BKPT HERE.
SMCONT:	JRST	,@OPTBL(OPCODE)	;NO BREAK, DISPATCH TO INSTRUCTION
;
;TABLE OF OP CODE PROCESSOR ADDRESSES
;
;THIS MACRO DEFINES THE TABLE ENTRIES AS WELL AS THE OPDODES
;
DEFINE SMOP(MNEM)
<MNEM=.-OPTBL
	OP'MNEM>
OPNOP=NXTINS	;SPECIAL DEFINITION FOR NOP
OPTBL:	SMOP(NOP)	; 0 - NO OPERATION
	SMOP(RSS)	; 1 - RETURN FROM SYNTACTIC SUBROUTINE
	SMOP(RSR)	; 2 - RESTORE STRING POINTER AND RETURN
	SMOP(BAD)	; 3
	SMOP(BAD)	; 4
	SMOP(BAD)	; 5
	SMOP(BAD)	; 6
	SMOP(JMP)	; 7 - JUMP WITHIN SYNTAX
	SMOP(XEQ)	;10 - EXECUTE SM INSTRUCTION
	SMOP(CSS)	;11 - CALL SYNTACTIC SUBROUTINE
	SMOP(MCH)	;12 - MATCH
	SMOP(ASM)	;13 - ABSORB SPACES AND MATCH
	SMOP(XHM)	;14 - EXECUTE HOST MACHINE INSTRUCTION
	SMOP(CHM)	;15 - CALL HOST MACHINE SUBROUTINE
	SMOP(JHM)	;16 - JUMP TO HOST MACHINE
	SMOP(SMZ)	;17 - SKIP IF MEMORY ZERO
	SMOP(ABS)	;20 - ABSORB STRING
	SMOP(BAD)	;21
	SMOP(BAD)	;22
	SMOP(BAD)	;23
	SMOP(BAD)	;24
	SMOP(BAD)	;25
	SMOP(BAD)	;26
	SMOP(BAD)	;27
	SMOP(LDG)	;30 - LOAD GR
	SMOP(STG)	;31 - STORE GR
	SMOP(ADG)	;32 - ADD TO GR
	SMOP(SGS)	;33 - SKIP IF GR SAME AS MEMORY
	SMOP(SGD)	;34 - SKIP IF GR DIFFERENT FROM MEMORY
	SMOP(JGN)	;35 - JUMP IF GR NONZERO
	SMOP(JGZ)	;36 - JUMP IF GR ZERO
	SMOP(BAD)	;37
;
;ADDRESSING MODE TABLES
;ADDRESSING IN SM IS ACCOMPLISHED BY INDEXED XCT'S OF THESE TABLES
;
;PHASE MODE DEFINITIONS
;
BAD=	JRST	,BADMOD		;BAD ADDRESSING MODE, OR SHOULDN'T HAVE GOTTEN HERE
IPHASE=	JRST	,ITERM		;IMMEDIATE MODE TERMINATION - ADDRESS IS OPERAND
DPHASE=	JRST	,DTERM		;DIRECT MODE TERMINATING - OPERAND MUST BE FETCHED
XPHASE=	ADD	YFIELD,SMXR0(XFIELD)	;INDEXED
PPHASE=	ADD	YFIELD,XFIELD		;IMMEDIATELY INDEXED
RPHASE=	HRRZ	YFIELD,0(YFIELD)	;INDIRECT THRGUGH RIGHT HALF
LPHASE=	HLRZ	YFIELD,0(YFIELD)	;INDIRECT THROUGH LEFT HALF
;
;MODES WITHOUT INDEXING ALLOW USE OF 6-BIT GENERAL REGISTER FIELD
;THESE MODES ARE IDENTIFIED BY MODE FIELD .GE. 17
;THREE PHASE MODES IMPLY DIRECT MODE TERMINATION
;
;BAD ADDRESSING MODE PROCESSOR
;
BADMOD:	HALT		;MODE ERROR
OPBAD:	HALT		;INVALID OPCODE
;;
;PHASE 1 TABLE
;
;THIS MACRO DEFINES THE TABLE ENTRIES AS WELL AS THE MODES
;
DEFINE SMADR(MNEM,PHASE)
<IFNB <MNEM>, <MNEM=.-PHASE1>
	PHASE>
;
PHASE1:	SMADR(I,IPHASE)	; 0 - I
	SMADR(D,DPHASE)	; 1 - D
	SMADR(R,RPHASE)	; 2 - R
	SMADR(L,LPHASE)	; 3 - L
	SMADR(RR,RPHASE)	; 4 - RR
	SMADR(RL,RPHASE)	; 4 - RL
	SMADR(LR,LPHASE)	; 6 - LR
	SMADR(LL,LPHASE)	; 7 - LL
	SMADR(,BAD)	;10
	SMADR(,BAD)	;11
	SMADR(,BAD)	;12
	SMADR(,BAD)	;13
	SMADR(,BAD)	;14
	SMADR(,BAD)	;15
	SMADR(,BAD)	;16
	SMADR(,BAD)	;17
	SMADR(XI,XPHASE)	;20 - XI
	SMADR(XD,XPHASE)	;21 - XD
	SMADR(RP,RPHASE)	;22 - RP
	SMADR(LP,LPHASE)	;23 - LP
	SMADR(RX,RPHASE)	;24 - RX
	SMADR(LX,LPHASE)	;25 - LX
	SMADR(XR,XPHASE)	;26 - XR
	SMADR(XL,XPHASE)	;27 - XL
	SMADR(RPR,RPHASE)	;30 - RPR
	SMADR(RPL,RPHASE)	;31 - RPL
	SMADR(LPR,LPHASE)	;32 - LPR
	SMADR(LPL,LPHASE)	;33 - LPL
	SMADR(RXR,RPHASE)	;34 - RXR
	SMADR(RXL,RPHASE)	;35 - RXL
	SMADR(LXR,LPHASE)	;36 - LXR
	SMADR(LXL,LPHASE)	;37 - LXL
;
;
;PHASE II TABLE
;
PHASE2:	BAD	; 0 - I - ALREADY TERMINATED
	BAD	; 1 - D - ALREADY TERMINATED
	DPHASE	; 2 - R
	DPHASE	; 3 - L
	RPHASE	; 4 - RR
	LPHASE	; 5 - RL
	RPHASE	; 6 - LR
	LPHASE	; 7 - LL
	BAD	;10
	BAD	;11
	BAD	;12
	BAD	;13
	BAD	;14
	BAD	;15
	BAD	;16
	BAD	;17
	IPHASE	;20 - XI
	DPHASE	;21 - XD
	PPHASE	;22 - RP
	PPHASE	;23 - LP
	XPHASE	;24 - RX
	XPHASE	;25 - LX
	RPHASE	;26 - XR
	LPHASE	;27 - XL
	PPHASE	;30 - RPR
	PPHASE	;31 - RPL
	PPHASE	;32 - LPR
	PPHASE	;33 - LPL
	XPHASE	;34 - RXR
	XPHASE	;35 - RXL
	XPHASE	;36 - LXR
	XPHASE	;37 - LXL
;
;
;PHASE III TABLE
;
PHASE3:	BAD	; 0 - I - ALREADY TERMINATED
	BAD	; 1 - D - ALREADY TERMINATED
	BAD	; 2 - R - ALREADY TERMINATED
	BAD	; 3 - L - ALREADY TERMINATED
	DPHASE	; 4 - RR
	DPHASE	; 5 - RL
	DPHASE	; 6 - LR
	DPHASE	; 7 - LL
	BAD	;10
	BAD	;11
	BAD	;12
	BAD	;13
	BAD	;14
	BAD	;15
	BAD	;16
	BAD	;17
	BAD	;20 - XI - ALREADY TERMINATED
	BAD	;21 - XD - ALREADY TERMINATED
	DPHASE	;22 - RP
	DPHASE	;23 - LP
	DPHASE	;24 - RX
	DPHASE	;25 - LX
	DPHASE	;26 - XR
	DPHASE	;27 - XL
	RPHASE	;30 - RPR
	LPHASE	;31 - RPL
	RPHASE	;32 - LPR
	LPHASE	;33 - LPL
	RPHASE	;34 - RXR
	LPHASE	;35 - RXL
	RPHASE	;36 - LXR
	LPHASE	;37 - LXL
;
;
;SKIP CONTROL TABLE
;LEFT HALF FOR SKIP NOT REQUESTED, RIGHT HALF FOR SKIP REQUESTED
;
SKPTBL:	XWD	DOINS,SKPINS	;0 - AS REQUESTED	(NO SUFFIX)
	XWD	OPRSR,OPRSS	;1 - PROPAGATE RESULT	(P)
	XWD	DOINS,DOINS	;2 - NEVER SKIP		(N)
	XWD	SKPINS,SKPINS	;3 - ALWAYS SKIP	(A)
	XWD	SKPINS,DOINS	;4 - REVERSE SKIP	(R)
	XWD	OPRSR,DOINS	;5 - FAIL IF NO SKIP	(F)
	XWD	DOINS,OPRSR	;6 - FAIL IF SKIP	(RF)
	XWD	OPRSR,OPRSR	;7 - ALWAYS FAIL	(AF)
;
;SKIP REQUEST PROCESSOR
;
NOSKIP:	LDB	AC,SKPPTR	;GET SKIP CODE FROM INSTRUCTION
	HLRZ	AC,SKPTBL(AC)	;GET RESPONSE FROM TABLE LEFT HALF
	AOJA	SMPC,0(AC)	;AND GO THERE
;
SKPREQ:	LDB	AC,SKPPTR	;GET SKIP CODE FROM INSTRUCTION
	HRRZ	AC,SKPTBL(AC)	;GET RESPONSE FROM TABLE RIGHT HALF
	AOJA	SMPC,0(AC)	;AND GO THERE
;
SKPINS:
NXTINS:	AOJA	SMPC,DOINS
;
;INSTRUCTION PROCESSORS
;
OPCHM:	JUMPE	YFIELD,NOSKIP	;IF EFFADDR=0, SIMULATE FAILURE
	PUSH	STK,SMPC	;SAVE THE CURRENT SM-LOCATION.
	PUSH	STK,SMILC	;AND ILC (FOR XEQ'S)
	PUSHJ	STK,0(YFIELD)
	JRST	,OPCHM1		;RESTORE PC, ILC AND DON'T SKIP
	POP	STK,SMILC	;RESTORE PC, ILC
	POP	STK,SMPC
	JRST	,SKPREQ		;AND SKIP
;
OPCHM1:	POP	STK,SMILC
	POP	STK,SMPC
	JRST	,NOSKIP		;AND DON'T SKIP
;
;
;
OPXHM:	XCT	,OPRAND		;THE HM INSTRUCTION IS IN OPRAND
	JRST	,NOSKIP		;ALLOW FOR EXECUTION OF SKIPS
	JRST	,SKPREQ
;
;
;
OPCSS:	JUMPE	YFIELD,NOSKIP	;IF EFF ADDR=0, SIMULATE FAILURE
	PUSH	STK,SMPC	;CALL SUBROUTINE - SAVE PC
	PUSH	STK,SMPTR	;AND STRING POINTER
	AOS	,CSSLVL		;INDEX PUSH DOWN DEPTH
OPJMP:	MOVEM	SMPC,SMOLDPC	;SAVE PC FOR DEBUGGING
	MOVE	SMPC,YFIELD	;GO TO EFFECTIVE ADDRESS
	JRST	,DOINS		;AND DO IT
;
;
OPJHM:	JRST	,0(YFIELD)	;GO TO HOST MACHINE
;
;
;
	PAGE

OPRSR:	SOSGE	,CSSLVL		;DECREMENT PUSHDOWN DEPTH
	JRST	,SMEXIT		;NO CORPESPONDING CSS, LEAVE SM
	POP	STK,SMPTR	;RESTORE STRING POINTER FROM STACK
	JRST	,POPPC
OPRSS:	SOSGE	,CSSLVL		;DECREMENT PUSHDOWN DEPTH
	JRST	,SMEXIT		;NO CORRESPONDINC CSS, LEACE SM
	POP	STK,JUNK	;GET RID OF STRING POINTER
POPPC:	POP	STK,SMPC	;RESTORE PC
	LDB	AC,SKPPTR	;GET SKIP CODE OF THIS INSTRUCTION
	MOVE	SMILC,SMPC	;FIX UP ILC TO POINT AT CSS TO GET PROPER SKIP CODE
	CAILE	AC,1		;IF RETURN CODE 0 OR 1, REQUEST SKIP
	JRST	,NOSKIP
	JRST	,SKPREQ
;
SMEXIT:	POP	STK,AC		;SAVE RETURN ADDRESS
	SUB	STK,[XWD 2,2]	;GET RID OF ARGUMENTS
	LDB	AC1,SKPPTR	;GET SKIP CODE OF RETURN
	CAILE	AC1,1		;IF 0 OR 1, TAKE SKIP RETURN, OTHERWISE
	JRST	,0(AC)		;RETURN
	JRST	,1(AC)
;
;
OPJGN:	SKIPN	,GRTBL(GR)	;PDP-10 SKIP IF GR NONZERO
	JRST	,NXTINS		;ZERO, DO NEXT INSTRUCTION
	JRST	,OPJMP		;NONZERO, SM JUMP
;
;

;
OPJGZ:	SKIPE	,GRTBL(GR)	;PDP-10 SKIP IF GR ZERO
	JRST	,NXTINS		;NONZERO, GO TO NEXT INSTRUCTION
	JRST	,OPJMP		;ZERO, JUMP TO EFFECTIVE ADDRESS
;;
;
OPLDG:	MOVEM	OPRAND,GRTBL(GR)	;COPY OPERAND INTO GR
	JRST	,NXTINS
;
;
;
OPSTG:	MOVE	OPRAND,GRTBL(GR)	;GET GR CONTENTS
	MOVEM	OPRAND,0(YFIELD)	;AND STORE INTO EFFECTIVE ADDRMSS
	JRST	,NXTINS
;
;
;
OPADG:	ADDM	OPRAND,GRTBL(GR)	;ADD TO GR
	JRST	,NXTINS
;
;
;
OPSGS:	CAMN	OPRAND,GRTBL(GR)	;COMPARE OPERAND WITH GR
	AOJA	SMPC,NXTINS		;EQUAL, DO THE SKIP
	JRST	,NXTINS			;UNEQUAL, DON'T SKIP
;
;
;
OPSGD:	CAME	OPRAND,GRTBL(GR)	;COMPARE OPERAND WITH GR
	AOJA	SMPC,NXTINS		;UNEQUAL, DO THE SKIP
	JRST	,NXTINS			;EQUAL,@CONTINUE WITH NEXT INSTRUCTION
;
;
;
OPSMZ:	JUMPN	OPRAND,NOSKIP	;GO TO NEXT INSTRUCTION IF OPERAND NONZERO
	JRST	,SKPREQ		;OPERAND ZERO, REQUEST SKIP
;
;
	IBP	,SMPTR		;ADVANCE SMPTR OVER BORING CHARACTER
OPASM:	LDB	AC,SMPTR	;GET STRING CHARACTER
	CAIE	AC,SPACE	;IS IT SPACE?
	CAIN	AC,TAB		;OR TAB?
	JRST	,OPASM-1	;YES, IGNORE IT
OPMCH:	MOVE	AC,SMPTR	;SAVE STRHNG POINTER IN CASE OF FAILURE
	MOVEM	AC,SMSAVE
OPNSM:	PUSHJ	STK,MCHER	;GO MATCH STRING
	JRST	,NOMCH		;COULDN'T, RESTORE POINTER AND DON'T SKIP
	JRST	,SKPREQ		;DID, CONTINUE AND SKIP

MCHER:	CAIN	MODE,I		;I MODE/
	JRST	,.+3		;YES, TAKE SPECIAL ARRANGEMENTS
	CAIE	MODE,XI		;XI MODE?
	JRST	,.+3		;NEITHER, REGULAR OPERAND
	HRLZ	OPRAND,OPRAND	;YES,@LEFT JUSTIFY IMMEDIATE OPERAND
	MOVEI	YFIELD,OPRAND	;AND SET UP POINTER TO IT
	HRLI	YFIELD,FSTCHR	;MAKE BYTE POINTER OUT OF OPERAND ADDRESS
;
NXTMCH:	LDB	AC,YFIELD	;GET TEMPLATE CHARACTER
	JUMPE	AC,GOTMCH	;ZERO? IF SO, ALL DONE, TAKE SKIP
	LDB	AC1,SMPTR	;GET STRING CHARACTER
	CAME	AC,AC1		;AND COMPARE WITH TEMPLATE
	POPJ	STK,		;NOT SAME, NONSKIP RETURN
	IBP	,YFIELD		;SAME, ADVANCE TO NEXT TEMPLATE CHARACTER
	IBP	,SMPTR		;AND NEXT STRING CHARACTER
	JRST	,NXTMCH		;AND TR[ THEM
;
GOTMCH:	AOS	,0(STK)		;SUCCESSFUL MATCH, SKIP RETURN
	POPJ	STK,

NOMCH:	MOVE	AC,SMSAVE	;MATCH FAILED, RESTORE SVRING POINTER
	MOVEM	AC,SMPTR
	JRST	,NOSKIP		;AND DON'T SKIP
;
OPABS:	PUSHJ	STK,MCHER	;ABSORB STRING
	JRST	,NXTINS		;LEAVE POINTER AT FAILURE
	JRST	,NXTINS		;ABSORBED IT ALL

;
;
;
	END
