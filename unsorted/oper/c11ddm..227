	SALL
	TITLE CPUDDM	PDP-11 CPU DESCRIPTOR
	ENTRY CPUDDM
	INTERN ITIM,SOURCE,PRMODE,MBSAVE,CPUUCB,SYSLST
	INTERN PC,OFFSET
	INTERN LDRUCB,CPUPC
	IFL MODEL-^D40, <	INTERN REG>
	EXTERN PERBNK,.FLAGS,SLPCHK
	INTERN TRPTBL,STM,WFLG,OLDPC,LVLARY,CORE,TRREG
	EXTERN CPURST,CPURD,CPUWR,CPUADR
	EXTERN BLDUP,TRDOWN,FETCH,LOADER
	EXTERN SR

	IFNDEF PACKED,<	PACKED=0>
	IFNDEF SEG,<	SEG=0>
	IFNDEF FPP,<	FPP=0>
	IFNDEF EIS,<	EIS=1>
	IFNDEF STKL,<	STKL=1>
	IFNDEF PTR,<	PTR=0>
	IFNDEF PTP,<	PTP=0>
	IFNDEF CPU,<	CPU=^D8>
	MEMSIZ=CPU*^D2048
;
;MACRO'S TO CONDITIONALLY ASSEMBLE A 40 VS A 45

	DEFINE MOD40(X)
<IFE MODEL-^D40,
<X>
>

	DEFINE MOD45(X)
<IFE MODEL-^D45,
<X>
>

CPUDDM:	DDM1 CPU,CPURDB,CPUUCB
	DDM2 ^D8,^D18,^D8,^D16
	DDM3 QADR+QFIX+QBRK,^D16,MEMSIZ
	DDM4 CPURD,CPUWR,CPURST,CPUADR,BRSET,SLPCHK
;
CPUUCB:	UCB CPU,0,CPUDDM,0,0,QADR+QFIX+QBRK
;
SYSLST:	SIXBIT /PDP11/
	Z ,FETCH
	Z ,CPUPC
	XWD LOADER,LDRUCB
	Z ,BLDUP
	Z ,TRDOWN
	DDM3 QADR+QATBL+QRD,^D36,0
	Z ,STM
;
LDRUCB:	UCB LDR,0,SYSLST,0,0,QADR+QATBL+QRD
;
	CORE=CPUDDM+DNFRM
;
;PDP-11 CPU DDM, PAGE 2
;
	DEFINE TT(B,V)	;TRAP TABLE MACRO
<	XWD B,V>

IFL MODEL-^D40,<	;TRAPS FOR 11/20, 11/05 GROUP
TRPTBL:	TT BUSBIT+MEMBIT+TRCBIT,4	;1= BUS ERROR
	TT BUSBIT+MEMBIT+TRCBIT,4	;2= MEM ERROR
	TT ILLBIT+TRCBIT,4	;3= ILL INSTR ERROR
	TT RSVBIT+TRCBIT,10	;4= RESERVED INSTR ERROR
	TT BKPBIT+TRCBIT,14	;5= BKPT INSTR
	TT IOTBIT+TRCBIT,20	;6= IOT INSTR
	TT EMTBIT+TRCBIT,30	;7= EMT INSTR
	TT TRPBIT+TRCBIT,34	;8= TRAP INSTR
	TT TRCBIT+STKBIT,14	;9= TRACE TRAP
	TT STKBIT,4	;10= STACK TRAP
	TT PWRBIT,24	;11= POWER FAIL TRAP
>
IFGE MODEL-^D40,<	;TRAPS FOR 11/40, 11/45 GROUP
TRPTBL:	TT BUSBIT+MEMBIT+TRCBIT,4	;ODD ADDRESS
	TT REDBIT+YELBIT+TRCBIT,4	;RED STACK VIOLATION
	TT SEGBIT+TRCBIT,250	;SEGMENT VIOLATION
	TT BUSBIT+MEMBIT+TRCBIT,4	;NONEXISTANT MEMORY
	TT PARBIT+TRCBIT,4	;PARITY ERROR
	TT MGMBIT+TRCBIT,250	;MANAGEMENT TRAP
	TT YELBIT+TRCBIT,4	;YELLOW STACK VIOLATION
	TT ILLBIT+TRCBIT,4	;ILLEGAL INSTRUCTION
	TT RSVBIT+TRCBIT,10	;RESERVED INSTRUCTION
	TT BKPBIT+TRCBIT,14	;BREAKPOINT INSWRUCTION
	TT IOTBIT+TRCBIT,20	;IOT
	TT EMTBIT+TRCBIT,30	;EMT
	TT TRPBIT+TRCBIT,34	;TRP
	TT TRCBIT,14	;TRACE TRAP (11/40 ONLY)
	TT PWRBIT,24	;POWER FAILURE
	TT FPPBIT,244	;FPP AND FIS TRAP
>
;
SOURCE:	0	;SOURCE OPERAND.
OFFSET:	0	;LOADER OFFSET
PRMODE:	XWD ^D8,^D16	;PREVAILING MODE SWITCH.
PSCORE:	MEMSIZ	;CORE REGISTER.
ITIM:	Z	;INCREMENTAL TIMER
	Z	;LAST TRDN
IFL MODEL-^D40, <
STM:	REPEAT 13,<0>	;SAVED FAST REGISTERS.
>
WFLG:	Z	;WAIT STATE TRAP FLAG.
MBSAVE:	Z	;TEMPORARY
IFL MODEL-^D40, <
REG:	REPEAT 7,<0>	;PDP-11 FAST REGISTERS.
PC:	Z	;PC IS NAMED
>
IFGE MODEL-^D40, <
	INTERN DADDR,MAFSAV,MODSAV,IRSAVE,CCSAVE,RETURN
	INTERN DBLNDX
MOD40	<INTERN SRCMAF>
	INTERN TRAPPC,TRAPPS
	INTERN FPPADR,KT11C,REGTBL
	INTERN SR0,SR1,SR2,SR3,STKLIM
	INTERN KSP

DADDR:	0	;DST ADDRESS
MAFSAV:	0	;SAVED MEMORY ACCESS FLAGS
MODSAV:	0	;SAVED ADDRESS MODE DURING INDEX AND INDIRECT ACCESS
IRSAVE:	0	;SAVED IR
DBLNDX:	0	;DOUBLE OPERAND TABLE INDEX
CCSAVE:	0	;SAVED CC'S FOR ABORTED INSTRUCTIONS
MOD40 <
SRCMAF:	0	;SRC FLAGS FOR 11/40
>
TRAPPC:	0	;SAVED TRAP PC
TRAPPS:	0	;SAVED TRAP PS
RETURN:	0	;SAVED JSP RETURN AC
STM:	REPEAT 17, <	0>	;SAVED AC'S
REGTBL:	REPEAT 22, <	0>	;PDP11 REGISTERS
PC=REGTBL+15
KSP=REGTBL+16
SSP=KSP+1
USP=KSP+3
FPPADR:	IFN FPP, <EXTERN FPPDCD
	FPPDCD
>
	IFE FPP, <EXTERN RSVERR
	RSVERR
>
MOD40 <	INTERN EISFLG
EISFLG:	EIS
>
KT11C:	SEG
SR0:	0
SR1:	0
SR2:	0
SR3:	0
STKLIM:	0
MOD45 <	INTERN	FPSR,FEA,FEC
FPSR:	0
FEA:	0
FEC:	0>
>
OLDPC:	Z	;OLD PC.
IFGE MODEL-^D40, <
	INTERN TRAPS
TRAPS:	0	;BR'8'
>
LVLARY:	Z	;LEVEL STATUS REGISTERS:  BR7
	Z	;BR6
	Z	;BR5
	Z	;BR4
	Z	;BR3
	Z	;BR2
	Z	;BR1
;REGISTER DESCRIPTION BLOCKS FOR PDP-11/CPU
;
CPURDB:	IFL MODEL-^D40, <
	RDB R0,REG+0,16	;PDP-11 GENERAL REGISTERS.
	RDB R1,REG+1,16
	RDB R2,REG+2,16
	RDB R3,REG+3,16
	RDB R4,REG+4,16
	RDB R5,REG+5,16
	RDB R6,REG+6,16
	RDB R7,REG+7,16
	RDB PS,STM+PS,8	;PROCESSOR STATUS.
	RBLK STAT,STM+PS,4,,2,4	;PRIORITIES ACTIVE REG.
	RBLK BR7,LVLARY+0,30,P,8,30	;LEVEL STATUS REGISTERS
	RBLK BR6,LVLARY+1,30,P,8,30	;ARE STORED LEFT JUSTIFIED
	RBLK BR5,LVLARY+2,30,P,8,30	;IN LVLARY, IN DESCENDING
	RBLK BR4,LVLARY+3,30,P,8,30	;ORDER OF PRIORITY.
	RDB SR,SR,16	;CONSOLE SWITCHES.
	RBLK OTR,STM+TR,11,,2,11	;OUTSTANDING TRAPS.
	RDB OLDPC,OLDPC,16,P	;OLD PC.
	RDB SP,REG+6,16	;STACK POINTER=R6
CPUPC:	RDB PC,REG+7,16	;PC=R7
>;END OF NOT 11/40 OR 45 CONDITIONAL


IFGE MODEL-^D40, <

MOD45 <STKL==1>

MOD45 <	EXTERN PIRQ,UBRK


	DEFINE GRRDB(S,N)
<IRPC N
<	RDB R'S'N,REGTBL+S*6+N,16
>
>

	GRRDB (0,012345)
	GRRDB (1,012345)

>;END MOD45
	RDB R0,REGTBL+0,16
	RDB R1,REGTBL+1,16
	RDB R2,REGTBL+2,16
	RDB R3,REGTBL+3,16
	RDB R4,REGTBL+4,16
	RDB R5,REGTBL+5,16
	RDB R6,KSP,16
	RDB R7,PC,16
	RDB SP,KSP,16
	RBLK TSTATE,STM+PS,4,,8,16
MOD45 <	RDB KR6,KSP,16
	RDB SR6,SSP,16
	RDB UR6,USP,16
	RDB KSP,KSP,16
	RDB SSP,SSP,16
	RDB USP,USP,16>

MOD40 <	IFN SEG,<
	RDB KR6,KSP,16
	RDB UR6,USP,16
	RDB KSP,KSP,16
	RDB USP,USP,16>
>
CPUPC:	RDB PC,PC,16
MOD45 <	RDB PS,STM+PS,16
	RBLK CUR,STM+PS,2,,8,21	;CURRENT  STATE
	RBLK PRV,STM+PS,2,,8,23	;PREVIOUS STATE
	RBLK GR,STM+PS,1,,8,24	;REGISTER SET
	RBLK STAT,STM+PS,8,,2,7>
MOD40 <	IFE SEG,< RDB PS,STM+PS,8>
IFN SEG,<
	RDB PS,STM+PS,16
	RBLK CUR,STM+PS,2,,8,21
	RBLK PRV,STM+PS,2,,8,23
>
	RBLK STAT,STM+PS,5,,2,4>
	RBLK OTR,TRAPS,16,,2,16
	RBLK BR7,LVLARY+0,31,P,8,30
	RBLK BR6,LVLARY+1,31,P,8,30
	RBLK BR5,LVLARY+2,31,P,8,30
	RBLK BR4,LVLARY+3,31,P,8,30
MOD45 <
	RBLK BR3,LVLARY+4,1,P,8,0
	RBLK BR2,LVLARY+5,1,P,8,0
	RBLK BR1,LVLARY+6,1,P,8,0
>
	RDB SR,SR,16
	RDB OLDPC,OLDPC,16,P
IFN STKL, <	RDB STKLIM,STKLIM,16>
MOD45 <
	RDB PIRQ,PIRQ,16
	RDB UBRK,UBRK,16
>

>;END OF 11/40-45 CONDITIONAL

	RDB CC,STM+PS,4	;CONDITION CODE
	RBLK LEVEL,STM+PS,3,,8,30	;PROCESSOR LEVEL.
	DRDB TM,STM,36,P
	DRDB ITM,ITIM,36	;INCREMENTAL TIMER.
	RBLK CORE,PSCORE,18,1,10,34
	FLG SINGLE,.FLAGS,1	;SINGLE INST TRAP FLAG.
	FLG SI,.FLAGS,1	;SIN INST TRAP ABBREVIATION
	RDB MA,STM+MA,18,P	;MEMORY ADDRESS.
	RDB MB,STM+MB,16,P	;MEMORY BUFFER.
	FLG WSTATE,STM+PS,17	;WAIT STATE ON FLAG.
IFL MODEL-^D40,<
	FLG TSTATE,STM+PS,16	;TRAP STATE FLAG.
>
	DRDB MODE,CPUDDM+DVAL,5,P	;THIS REGISTER IS HERE SO
		;THAT GET CAN FORCE THE CPU EX/MOD MODE BACK
		;TO THE MODE OF THE SAVED FILE.

IFGE MODEL-^D40, <

IFN SEG, <
	RDB SR0,SR0,16
	RDB SR1,SR1,16
	RDB SR2,SR2,16
MOD45 <	RDB SR3,SR3,16>

	DEFINE SEGRDB(M,S,P)
<IRPC M
<IRPC S
<IRPC P
<	EXTERN M'S'APR'P
	RBLK M'S'PAR'P,M'S'APR'P,16,,8,17
	RBLK M'S'PDR'P,M'S'APR'P,16,,8,35
>;END IRPC P
>;END IRPC S
>;;END IRPC M
>;;END SEGRDB DEFINITION

MOD45 <	SEGRDB (KSU,ID,01234567)>
MOD40 <	SEGRDB (KU,I,01234567)>

>;;END SEG CONDITIONAL

IFN FPP, <

MOD45 <	EXTERN FAC

	DEFINE FACRDB(N)
<K=0
IRPC N
<	RDB AC'N'A,FAC+K,32
	RDB AC'N'B,FAC+K+1,32
K=K+2
>;;END IRPC N
>;;END FACRDB DEFINITION

	FACRDB (012345)

	RDB FEC,FEC,4
	RDB FEA,FEA,16
	RDB FPS,FPSR,16
>;;END MOD45

>;;END FPP CONDITIONAL
>;;END 11/45 CONDITIONAL

	RDB OFFSET,OFFSET,18
TRREG:	FLG WAIT,WFLG,0
IFL MODEL-^D40,<
	FLG BUS,TRPTBL,0	;TRAP FLAGS.
	FLG MEM,TRPTBL+1,0
	FLG ILLEG,TRPTBL+2,0
	FLG RSV,TRPTBL+3,0
	FLG BKP,TRPTBL+4,0
	FLG IOT,TRPTBL+5,0
	FLG EMT,TRPTBL+6,0
	FLG TRP,TRPTBL+7,0
	FLG TRC,TRPTBL+8,0
	FLG STK,TRPTBL+9,0
	FLG PWR,TRPTBL+10,0
	FLG PST,WFLG,1
>
IFGE MODEL-^D40,<
	FLG BUS,TRPTBL,0	;TRAP FLAGS.
	FLG RED,TRPTBL+1,0
	FLG SEG,TRPTBL+2,0
	FLG MEM,TRPTBL+3,0
IFE MODEL-^D45,<
	FLG PAR,TRPTBL+4,0
	FLG MGM,TRPTBL+5,0>
	FLG YEL,TRPTBL+6,0
	FLG ILLEG,TRPTBL+7,0
	FLG RSV,TRPTBL+8,0
	FLG BKP,TRPTBL+9,0
	FLG IOT,TRPTBL+10,0
	FLG EMT,TRPTBL+11,0
	FLG TRP,TRPTBL+12,0
	FLG TRC,TRPTBL+13,0
	FLG PWR,TRPTBL+14,0
	FLG FPP,TRPTBL+15,0
	FLG PST,WFLG,1
>
	Z
	SUBTTL CORE MEMORY READ/WRITE ROUTINES
;
;THERE ARE FIVE ROUTINES INVOLVED IN CORE MEMORY MANAGEMENT.
;RDCORH-- READ CORE HALF WORD
;WRCORH-- WRITE CORE HALF WORD
;RDCORB-- READ CORE BYTE
;WRCORB-- WRITE CORE BYTE
;BRSET-- SET BREAK BITS
;
	INTERN RDCORH,WRCORH,RDCORB,WRCORB
	EXTERN ADRSCH
IFL MODEL-^D40, <
	EXTERN TODDS,TODDD
>;
;CALLING SEQUENCES--
;[RDCORH/RDCORB]
;	MEMORY ADDRESS IN MA
;	JSP XR,RDCORH
;	  BKPT INSTRUCTION	;XCT'D IF BRKPT
;	NORMAL RETURN	;MA IS HALVED, DATA IS IN MB
;
;[WRCORH/WRCORB]
;	MEMORY ADDRESS IN MA
;	DATA IN MB
;	JSP XR,WRCORH
;	  BKPT INSTRUCTION	;XCT'D IF BRKPT
;	NORMAL RETURN
	SUBTTL UNPACKED FORMAT ROUTINES
;
;THE FORMAT OF UNPACKED CORE IS DESCRIBED IN THE CPU.
;
IFE PACKED,<

RDCORH:	ROT MA,-1	;CONVERT MA FROM BYTES TO WORDS.
	SKIPGE MB,C(MA)	;GET SELECTED WORD.  BKPT?
	XCT ,0(XR)	;XCT BKPT INSTRUCTION.
	ANDI MB,177777	;MASK OFF BITS.
	JRST 1(XR)	;EXIT.

WRCORH:	ROT MA,-1	;CONVERT MA FROM BYTES TO WORDS.
	SKIPGE ,C(MA)	;BKPT IN SELECTED WORD?
	XCT ,0(XR)	;YES.
	HRRM MB,C(MA)	;NO, STORE RESULT.
	JRST ,1(XR)	;EXIT.

RDCORB:	ROT MA,-1	;CONVERT MA FROM BYTES TO WORDS.
	JUMPL MA,RDODD	;ODD BYTE?
	SKIPGE MB,C(MA)	;NO, GET EVEN (LOW) BYTE.  BKPT?
	XCT ,0(XR)	;YES.
	ANDI MB,377	;MASK DATA.
	JRST ,1(XR)	;EXIT.
;
RDODD:	MOVE MB,C(MA)	;ODD BY\E.  GET HALF WORD.
	TLNE MB,OBRK	;BKPT?
	XCT ,0(XR)	;YES.
	LSH MB,-^D8	;ISOLATE ODD BYTE.
	ANDI MB,377
IFL MODEL-^D40, <
	ADDI TM,TODDS	;ADD ON EXTRA TIME FOR ODD SOURCE.
>
	JRST ,1(XR)	;EXIT

WRCORB:	ROT MA,-1	;CONVERT MA FROM BYTES TO WORDS.
	JUMPL MA,WRODD	;ODD BYTE?
	SKIPGE ,C(MA)	;NO, BKPT IN EVEN BYTE?
	XCT ,0(XR)	;YES.
	DPB MB,[POINT 8,C(MA),35]	;STORE EVEN BYTE.
	JRST ,1(XR)	;EXIT.
;
WRODD:	HLL MB,C(MA)	;ODD BYTE.  GET FLAGS.
	TLNE MB,OBRK	;BKPT?
	XCT ,0(XR)	;YES.
	DPB MB,[POINT 8,C(MA),27]	;STMRE RESULT.
IFL MODEL-^D40, <
	ADDI TM,TODDD	;ADD ON EXTRA TIME FOR ODD DST.
>
	JRST 1(XR)
;
BRSET:	HRRZ MA,BRKBLK+BFRM	;GET ADDR OF FRAME TO BE BRKPT'D.
	HLLZ MB,BRKBLK+BBRK	;GET BREAK CONDITIONS.
	TRNE MA,1	;ODD ADDRESS?
	SKIPA TMP1,[XWD OBRK,0]	;YES, GET ODD BRK BIT AND SKIP
	MOVSI TMP1,HBRK		;NO, GET EVEN BREAK.
	CAML MA,CORE		;LEGAL ADDR?
	JRST SETPER	;NO.
	ROT MA,-1	;YES, CONVERT BYTE ADDR TO WORD ADDR.
	JUMPE MB,.+3	;SET OR CLEAR BKPT BITS?
	IORM TMP1,C(MA)	;SET AND SKIP
	JRST .+2
	ANDCAM TMP1,C(MA)	;CLEAR
SKIPR:	AOS ,(P)	;SET SKIP RETURN AND
OUT:	POPJ P,		;EXIT.
;
SETPER:	ROT MA,-1	;CONVERT BYTE ADDR TO WORD ADDR.
	JSP R,ADRSCH	;LOOK UP ADDR IN EXTERNAL PAGE.
	JRST OUT	;NOT FOUND.
	JUMPE MB,.+3	;SET OR CLEAR BKPT BITS?
	IORM TMP1,PERBNK(XMA)	;SET AND EXIT.
	JRST SKIPR
	ANDCAM TMP1,PERBNK(XMA)	;CLEAR AND EXIT.
	JRST SKIPR
>
	SUBTTL PACKED FORMAT ROUTINES

IFN PACKED,<

RDCORH:	ROT MA,-2	;CONVERT MA TO PACKED WORD POINTER.
	JUMPGE MA,GLEFT	;LEFT OR RIGHT HALFWORD?
GRIGHT:	SKIPA MB,C(MA)	;RIGHT, GET WORD AND SKIP.
GLEFT:	HLRZ MB,C(MA)	;LEFT, GET HALFWORD.
	ROT MA,1	;RESTORE MA TO WORD ADDRESS FORMAT.
	TRNE MB,HBRK	;BKPT?
	XCT ,0(XR)	;YES, DO IT.
	ANDI MB,177777	;CUT RESULT TO 16 BITS AND
	JRST ,1(XR)	;EXIT.
;
WRCORH:	ROT MA,-2	;CONVERT MA TO PACKED WORD POINTER.
	JUMPGE MA,PLEFT	;LEFT OR RIGHT HALFWORD?
	DPB MB,[POINT 16,C(MA),35]	;RIGHT, STORE WORD
	JRST GRIGHT	;AND GO CHECK BKPT
;
PLEFT:	DPB MB,[POINT 16,C(MA),17]	;LEFT, STORE WORD
	JRST GLEFT	;AND GO CHECK BKPT.
;
;
BRSET:	HRRZ MA,BRKBLK+BFRM	;GET FRAME TO BE BKPT'D.
	HLLZ MB,BRKBLK+BBRK	;GET BREAK CONDITIONS.
	CAML MA,CORE	;LEGAL?
	JRST SETPER	;NOT AS CORE.
	HRRZ TMP,MA	;CONVERT BYTE ADDRESS TO PACKED POINTER+
	ANDI TMP,3	;BYTE SELECTOR.
	ROT MA,-2
	MOVE TMP1,BBITS(TMP)	;GET PROPER BRK BITS FOR BYTE.
	JUMPE MB,.+3	;SET OR CLEAR?
	IORM TMP1,C(MA)	;SET AND SKIP.
	JRST .+2
	ANDCAM TMP1,C(MA)	;CLEAR.
SKIPR:	AOS ,(P)	;TAKE SKIP RETURN
REXIT:	POPJ P,
;
SETPER:	ROT MA,-1	;CONVERT ADDR TO PERIPHERAL FORMAT.
	JSP R,ADRSCH	;LOOK UP ADDR IN EXTERNAL PAGE.
	JRST REXIT	;NOT FOUND.
	JUMPGE MA,.+2	;ODD OR EVEN?
	SKIPA TMP1,BBITS+1	;ODD, GET BIT AND SKIP
	MOVE TMP1,BBITS	;EVEN, GET BIT.
	JUMPE MB,.+3	;SET OR CLEAR?
	IORM TMP1,PERBNK(XMA)	;SET AND EXIT.
	JRST SKIPR
	ANDCAM TMP1,PERBNK(XMA)	;CLEAR AND EXIT.
	JRST SKIPR

RDCORB:	HRRZ TMP2,MA	;CONVERT BYTE ADDR TO PACKED ADDR POINTER+
	ANDI TMP2,3	;BYTE SELECTOR.
	ROT MA,-2
	LDB MB,CORTAB(TMP2)	;GET BYTE.
	MOVE TMP1,C(MA)	;GET WHOLE WORD.
	ROT MA,1	;RESTORE MA TO WORD ADDR FORMAT.
IFL MODEL-^D40, <
	JUMPGE MA,.+2	;ODD?
	ADDI TM,TODDS	;YES, ADD ON EXTRA TIME.
>
	TDNE TMP1,BBITS(TMP2)	;CHECK FOR BKPTS.
	XCT ,0(XR)	;FOUND.
	JRST ,1(XR)	;EXIT.

WRCORB:	HRRZ TMP2,MA	;CONVERT BYTE ADDR TO PACKED ADDR POINTER+
	ANDI TMP2,3	;BYTE SELECTOR
	ROT MA,-2
	DPB MB,CORTAB(TMP2)	;STORE BYTE.
	MOVE TMP1,C(MA)	;GET WHOLE WORD.
	ROT MA,1	;RESTORE MA TO WORD ADDR FORMAT.
IFL MODEL-^D40, <
	JUMPGE MA,.+2	;ODD?
	ADDI TM,TODDD	;YES, ADD ON EXTRA TIME.
>
	TDNE TMP1,BBITS(TMP2)	;CHECK FOR BKPTS.
	XCT ,0(XR)	;FOUND.
	JRST 1(XR)	;EXI\.

CORTAB:	POINT 8,C(MA),17	;XXXXX0 OR XXXXX4
	POINT 8,C(MA),9		;XXXXX1 OR XXXXX5
	POINT 8,C(MA),35	;XXXXX2 OR XXXXX6
	POINT 8,C(MA),27	;XXXXX3 OR XXXXX7

BBITS:	XWD HBRK,0
	XWD OBRK,0
	XWD 0,HBRK
	XWD 0,OBRK

>
IFN PACKED,<
C:	XLIST
	REPEAT MEMSIZ/4,<0>
	LIST
>
IFE PACKED,<
C:	XLIST
	REPEAT MEMSIZ/2,<0>
	LIST
>
	LIT
	RELOC CPUDDM+DSYN
	EXTERN PDP11S
	PDP11S	;DEVICE SYNTAX.
	END
