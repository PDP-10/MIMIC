	TITLE	BREAK - MIMIC BREAK PROCESSOR
	HISEG

;BRKCHK IS CALLED BY A PUSHJ FROM THE VM WHEN THE BREAK BIT
;IS FOUND SET ON A FRAME. BRKCHK VERIFIES THE BREAK, EXECUTES
;ANY ASSOCIATED ACTIONS, AND RETURNS TO THE VM.

;INTERNAL SUBROUTINES

	INTERN	BRKCHK,INTSTP,DOACTS,MIMIC,MIMREN

;INTERNAL DATA

;EXTERNAL SUBROUTINES

	EXTERN	BKSRCH
	EXTERN	REDTXT,WRTTXT
	EXTERN	GETCOR,NXTCON
	EXTERN	SM,COMPTR

;EXTERNAL DATA

	EXTERN	CSSLVL
	EXTERN	SMGR		;TO KEEP P.MAC HAPPY
	EXTERN	BRKPTR
	EXTERN	SYSLSP
	EXTERN	CINPUT
	EXTERN	SYNPTR
	EXTERN	STKSAV,STKINIT
	EXTERN	ACTPTR
	EXTERN	JOBREN,JOBFF,JOBREL
	EXTERN	CTYSTAT
	EXTERN	BCTBOT,BCTTOP,BCTLIM

;NOTE - MOST (ALL?) OF THIS EXTERNAL DATA IS FOUND
;IN MIMIC'S LOW SEGMENT, 'COMMON'

;AC DEFINITIONS

AC1=13	;UNTIL TEAR DOWN SUBR IS CALLED,
AC2=14	;CAN ONLY USE AC'S 13-16
UCB=4
DDM=5
AC3=3
STK=17

;OTHER DEFINITIONS OF SYSTEM PARAMETERS ARE FOUND IN P.MAC

;
;MIMIC STARTUP
;SINCE THIS IS CLOSELY RELATED TO RESPONSE TO A BREAK,
;THE START OF MIMIC IS IN THIS MODULE
;
MIMIC:	RESET			;RECOVER FREE STORAGE.
	MOVE	STK,STKINIT	;INITIALIZE THE STACK
IFN TYMSHR,<	EXTERN BRI
	PUSHJ	STK,BRI	;WRITE INITIAL BILLING RECORD
>
	SETZM	,CONADR		;INITIALIZE CONTROLLER ADDR POINTER
INILP:	PUSHJ	STK,NXTCON	;GET ADDR OF NEXT CONTROLLER
	JRST	INIEND		;DONE?
	MOVE	AC1,CONADR	;NO, GET CONTROLLER ADDR
	HLRZ	AC1,DINIT(AC1)	;GET ADDR OF INITIALIZATION ROUTINE
	JUMPE	AC1,INILP	;ZERO?  DON'T CALL
	PUSHJ	STK,0(AC1)	;CALL ROUTINE
	JRST	,INILP		;ONWARDS
;
INIEND:	HRRZ	AC1,JOBFF	;GET FIRST FREE WORD OF LOW SEG
	MOVEM	AC1,BCTBOT	;WHICH IS BEGINNING
	HRRZ	AC2,JOBREL	;GET LAST WORD OF LOW SEG
	MOVEM	AC2,BCTLIM	;WHICH IS LIMIT ON SIZE OF BCT
	ADDI	AC1,2*ENTSIZ	;COMPUTE SPACE FOR 2 PHONY ENTRIES
	MOVEM	AC1,BCTTOP	;AND SET UP POINTER TO END OF TABLE
	CAMG	AC2,AC1		;IS THERE SPACE FOR THEM?
	PUSHJ	STK,GETCOR	;NO, GET ENOUGH
	MOVE	AC1,BCTBOT	;SET UP POINTER TO 1ST PHONY ENTRY.
	SETZM	,BCTLO(AC1)	;PUT ZERO ENTRY INTO TABLE
	SETZM	,BCTHI(AC1)
	SETZM	,BCTBRK(AC1)	;UNIT ADDRESS IS ZERO
	SETZM	,BCTACT(AC1)
	MOVE	AC2,[XWD 377777,-1]	;FOR INFINITE ENTRY,
	MOVEM	AC2,BCTLO+ENTSIZ(AC1)
	MOVEM	AC2,BCTHI+ENTSIZ(AC1)
	HRRZM	AC2,BCTBRK+ENTSIZ(AC1)	;UNIT ADDRESS IS ALL ONES
	SETZM	,BCTACT+ENTSIZ(AC1)
IFN ONLINE,<	EXTERN	BILL,BILARG
	PUSHJ	STK,BILL	;CALL BILLING ROUTINE
	ARG	5,BILARG+0
	ARG	5,BILARG+1
	ARG	5,BILARG+2
	ARG	5,BILARG+3
	ARG	0,BILARG+4
	ARG	0,BILARG+5
	ARG	5,BILARG+6
	ARG	5,BILARG+7
	ARG	0,BILARG+^D8
	ARG	0,BILARG+^D9
	ARG	2,BILARG+^D10
	ARG	2,BILARG+^D11
	ARG	0,BILARG+^D12
>
MIMREN:	MOVE	STK,STKSAV	;INITIALIZE STACK
IFN TIMLTD,<	EXTERN	CHARGE
	JSP	16,CHARGE	;WRITE INITIAL BILL ON START/REEN
	JUMP	0,1
	JUMP	0,[ASCII/MIM1/]
>
	CLRBFI			;INIT INPUT TTY BUFFER
	SETZM	,BRKBLK+BACT	;FAKE OUT ACTIONS.
	JRST	,FSTCOM		;AND GO TRY SOMETHING

	PAGE
	SUBTTL	BRKCHK

BRKCHK:	PUSHJ	STK,BKSRCH	;SEARCH BCT FOR BREAK ENTRY
	POPJ	STK,		;NOT FOUND, GO RIGHT BACK TO VM
	MOVE	AC1,BRKPTR	;GET POINTER TO ENTRY FOUND
	HLLZ	AC2,BCTBRK(AC1)	;GET BREAK MASK BITS FROM TABLE.
	TDNE	AC2,BRKBLK+BBRK	;MASK VM-SET BITS.  ANY ON?
	SOSLE	,BCTCNT(AC1)	;IF SO, HAS HIS COUNT GONE TO ZERO?
	POPJ	STK,		;NO, GO RIGHT BACK
	SETZM	,BCTCNT(AC1)	;YES, MAKE SURE COUNT DOESN'T BECOME -1
	HLLM	AC2,BRKBLK+BBRK	;PUT FULL TABLE ENTRY BACK FOR VM
	MOVE	AC1,BCTACT(AC1)	;GET ACTION BITS FROM ENTRY
	MOVEM	AC1,BRKBLK+BACT	;AND SAVE FOR LATER
INTSTP:	MOVEM	STK,STKSAV	;SEAL OFF STACK FOR START COMMANDS
	MOVE	AC1,SYSLSP	;GET POINTER TO SYSTEM LIST
	PUSHJ	STK,@SYTEAR(AC1)	;CALL TEARDOWN ROUTINE TO SAVE VM'S AC'S
	HRRZ	UCB,BRKBLK+BUCB	;GET ADDRESS OF BREAKING UCB FROM BRKBLK
	HRRZ	DDM,UDDM(UCB)	;GET ADDRESS OF UNIT'S DDM FROM UCB
	HRRZ	AC1,DHON(DDM)	;AND ADDRESS OF HONORING ROUTINE FROM DDM
	PUSHJ	STK,0(AC1)	;CALL THE HONORING ROUTINE
	TTCALL	7,CTYSTAT	;RESTORE OLD CTY STATUS.

FSTCOM:	MOVEI	AC1,MIMREN	;RESTORE REENTRY POINT FOR
	MOVEM	AC1,JOBREN	;DEBUGGING.
	PUSHJ	STK,DOACTS	;DO THE ACTIONS
				;AND GO INTO COMMAND MODE
NXTCOM:	PUSHJ	STK,CINPUT	;ACQUIRE COMMAND INPUT
	PUSH	STK,SYNPTR	;GIVE SM POINTER TO SYNTAX
	PUSH	STK,COMPTR	;AND POINTER TO COMMAND
	PUSHJ	STK,SM		;AND GO TO SM
	TTCALL	3,COMERR	;COMMAND ERROR, SAY SO
	JRST	,NXTCOM		;GO GET ANOTHER COMMAND

;NOTE THAT SM MAY NOT RETURN HERE IF A START, RUN, GO OR CONTINUE
;COMMAND IS EXECUTED. IT IS THE RESPONSIBILITY OF THOSE
;COMMAND S TO CLEAN UP THE STACK OF RESIDUAL JUNK.
;NAMELY, THE CALL TO BRKCHK (FOR GO AND CONTINUE)
;	SM'S ARGUMENTS
;	THE CALL TO SM

COMERR:	ASCIZ	/?
/				;COMMAND ERROR MESSAGE TEXT

	SUBTTL	DOACTS - ACTION EXECUTER

;DOACTS EXECUTES THE ACTIONS CORRESPONDING TO THE BITS SET
;IN THE ACTION WORD OF BRKBLK
;IT IS DESIGNED TO TAKE CARE OF THE POSSIBLILITY OF RECURSIVE
;EXECUTION OF ACTIONS

DOACTS:	SKIPN	AC1,BRKBLK+BACT	;CHECK IF THERE ARE ANY ACTIONS
	POPJ	STK,		;DON'T WASTE TIME DOING NOTHING
	PUSH	STK,CSSLVL	;SAVE CSSLVL SO SM DOESN'T CLOBBER IT
	MOVEI	AC2,ACTPTR	;AND INIT POINTER TO ACTION BUFFER POINTER TABLE
NXTACT:	JUMPE	AC1,ACTDON	;ANY ACTION BITS LEFT SET?
	JUMPL	AC1,DOACT	;YES, HIGH ORDER BIT (NEXT ACTION) SET?
CONACT:	LSH	AC1,1		;NO, SHIFT TO NEXT BIT
	AOJA	AC2,NXTACT	;BUMP POINTER TO NEXT ACTION AND GO TRY IT

DOACT:	HRRZ	AC3,0(AC2)	;GET POINTER TO STRING FROM TABLE
	SKIPN	,@AC3		;IS THE ACTION BUFFER ZERO?
	JRST	,CONACT		;YES, GO ON TO NEXT ACTION.
	PUSH	STK,AC1		;SAVE AC'S FOR AFTER ACTION IS DONE
	PUSH	STK,AC2		;BECAUSE SM IS LIKELY TO CLOBBER THEM
	PUSH	STK,SYNPTR	;NOW SM'S ARGUMENTS - SYNTAX POINTER
	PUSH	STK,AC3		;AND POINTER TO ACTION STRING
	MOVEM	AC3,TXTADR
	PUSHJ	STK,WRTTXT	;OUTPUT THE ACTION
	PUSHJ	STK,SM		;GO TO SM
	TTCALL	3,COMERR	; ACTION REJECTED, SAY SO
	POP	STK,AC2		;RESTORE STUFF FROM STACK
	POP	STK,AC1		;SM IS NICE ENOUGH TO CLEAN UP ITS ARGUMENTS
	JRST	,CONACT		;AND GO TRY NEXT ACTION

ACTDON:	POP	STK,CSSLVL	;RESTORE CSSLVL SO SYNTAX WORKS
	POPJ	STK,		;ALL DONE, RETURN TO CALLER

	END
