;PAGE 1 -- NOVA RELOCATING LOADER
TITLE	NOVLNK -- RELOCATABLE LINKING LOADER FOR NOVA
SUBTTL	VERSION 1/SLH/18 NOV 1971;MODS 1 MAY 1972
SALL

VERSION==1
SUBV==3

	JOBFF==121
	JOBVER==137

LOC 	JOBVER
	XWD	SUBV,VERSION
RELOC

;AC'S
	F=0		;ALSO USED BY EXEC
	AC1=1
	NWDC=1
	AC2=2
	ZWDC=2
	AC3=3
	AC4=4
	AC5=5
	WDC=6		;WORD COUNT
	PTR=7		;BYTE POINTER FOR RELOC FLAGS
	$ORIGN=10	;POINTS TO CORE ADDRESS
	WORD=11		;NOVA WORD FROM INPUT FILE
	CHKSUM=12	;CHECKSUM

	ARG=13		;ARGUMENT AC FOR EXEC CALLS
	T1=13		;TEMPORARY
	T2=14
	T3=15
	T4=16

	P==17		;PUSH-DOWN LIST PTR ALSO USED BY EXEC

	INTERN	$ORIGN,$RADIX,$BITS,$DFBIN,$DFINF,$USRSW,$EMASK
	INTERN	$INITU,$ELOAD,$LOADR,$RELOC

	EXTERN	$PRFIL,$PRVAL,$PRSYM,$WRWRD
	EXTERN	$PTWRD,$MASK,$PURGE,$RDSYM,$RDNUM
	EXTERN	$RDWRD,$STSYM,$HI,$LO,$MAX,$GTWRD,$MIN,$LKGLB,$LKOWN

;FLAGS FOR RIGHT-HAND OF F

	RLIB==1
	RSTART==2
	RZERO==4
	REXTD==10
	REXTN==20
	RABS==40
	RENTRY==100
	RREL==200
	RLLIB==400
	RLMODE==1000
	RLENT==2000
	RDATA==4000
	R44==10000

	SOMFLG==RLIB+RABS+RREL+RLENT

	QEXTD==4000

	SYMN==0		;WORD 1 IS SYMBOL NAME
	SYMV==1		;WORD 2 IS SYMBOL VALUE
	SYMF==2		;WORD 3 IS SYMBOL FLAG(S)

;RANDOM EQUIVALENCES

	WDMASK==177777	;WORD MASK FOR 16 BIT NOVA WORD

OPDEF	PJRST	[JRST]

TWOSEG

RELOC	400000
;PAGE 2 -- NRL
;AVOID PHASE ERRORS

DEFINE	ERRMS (A,B)
<	MOVEI	AC1,.+4
	PUSHJ	P,PRERR
	OUTSTR	[ASCIZ /
/]
	JRST	B
	ASCIZ	/A/
>

DEFINE	ERRMS1 (A,B,C)
<	MOVEI	AC1,.+6
	PUSHJ	P,PRERR
	MOVE	ARG,B
	PUSHJ	P,$PRVAL
	OUTSTR	[ASCIZ /
/]
	JRST	C
	ASCIZ	/A/
>
;PAGE 3 -- NRL
;THIS INITIALIZES THE WORLD

$INITU:	SETZM	UBEGN		;SET UP TO ZERO USER CORE
	MOVE	T1,[XWD UBEGN,UBEGN+1]
	BLT	T1,UEND
	MOVEI	T1,400
	MOVEM	T1,$RELOC	;SET INITIAL RELOCATE OFFSETS
	MOVEI	T1,50
	MOVEM	T1,RELOCZ	;PAGE ZERO OFFSET
	TRZ	F,-1		;CAF
	MOVSI	T1,QEXT+QENT+QEXTD
	MOVEM	T1,$EMASK	;SET FOR LOADER EXEC
	POPJ	P,0		;RETURN

;THIS IS THE MAJOR LOAD ROUTINE
$LOADR:	TRZ	F,SOMFLG	;CLEAR SOME FLAG BITS
	SETZB	CHKSUM,BLKNO	;START WITH CLEAN CHECKSUM, AND BLOCK NO
	MOVE	T2,$RELOC	;GET OLD RELOCATION FACTOR
	CAMGE	T2,SAVNMX	;MUST BE GREATER THAN OLD MAXIMUM
	 JRST	REVERR
	MOVEM	T2,NMAX		;NEW NMAX
	ROT	T2,1		;ROTATE TO MAKE BYTE POINTER
	MOVEM	T2,RELOCB	;NEW RELOCATABLE BYTE OFFSET
	MOVE	T2,RELOCZ	;NOW DO SAME FOR PAGE ZERO RELOCATION
	CAMGE	T2,SAVZMX	;GREATER THAN OLD LIMIT?
	 JRST	PZRERR
	MOVEM	T2,ZMAX
	ROT	T2,1		;ROTATE TO MAKE BYTE POINTER
	MOVEM	T2,RELCZB	;PAGE ZERO BYTE POINTER
	MOVEI	T1,EXDBLK	;RESET POINTER TO EXTERN DIS BLOCK
	MOVEM	T1,EXDPTR
	MOVE	T1,JOBFF
	MOVEM	T1,SAVADR	;SAVE SYMBOL TABLE END

;CHECK FOR MORE STUFF HERE

GETBLK:	PUSHJ	P,$RDWRD	;GET FIRST BYTE
	 JRST	LEOF+1		;END OF FILE
	JUMPE	ARG,GETBLK	;PRESUME ZEROS ARE HEADER
	PUSHJ	P,BLDED		;GET FIRST HALF OF THIS WORD
	AOS	BLKNO		;BUMP NUMBER OF BLOCKS
	TRNN	WORD,100000	;NEGATIVE MEANS ABSOLUTE BINARY
	TRNE	F,RABS		;OR ELSE PREVIOUSLY SEEN ABSOLUTE
	 JRST	ABSOLU
	TRZ	F,RSTART	;CLEAR START BIT
	CAIG	WORD,12		;CHECK FOR BLOCK TYPE WITHIN BOUNDS
	CAIGE	WORD,2		;WE ASSUME THAT ABSOLUTE START BLOCK
	 JRST	ILGBL		;WON'T EVER BE THE FIRST BLOCK
	TRO	F,RREL		;SET RELOCATE FILE BIT
	XCT	TABLE1-2(WORD)	;NO PROCESS THE BLOCK AND RETURN TO GETBLK
SKPBLK:	PUSHJ	P,RDHDR		;GET HEADER STUFF AND WORD COUNT
	JUMPE	WDC,SKPB1	;JUMP IF WORD COUNT DONE
	PUSHJ	P,BLDWRD	;GET A WORD
	SOJA	WDC,SKPBLK+1	;REDUCE WORD COUNT BY ONE AND LOOP
SKPB1:	PUSHJ	P,CHCHSM	;CHECK CHECKSUM ANYWAY
	JRST	GETBLK
;PAGE 4 -- NRL
;FOLLOWS THEDISPATCH TABLE FOR BLOCK TYPE


TABLE1:	JRST	REDATA		;DATA BLOCK -- 2
	JRST	ENTRY		;ENTRY BLOCK -- 3
	JRST	EXTERD		;EXTERNAL DISPLACEMENT BLOCK -- 4
	JRST	EXTERN		;NORMAL EXTERNAL BLOCK -- 5
	JRST	START		;START BLOCK -- 6
	JRST	TITLE		;TITLE BLOCK -- 7
	JRST	LOCSYM		;LOCAL SYMBOL BLOCK -- 10
	JRST	SETLIB		;BEGINNING OF LIBRARY FILE -- 11
	JRST	ENDLIB		;END OF LIBRARY FILE -- 12

SETLIB:	TRO	F,RLMODE+RDATA	;SET BITS FOR LIB MODE AND DATA BLOCK
	TRNN	F,RLLIB		;DO WE WANT TO LOOK AT LIBRARY FILES?
	TRO	F,RLIB		;NO,SET IGNORE LIBRARY BIT
	JRST	SKPBLK		;GO AND SKIP HEADER BLOCK

ENDLIB:	TRZ	F,RLIB+RLMODE+RDATA	;CLEAR SOME BITS
	TRO	F,RSTART	;LIBRARY END IS EQUIVALENT TO START BLOCK
	JRST	SKPBLK		;SCAN PAST HEADER AND GO TO NEXT BLOCK

;THIS SUBROUTINE CONVERTS THE NAME IN SAVNAM,SAVNAM+1 TO
;STANDARD PDP-10 SIXBIT
;USES AC1 AND AC2

RADX50:	SETZM	SIXNAM		;WHERE NAME EVENTUALLY ENDS
	MOVE	T4,[POINT 6,SIXNAM]
	MOVE	T1,SAVNAM	;GET NAME
	IMULI	T1,50*50
	LDB	T2,[POINT 11,SAVNAM+1,30]	;SECOND PART OF NAME
	ANDI	T2,3777
	ADD	T1,T2		;NOW HAVE ONE-WORD SYMBOL
RDX50:	IDIVI	T1,50		;GET CHAR
	HRLM	T2,(P)		;SAVE IT
	SKIPE	T1		;ANYTHING LEFT?
	PUSHJ	P,RDX50		;YES, RECURSE
	HLRZ	T3,(P)		;GET A CHARACTER
	JUMPE	T3,SETACA	;BLANK STAYS BLANK
	ADDI	T3,26
	CAIG	T3,12+26	;LESS THAN 12 IS NUMERAL
	SUBI	T3,<26-17>	;SUBTRACT RIGHT AMOUNT
	CAIN	T3,73		;WAS IT A "."
	SUBI	T3,55		;YUP
SETACA:	IDPB	T3,T4		;DEPOSIT INTO SIXNAM
	POPJ	P,0		;RETURN
;PAGE 5 -- NRL
;FOUND LOCAL SYMBOL BLOCK.  SHALL WE PROCESS IT?

LOCSYM:	TLNN	F,RLIB		;IGNORE THIS BLOCK?
	TLNN	F,QLOCAL	;NO, TEST FOR LOCALS WANTED
	 JRST	SKPBLK		;LOCALS NOT WANTED.  IGNORE IT.
	PUSHJ	P,RDHDR		;GET HEADER INFORMATION
LOCSYA:	PUSHJ	P,GETSYM	;GET A SYMBOL
	 JRST	SKPB1		;NO MORE
	MOVE	ARG,SIXNAM+SYMN	;FIRST CHECK TO SEE IF ALREADY DEFINED
	PUSHJ	P,$LKGLB	;AS A GLOBAL SYMBOL
	 JRST	.+2		;NO, GO AHEAD WITH DEFINITION
	 JRST	LOCSYA		;YES, IGNORE THIS SYMBOL
	MOVSI	AC1,QLOCAL	;SET FLAG TYPE
	PUSHJ	P,SETSYM	;STORE IT
	JRST	LOCSYA		;LOOK FOR MORE

;PROCESS START BLOCK FOUND

START:	TRO	F,RSTART	;SIGNAL START BLOCK SEEN
	TRNE	F,RLIB		;LIBRARY MODE IGNORE?
	JRST	SKPBLK		;YES, SKIP START BLOCK
	PUSHJ	P,RDHDR		;GET HEADER INFORMATION
	PUSHJ	P,ADVPTR	;GET THE RELOC FLAG
	PUSHJ	P,BLDWRD	;GET START ADDRESS
	XCT	TABLE2(AC1)	;THIS DOES THE RELOCATE
	TRC	WORD,WDMASK
	TRCE	WORD,WDMASK	;CHECK FOR 177777
	MOVEM	WORD,SADR	;STORE THE THING IF ADDRESS IS REAL
	MOVE	T2,NMAX		;SAVE THINGS
	MOVEM	T2,SAVNMX
	MOVEM	T2,$RELOC	;NEW $RELOC NEXT TIME THROUGH
	MOVE	T2,ZMAX
	MOVEM	T2,SAVZMX
	MOVEM	T2,RELOCZ
	MOVEI	AC2,EXDBLK-2	;NOW CHECK ON ANY EXTERNAL DISPLACEMENTS
ENDEXA:	ADDI	AC2,2		;HANGING AROUND
	CAML	AC2,EXDPTR	;BEYOND THE LIMIT?
	 JRST	LCSYM		;YES, CHECK LOCAL SYMBOL FILE REQUESTED
	SKIPL	AC1,1(AC2)	;IF SYMBOL ALREADY DEFINED, DON'T BOTHER
	 JRST	ENDEXA		;PUTTING IT IN THE SYMBOL TABLE
	MOVEM	AC1,SIXNAM+SYMV
	MOVE	AC1,(AC2)	;GET SYM NAME
	MOVEM	AC1,SIXNAM+SYMN	;STORE
	MOVSI	AC1,QEXTD	;SET THE RIGHT BIT IN FLAGS
	PUSHJ	P,SETSYM	;STORE IT AWAY
	JRST	ENDEXA		;UP AND AWAY

;TITLE BLOCK FOUND

TITLE:	TRNE	F,RLIB		;IGNORE BECAUSE OF LIBRARY?
	JRST	SKPBLK		;YES
	PUSHJ	P,RDHDR		;BYPASS FIRST PART OF BLOCK
	PUSHJ	P,GETSYM	;GET THE SYMBOL
	 JFCL			;BETTER BE THERE!!
	MOVSI	AC1,QTITLE
	PUSHJ	P,SETSYM	;STORE IN SYMBOL TABLE
	JRST	SKPB1

;STORE SYMBOL IN SYMBOL TABLE

SETSYM:	MOVEM	AC1,SIXNAM+SYMF	;STORE FLAGS
	MOVEI	ARG,SIXNAM	;POINTER TO SYMBOL BLOCK
	PUSHJ	P,$STSYM
	 JRST	SYMERR		;GOD, NO ROOM!!
	POPJ	P,0		;OK, GO AWAY

;DIDDLE THE RELOC FLAG POINTER

ADVPTR:	ILDB	AC1,PTR		;GET THE BYTE
	TLNE	PTR,760000	;AT END OF WORD?
	POPJ	P,0		;NOT YET
	ADDI	PTR,1		;YES, +1 TO LOC
	TLC	PTR,210000	;RESET POSITION BITS
	POPJ	P,0

BEGPTR:	XWD	200300,RELOC1
;PAGE 6 -- NRL
;GET A SYMBOL FROM THE CURRENT BLOCK OF THE FILE
GETSYM:	PUSHJ	P,ADVPTR	;GET NEXT RELOC FLAG
	SOJLE	WDC,CPOPJ	;IF NO MORE, DONE
	PUSHJ	P,BLDWRD
	SOS	WDC
	MOVEM	WORD,SAVNAM	;SAVE FIRST HALF OF SYMBOL NAME
	PUSHJ	P,BLDWRD
	SOS	WDC
	MOVEM	WORD,SAVNAM+1
	PUSHJ	P,BLDWRD	;EQUIVALENCE
	XCT	TABLE2(AC1)
	MOVEM	WORD,SIXNAM+SYMV	;STORE THE VALUE
	PUSHJ	P,RADX50	;CONVERT SYMBOL NAME
SPOP:	AOS	0(P)
CPOPJ:	POPJ	P,0		;SKIP RETURN, FOUND SYMBOL

TABLE2:	JFCL			;0 -- ILLEGAL RELOC, LEAVE IT ANYWAY
	JFCL			;1 -- ABSOLUTE VALUE
	ADD	WORD,$RELOC	;2 -- NORMAL RELOCATION
	ADD	WORD,RELOCB	;3 -- BYTE RELOCATION
	ADD	WORD,RELOCZ	;4 -- PAGE ZERO RELOCATION
	ADD	WORD,RELCZB	;5 -- PAGE ZERO BYTE RELOCATION
	JFCL			;6 -- EXTERNAL DISPLACEMENT REFERENCE
	PUSHJ	P,ILGF		;7 -- ILLEGAL RELOC
;PAGE 7 -- NRL
;FOUND AN ENTRY BLOCK

ENTRY:	TRNE	F,RLIB		;IGNORE LIBRARY MODE?
	JRST	SKPBLK		;YES
	TRO	F,RENTRY
	PUSHJ	P,RDHDR
ENTRYB:	PUSHJ	P,GETSYM	;GET A SYMBOL
	 JRST	RETURN
ENTRYA:	PUSHJ	P,LOOKGB	;SEE IF ALREADY DEFINED IN SYMBOL TABLE
	 JRST	ENTRYC		;NO, GO DEFINE IT
	TRNE	AC1,QENT	;ALREADY DEFINED AS ENTRY?
	JRST	MULERR		;YES, IT IS AN ERROR
	TRO	F,RLENT		;SET BIT FOR LIBRARY MODE CHECK
	TRNE	AC1,QEXTD	;EXTERNAL DISPLACEMENT?
	JRST	CHENTY		;YES, GO PROCESS
	TRO	F,REXTN
	PUSHJ	P,EXNCHN	;TRACE THE EXTERNAL CHAIN
	PUSHJ	P,PURGIT	;REMOVE THIS OCCURRENCE IN SYMTABLE
	JRST	ENTRYA		;GET NEXT OCCURRENCE

ENTRYC:	PUSHJ	P,SETENT	;PUT ENTRY INTO SYMBOL TABLE
	TRZ	F,REXTN+REXTD	;FIRST CLEAR SOME FLAGS
	JRST	ENTRYB		;CYCLE TO NEXT SYMBOL

RETURN:	TRZ	F,RENTRY+REXTN+REXTD	;CAF
	JRST	SKPB1

;PROCESS ENTRY SYMBOL FOR INSERTION INTO SYMTABLE

SETENT:	MOVSI	AC1,QENT
	TRNE	F,REXTD		;DISPLACEMENT?
	HRRI	AC1,QEXTD	;SET DISPLACEMENT BIT IN RIGHT HALF
	TRNE	F,REXTN		;OR EXTERNAL NORMAL?
	HRRI	AC1,QEXT
	PJRST	SETSYM		;PUT IT IN SYMBOL TABLE
;PAGE 8 -- NRL
;EXTERN (NORMAL) BLOCK FOUND

EXTERN:	TRNE	F,RLIB
	JRST	SKPBLK		;SKIP BLOCK BECAUSE OF LIB MODE
	TRO	F,REXTN
	PUSHJ	P,RDHDR
EXTERA:	PUSHJ	P,GETSYM	;GET A SYMBOL
	 JRST	RETURN		;NO MORE
	PUSHJ	P,LOOKGB
	 JRST	EXTSET		;DOESN'T EXIST, PUT IN SYMTABLE
	CAIN	AC1,QEXT	;WAS IT ANOTHER EXTERN?
	JRST	EXTSET		;YES, PUT THIS OCCURRENCE IN TABLE, TOO
	TRNE	AC1,QEXTD	;EXTERNAL DISPLACEMENT?
	JRST	NORERR		;YES, THERE AM A CONFLICT OF SOME SORT
	MOVE	AC4,SIXNAM+SYMV
	MOVE	AC2,SYMV(ARG)	;SET UP FOR TRACING THE CHAIN
	PUSHJ	P,EXNA
	TRNE	AC1,QEXT	;HAD EXTERN FLAG BEEN SET?
	JRST	EXTERA		;YES, GO TO NEXT SYMBOL
	MOVE	AC1,[XWD QENT,QEXT]
	PUSHJ	P,REDEF		;CHANGE FLAGS FOR THIS SYMBOL
	JRST	EXTERA		;CYCLE AROUND
EXTSET:	MOVSI	AC1,QEXT
	PUSHJ	P,SETSYM	;PUT SYMBOL IN SYMBOL TABLE
	JRST	EXTERA		;GET NEXT SYMBOL

REDEF:	MOVE	ARG,SAVPTR	;GET SAVED POINTER
	MOVEM	AC1,SYMF(ARG)
	POPJ	P,0

;ENTRY WAS PREVIOUSLY ANNOUNCED AS EXTERNAL DISPLACEMENT

CHENTY:	MOVE	AC2,SIXNAM+SYMV	;GET VALUE
	TRON	F,REXTD		;BEEN HERE BEFORE?
	PUSHJ	P,CHRAN		;NO, CHECK DISPLACEMENT RANGE
	MOVE	AC4,SYMV(ARG)	;GET THE VALUE
CHN1:	ANDI	AC4,77777	;GET THE RELEVANT BITS (ADDRESS)
	MOVEM	AC4,$ORIGN	;AND USE TO GET THE LAST REF.
	PUSHJ	P,$GTWRD
	HLRZ	AC4,ARG		;LEFT HALF CONTAINS ADDRESS OF NEXT ONE
	ANDI	ARG,177400	;REMOVE OLD DISPLACEMENT, IF ANY
	XOR	ARG,AC2		;PUT IN REAL DISPLACEMENT
	PUSHJ	P,$PTWRD	;STORE AGAIN IN SIMULATED CORE
	 JFCL			;TOO BAD IT DIDN'T WORK
	CAIE	AC4,777777	;END OF CHAIN?
	JRST	CHN1		;NO, GO TO NEXT
	PUSHJ	P,PURGIT	;YUP, PURGE OLD REFERENCE
	JRST	ENTRYA		;AND GO TO NEXT

CHRAN:	CAILE	AC2,377
	JRST	DISERR		;DISPLACEMENT OUT OF RANGE
	POPJ	P,0

LOOKGB:	MOVE	ARG,SIXNAM	;SET UP FOR FINDING SYMBOL -- GLOBAL
	PUSHJ	P,$LKGLB
	 POPJ	P,0		;DOESN'T EXIST
	HRRZM	ARG,SAVPTR	;SAVE POINTER FOR FUTURE PURGES
	HLRZ	AC1,SYMF(ARG)	;GET THE FLAGS
	HRRZ	AC2,SYMF(ARG)	;AND OR BOTH HALVES TOGETHER
	IOR	AC1,AC2
	JRST	SPOP		;SKIP RETURN
;PAGE 9 -- NRL
;THIS SUBROUTINE UNCHAINS NORMAL EXTERNAL REFERENCES

EXNCHN:	MOVE	AC2,SIXNAM+SYMV
	MOVE	AC4,1(ARG)	;SET UP VALUES
EXNA:	MOVEM	AC4,$ORIGN
	PUSHJ	P,$GTWRD	;GET WORD REFERENCED
	MOVE	AC4,ARG		;SAVE NEW ADDRESS
	MOVE	ARG,AC2		;SET VALUE
	PUSHJ	P,$PTWRD	;PUT WORD BACK WHERE IT CAME FROM
	 POPJ	P,0		;ERROR RETURN
	CAIE	AC4,177777	;ALL ONE'S IS END OF CHAIN
	JRST	EXNA
	POPJ	P,0		;DONE

;SET UP FOR PURGING A SYMBOL

PURGIT:	MOVE	ARG,SAVPTR	;SAVED POINTER TO SYMBOL
	PJRST	$PURGE		;PURGE IT
;PAGE 10 -- NRL
;FOUND AN EXTERNAL DISPLACEMENT BLOCK
;LOOK UP THE SYMBOL IN SYMBOL TABLE.  IF IT DOES NOT ALREADY
;EXIST, THE CURRENT VALUE IS -1.  IF SYMBOL FOUND AND HAS NOT
;PREVIOUSLY BEEN DEFINED, CURRENT VALUE IS ALSO -1.
;HOWEVER, IF IT WAS DEFINED, PUT THAT VALUE IN CURRENT REFERENCE
;SLOT, AND STORE SYMBOL IN CORE BLOCK.

EXTERD:	TRNE	F,RLIB
	JRST	SKPBLK		;IGNORE BECAUSE OF LIBRARY MODE
	TRO	F,REXTD
	PUSHJ	P,RDHDR		;GET PRELIMINARY PART OF BLOCK
EXTDA:	PUSHJ	P,GETSYM	;GET THE SYMBOL
	 JRST	RETURN		;NO MORE EXIST IN THIS BLOCK
	PUSHJ	P,LOOKGB	;LOOK FOR IT IN SYMBOL TABLE
	 JRST	EXTDS		;DOESN'T EXIST
	CAIN	AC1,QEXTD	;NOT DEFINED?
	 JRST	EXTDS		;YES, SAME AS NON-EXISTENT
	TRNE	AC1,QEXT	;PREVIOUSLY AN EXTERNAL NORMAL?
	 JRST	DNERR		;DRAT
	TRNE	AC1,QEXTD	;EXTD BIT ALREADY SET?
	JRST	.+3		;YES, DON'T WORRY ABOUT IT
	MOVE	AC1,[XWD QENT,QEXTD]
	PUSHJ	P,REDEF		;RESET THE FLAG BITS
	MOVE	AC2,SYMV(ARG)	;GET PREVIOUS VALUE
	PUSHJ	P,CHRAN		;CHECK DISPLACEMENT RANGE
EXTDC:	MOVE	AC3,EXDPTR	;GET CURRENT BLOCK POINTER
	MOVE	AC1,SIXNAM+SYMN
	MOVEM	AC1,(AC3)	;STORE THE NAME
	MOVEM	AC2,1(AC3)	;STORE THE SAVED VALUE
	ADDI	AC3,2
	CAIL	AC3,EXDPTR	;OVERRUN THE BOUNDARIES?
	JRST	NMROOM		;YES
	MOVEM	AC3,EXDPTR	;SAVE NEW POINTER
	JRST	EXTDA		;ON TO NEXT SYMBOL

EXTDS:	SETO	AC2,		;SET VALUE TO -1
	JRST	EXTDC		;STORE THE SYMBOL
;PAGE 11 -- NRL
;CHECK FOR LOCAL SYMBOL REQUEST FROM PDP-10 FILE

LCSYM:	TLNE	F,QSYM		;LOCAL SYMBOLS WANTED?
	JRST	LCSMA		;YES.
	PUSHJ	P,CHCHSM	;YES, VALIDATE CHECKSUM
	JRST	LEOF+1		;DONE
;
LCSMA:	SETZM	WORD
	PUSHJ	P,$RDSYM	;YES, GET SYMBOL
	 JRST	LEOF+1		;NO MORE SYMBOLS
	MOVEM	ARG,SIXNAM	;STORE SYMBOL NAME
	PUSHJ	P,$RDSYM
	 JRST	SYFERR		;PREMATURE END TO SYMBOL TABLE
	MOVEM	ARG,SIXNAM+SYMV	;VALUE
	PUSHJ	P,$RDSYM
	 JRST	SYFERR
	LDB	AC1,[POINT 3,ARG,35]	;GET RELOCATE FLAG FOR VALUE
	MOVE	WORD,SIXNAM
	XCT	TABLE2(AC1)
	ADDM	WORD,SIXNAM+SYMV	;ADD RELOCATION TO EQUIVALENCE
	MOVE	ARG,SIXNAM+SYMN	;FIRST CHECK FOR GLOBAL DEFINITION
	PUSHJ	P,$LKGLB	;TO AVOID DUPLICATION IN SYMBOL TABLE
	 JRST	.+2		;DOESN'T EXIST, PUT IT IN
	 JRST	LCSMA		;IGNORE THIS SYMBOL, ALREADY DEFINED
	MOVSI	AC1,QLOCAL	;SET LOCAL BIT
	PUSHJ	P,SETSYM	;STORE THE SYMBOL
	JRST	LCSMA
;PAGE 12 -- NRL
;BUILD A NOVA WORD FROM INPUT FILE

BLDWRD:	PUSHJ	P,$RDWRD	;GET A WORD -- 8 BITS
	 JRST	LEOF		;END OF FILE
BLDED:	MOVEM	ARG,WORD
	PUSHJ	P,$RDWRD	;GET NEXT 8 BITS (1ST HALF)
	 JRST	LEOF
	DPB	ARG,[POINT 8,WORD,27]	;PUT IN RIGHT PLACE
	ANDI	WORD,WDMASK	;JUST TO MAKE SURE
	ADDM	WORD,CHKSUM	;CALCULATE CHECKSUM
	POPJ	P,0

CHCHSM:	ANDI	CHKSUM,WDMASK	;AND OFF EXTRANEOUS BITS
	JUMPE	CHKSUM,CPOPJ	;NOT ZERO?
CHKERR:	ERRMS1 <CHECKSUM ERROR AT BLOCK 4>,BLKNO,FATERR

RDHDR:	PUSHJ	P,BLDWRD	;SECOND WORD OF HEADER IS WORD COUNT
	MOVN	WDC,WORD	;COMPLEMENT WORD COUNT
	ANDI	WDC,WDMASK	;EXTRANEOUS BITS OUT
	CAILE	WDC,20		;MORE THAN 16 IS ERROR
	 JRST	BADWC
	PUSHJ	P,BLDWRD	;GET RELOC FLAGS #1
	MOVEM	WORD,RELOC1
	PUSHJ	P,BLDWRD	;SECOND FLAG
	MOVEM	WORD,RELOC2
	PUSHJ	P,BLDWRD
	MOVEM	WORD,RELOC3
	MOVE	PTR,BEGPTR	;SET UP RELOC BITS POINTER
	PJRST	BLDWRD		;GET AND BYPASS CHECKSUM

$USRSW:	ASCII	/Z:/
	PUSHJ	P,ZEROSW
	ASCII	/Z/
	PUSHJ	P,TYPREL
	ASCII	/LIB/
	TRO	F,RLLIB
	ASCII	/-LIB/
	TRZ	F,RLLIB
	ASCII	/SA:/
	PUSHJ	P,SETSAD
	ASCII	/J/
	TRO	F,R44
	ASCII	/-J/
	TRZ	F,R44
	Z

ZEROSW:	PUSHJ	P,$RDNUM	;GET OCTAL VALUE FOR Z SWITCH
	CAIL	ARG,400		;WITHIN RANGE?
	JRST	PZOERR		;NO, COMPLAIN
	MOVEM	ARG,RELOCZ	;SAVE IT
	POPJ	P,

TYPREL:	OUTSTR	[ASCIZ \PAGE ZERO REL CONST/	\]
	MOVE	ARG,RELOCZ	;TYPE OUT PAGE ZERO RELOCATION CONSTANT
	PUSHJ	P,$PRVAL	;PRINT IT
	OUTSTR	[ASCIZ /
/]				;OUTPUT CR-LF
	POPJ	P,0		;RETURN TO LEXEC

SETSAD:	PUSHJ	P,$RDNUM	;GET START ADDRESS
	MOVEM	ARG,SADR
	POPJ	P,0
;PAGE 13 -- NRL
;THIS IS PURE DATA BLOCK TO BE RELOCATED

REDATA:	TRNE	F,RLIB		;IGNORE DATA IN LIBRARY MODE?
	JRST	SKPBLK		;YES INDEED
	TRNN	F,RDATA		;FIRST TIME THROUGH IN LIB MODE?
	JRST	RDAT1		;NO, READ THE DATA
	TRNE	RLENT		;FOUND ENTRIES?
	JRST	RDAT1		;YES, GO AHEAD
	MOVE	T1,SAVADR	;ALAS, WE MUST IGNORE THIS BLOCK
	MOVEM	T1,JOBFF	;SO RESET SYMBOL TABLE END
	MOVEI	T1,EXDBLK	;AND REINITIALIZE EXTD STORAGE
	MOVEM	T1,EXDPTR	;BLOCK
	TRO	F,RLIB		;SET IGNORE BIT
	JRST	SKPBLK		;IGNORE THIS BLOCK

RDAT1:	TRZ	RDATA		;CLEAR AWAY GARBAGE
	PUSHJ	P,RDHDR		;GET HEADER INFORMATION
	PUSHJ	P,ADVPTR	;GET RELOC FLAG FOR ADDRESS
	PUSHJ	P,BLDWRD	;GET THE ADDRESS
	XCT	TABLE3(AC1)	;DO THE RELOCATION, AND SET RIGHT MAX
RED2:	MOVEM	WORD,$ORIGN	;SAVE ADDRESS
RED3:	SOJLE	WDC,SKPB1	;REDUCE WORD COUNT, BRANCH IF DONE
RED1:	PUSHJ	P,ADVPTR	;GET RELOC FLAG
	PUSHJ	P,BLDWRD	;GET NEXT WORD
	XCT	TABLE4(AC1)	;RELOCATE AND DIDDLE IF NECESSARY
RED5:	MOVE	ARG,WORD	;PUT INTO ARG
	PUSHJ	P,$PTWRD	;STORE IT
	 JRST	NOMCOR		;PITY
	ADDI	$ORIGN,1	;BUMP ADDRESS
	XCT	ADDCHK(AC2)	;BUMP APPROPRIATE MAX
RED4:	SOJLE	WDC,SKPB1
	JRST	RED1		;MORE TO DO

TABLE3:	PUSHJ	P,ILGF		;0--ILLEGAL FLAG
	MOVEI	AC2,0		;1--ABSOLUTE RELOCATION
	JRST	SETNOR		;2--NORMAL RELOCATION
	ADD	WORD,RELOCB	;3--NORMAL BYTE
	JRST	SETPGZ		;4--PAGE ZERO RELOCATION
	ADD	WORD,RELCZB	;5--PAGE ZERO BYTE RELOCATION
	JFCL			;6--EXTERNAL DISPLACEMENT
	PUSHJ	P,ILGF		;7--ILLEGAL

SETNOR:	ADD	WORD,$RELOC	;RELOCATE
	CAMGE	WORD,NMAX	;LESS THAN OLD NMAX?
	 JRST	RELERR		;YES, ERROR
	MOVEM	WORD,NMAX	;SAVE NEW NMAX
	MOVEI	AC2,1		;SET MODE FOR LATER
	JRST	RED2

SETPGZ:	ADD	WORD,RELOCZ	;RELOCATE
	CAMGE	WORD,ZMAX	;CHECK FOR TURNING BACK COUNTER
	 JRST	RELERR		;YES
	CAIL	WORD,400	;OVER PAGE ZERO LIMIT?
	 JRST	PZOERR
	MOVEM	WORD,ZMAX
	MOVEI	AC2,2
	JRST	RED2

LEOF:	POP	P,(P)		;READJUST PDL
	JUMPN	CHKSUM,BFERR	;AT BEGINNING OF NEW BLOCK?
	TRNE	F,RLMODE	;STILL IN LIBRARY MODE?
	JRST	NOLBND		;YES, OUTPUT MESSAGE
	TRNE	F,RSTART
	 JRST	SPOP		;RETURN TO EXEC, START BLOCK SEEN
	ERRMS <NO START BLOCK SEEN4>,CPOPJ
;PAGE 14 -- NRL
;CONTINUATION OF DATA PROCESSING

;THE FOLLOWING TABLE IS FOR ACTUAL RELOCATION
;IT DIFFERS FROM OTHERS BECAUSE OF SPECIAL EXTERNAL DISPLACEMENT
;HANDLING

TABLE4:	PUSHJ	P,ILGF
	JFCL
	ADD	WORD,$RELOC
	ADD	WORD,RELOCB
	ADD	WORD,RELOCZ
	ADD	WORD,RELCZB
	JRST	EXTDIS
	PUSHJ	P,ILGF

;THIS IS THE ROUTINE THAT DOES THE RIGHT THING WHEN A WORD
;REFERS TO AN EXTERNAL DISPLACEMENT.  WHAT HAPPENS DEPENDS ON
;WHETHER THE SYMBOL HAS BEEN DEFINED OR NOT.  NEGATIVE VALUE
;MEANS NO DEFINITION, AND THAT WE'RE CHAINING DISPLACEMENTS

EXTDIS:	MOVE	T1,WORD		;GET THE WORD
	ANDI	T1,377		;GET DISPLACEMENT REFERENCE NUMBER.
	ADDI	T1,(T1)		;DOUT
	ANDI	WORD,177400	;AND OFF DISP. BITS
	SKIPL	T2,EXDBLK-1(T1)	;CHECK SIGN BIT
	JRST	EXTDIA		;SYMBOL IS DEFINED
	HRL	WORD,EXDBLK-1(T1)	;PUT LAST REFERENCE IN THIS WORD
	HRRM	$ORIGN,EXDBLK-1(T1)	;SET THIS ADDRESS AS NEXT REF.
	JRST	RED5		;RETURN TO PROCESSING
EXTDIA:	ADD	WORD,T2		;ADD IN DISPLACEMENT
	JRST	RED5

;THIS LAST TABLE BUMPS THE APPROPRIATE NMAX OR ZMAX

ADDCHK:	JFCL			;ABSOLUTE ADDRESS, DO NOTHING
	AOS	NMAX		;NORMAL RELOCATION
	JRST	ZCHECK		;PAGE ZERO RELOCATION, CHECK STUFF

ZCHECK:	CAIL	$ORIGN,400
	JRST	PZOERR
	AOS	ZMAX
	JRST	RED4
;PAGE 15 -- NRL
;PROCESSING AN ABSOLUTE BINARY FILE

ABSOLU:	TRZE	F,RREL		;WE'RE NOT IN RELOCATE MODE
	JRST	ILGBL		;OH DEAR, YES
	TRNN	WORD,100000	;START BLOCK?
	JRST	SSABS		;PEUT ETRE
	TRO	F,RABS		;SET FLAG BIT
	MOVN	AC1,WORD	;GET COMPLEMENT
	ANDI	AC1,WDMASK	;AND OUT EXTRANEOUS BITS
	CAILE	AC1,20
	 JRST	MDATAB		;THIS IS A MULTIPLE DATA BLOCK
	PUSHJ	P,BLDWRD	;GET ORIGIN
	MOVEM	WORD,$ORIGN
	PUSHJ	P,BLDWRD	;PASS BY CHECKSUM
LOOPER:	PUSHJ	P,BLDWRD	;GET DATA
	MOVE	ARG,WORD
	PUSHJ	P,$PTWRD	;PUT IN SIMULATED CORE
	 JRST	NOMCOR		;PUT FAILED, ERROR
	ADDI	$ORIGN,1	;BUMP ORIGIN
	SOJG	AC1,LOOPER	;BUMP WORD COUNT
	JRST	SKPB1		;CHECK CHECKSUM AND GET NEXT BLOCK

ABSONE:	SETZM	CHKSUM		;FIRST CLEAR CHECKSUM
	PUSHJ	P,$RDWRD	;IT'S AN ERROR BLOCK, WHICH IS IGNORED
	 JRST	LEOF+1
	CAIE	ARG,377		;ALL ONE'S INDICATE END OF BLOCK
	JRST	ABSONE
	JRST	GETBLK		;DONE, GET NEXT BLOCK
;PAGE 16 -- NRL
;FOUND ABSOLUTE BINARY START BLOCK

SSABS:	CAIE	WORD,1
	 JRST	ABSONE		;MUST BE AN ERROR BLOCK
SABS:	TRO	F,RSTART
	PUSHJ	P,BLDWRD
	ANDI	WORD,77777	;AND OFF EXTRANEOUS BIT
	MOVEM	WORD,SADR	;SAVE ADDRESS
	PUSHJ	P,BLDWRD	;GET CHECKSUM WORD
	JRST	SKPB1		;GET NEXT BLOCK, IF ANY

;MULTIPLE DATA BLOCK

MDATAB:	PUSHJ	P,BLDWRD	;GET WORD
	MOVEM	WORD,$ORIGN	;SAVE ADDRESS
	PUSHJ	P,BLDWRD	;GET CHECKSUM
	PUSHJ	P,BLDWRD	;GET DATA
	PUSHJ	P,CHCHSM	;CHECKSUM CHECK
LOOPEE:	MOVE	ARG,WORD	;GET DATUM
	PUSHJ	P,$PTWRD	;STORE IN CORE
	 JRST	NOMCOR
	ADDI	$ORIGN,1	;BUMP ADDRESS
	SOJG	AC1,LOOPEE	;DONE?
	JRST	GETBLK		;YES
;PAGE 17 -- NRL
;ERROR MESSAGES, ETC.

PRERR:	PUSHJ	P,$PRFIL	;PRINT HEADER FOR FILE
	HRLI	AC1,440700	;CREATE BYTE POINTER FOR MESSAGE
PRERR1:	ILDB	AC2,AC1		;GET CHARACTER
	CAIG	AC2,"4"		;CHECK FOR END OF MESSAGE
	CAIGE	AC2,"1"	;WHICH IS NUMERAL FROM 1-4
	JRST	.+2
	JRST	@TAB3-"1"(AC2)	;DISPATCH
	OUTCHR	AC2		;OUTPUT CHARACTER
	JRST	PRERR1

TAB3:	PRORIG
	PRSIXN
	CPOPJ
	CPOPJ		;JUST RETURN

PRORIG:	MOVE	ARG,$ORIGN	;PRINT ORIGIN
	PJRST	$PRVAL

PRSIXN:	MOVEI	ARG,SIXNAM	;PRINT CURRENT SYMBOL NAME
	PUSHJ	P,$PRSYM
	OUTCHR	[" "]		;AND ITS VALUE
	MOVE	ARG,SIXNAM+SYMV
	PJRST	$PRVAL

FATERR:	POP	P,(P)		;REMOVE EXTRANEOUS PUSHDOWN POINTER
	POPJ	P,0		;RETURN TO LEXEC QUIETLY

DONRET:	PUSHJ	P,PURGIT	;REMOVE BAD REFERENCE
	JRST	EXTDS		;SET THIS OCURRENCE IN SYMBOL TABLE

DISRET:	MOVE	ARG,AC2		;PRINT BAD DISPLACEMENT VALUE
	PUSHJ	P,$PRVAL
	SETZB	AC2,SIXNAM+SYMV	;ZERO OUT VALUES
	POPJ	P,0		;RETURN

;HEREIN FOLLOW FATAL ERROR MESSAGES

SYMERR:	ERRMS <NO ROOM IN SYMBOL TABLE 2>,FATERR
ILGBL:	ERRMS1 <ILLEGAL BLOCK TYPE 4>,WORD,CPOPJ
BADWC:	ERRMS1 <WORD COUNT OUT OF RANGE AT 4>,BLKNO,FATERR
RELERR:	ERRMS <OVERWRITE AT 1>,CPOPJ
PZRERR:	ERRMS <PAGE ZERO RELOC REVERSED4>,CPOPJ
NORERR:	ERRMS <EXTERNAL CONFLICT 2>,CPOPJ
PZOERR:	ERRMS <PAGE ZERO OVERFLOW4>,CPOPJ
BFERR:	ERRMS <BAD INPUT FILE, EOF AT 1>,CPOPJ
NOMCOR:	ERRMS <NO MORE CORE AVAILABLE 1>,CPOPJ
REVERR:	ERRMS <RELOCATION COUNTER REVERSED4>,CPOPJ
NMROOM:	ERRMS <TOO MANY EXTERNAL DISP. 2>,CPOPJ
NOLBND:	ERRMS <NO LIBRARY END BLOCK SEEN4>,CPOPJ

;HEREIN ARE NON-FATAL ERRORS

MULERR:	ERRMS <MULTIPLE ENTRY DEFINITIONS FOR 2>,ENTRYB
DISERR:	ERRMS <DISPLACEMENT OVERFLOW 4>,DISRET
DNERR:	ERRMS <DISPLACEMENT CONFLICT 2>,DONRET
ILGF:	ERRMS <ILLEGAL RELOC FLAG AT 1>,CPOPJ
SYFERR:	ERRMS <BAD LOCAL SYMBOL FILE4>,GETBLK
;PAGE 18 -- NRL
;END OF LOADER HERE.

$ELOAD:	TRNN	F,R44		;T SWITCH SET?
	JRST	PUNCH		;NO, JUST PUNCH
	MOVE	$ORIGN,$HI	;SET UP LOADER PARAMETERS
	ADDI	$ORIGN,1
	MOVEM	$ORIGN,AC1	;SAVE FOR LATER USE
	MOVE	ARG,ZMAX
	PUSHJ	P,$PTWRD	;STORE TOP OF PAGE ZERO
	 JFCL
	ADDI	$ORIGN,1
	SETZ	ARG,
	PUSHJ	P,$PTWRD	;ADDRESS OF START OF SYMBOL TABLE (?)
	 JFCL
	ADDI	$ORIGN,1
	SETZ	ARG,
	PUSHJ	P,$PTWRD	;ADDRESS OF FIRST LOC NOT USED BY SYMT
	 JFCL
	ADDI	$ORIGN,1
	MOVE	ARG,NMAX
	PUSHJ	P,$PTWRD	;STORE LAST CORE LOCATION USED
	 JFCL
	ADDI	$ORIGN,1
	SKIPN	ARG,SADR	;GET STARTING ADDRESS IF NOT ZERO
	MOVEI	ARG,177777	;ALL ONE'S
	PUSHJ	P,$PTWRD
	 JFCL
	MOVEI	$ORIGN,44	;ABSOLUTE LOC 44 GETS POINTER
	MOVE	ARG,AC1		;SAVED $HI
	PUSHJ	P,$PTWRD
	 JFCL

;NOW PUNCH OUT WHAT HAS BEEN LOADED IN ABSOLUTE FORMAT
;LIMITS FROM $LO TO $HI

PUNCH:	MOVE	$ORIGN,$LO
PNCHA:	PUSHJ	P,ZEROBL	;MAKE SURE PUNCH BLOCK AREA IS CLEAN
PNCHC:	SETZ	ZWDC,
	MOVEM	$ORIGN,PNBLK+1	;PUT STARTING ADDRESS IN BLOCK
	ADDM	$ORIGN,CHKSUM
PNCHB:	CAMLE	$ORIGN,$HI	;HIT UPPER LIMIT YET?
	JRST	ENDPUN		;YES, END OF PUNCHING
	PUSHJ	P,$GTWRD	;GET WORD
	JUMPE	ARG,ZEROWD	;IF ZERO, DO DIFFERENTLY
	JUMPN	ZWDC,ZWCHR	;ANY ZEROES HANGING AROUND?
	TRZ	F,RZERO		;NO, CLEAR FLAG
PNCHD:	MOVEM	ARG,PNB(NWDC)	;STORE THIS WORD
	ADDM	ARG,CHKSUM	;DO CHECKSUM
	ADDI	NWDC,1		;BUMP WORD COUNT
	ADDI	$ORIGN,1	;AND ORIGIN
	CAIGE	NWDC,20		;AT LIMIT?
	JRST	PNCHB		;NO, GET NEXT WORD
	PUSHJ	P,OUTBLK	;YES, PUNCH THIS BLOCK
	JRST	PNCHA		;AND START NEXT BLOCK

ENDPUN:	JUMPN	ZWDC,ENDZWC	;ANY MULTIPLE DATA BLOCKS AROUND?
	PUSHJ	P,OUTBLK	;NO, JUST OUTPUT
ENDST:	MOVE	T1,SADR		;NOW PUNCH START BLOCK
	MOVEM	T1,PNBLK+1
	MOVEI	CHKSUM,1(T1)	;START ADDRESS+1 (FOR BLOCK TYPE) TO CHECKSUM
	MOVEI	T1,1
	MOVEM	T1,PNBLK
	MOVEI	NWDC,3		;NUMBER OF WORDS TO GO OUT
	PJRST	OUTBLB		;OUTPUT BLOCK AND RETURN TO LEXEC

ENDZWC:	CAIG	ZWDC,20
	JRST	ZWCHRB		;RECYCLE AND OUTPUT NORMAL BLOCK
	PUSHJ	P,OUTMUL	;OUTPUT MULTIPLE DATA BLOCK
	JRST	ENDST		;AND CREATE START BLOCK
;PAGE 19 -- NRL
;CONTINUATION OF PUNCHING

;THIS SUBROUTINE ZEROES OUT THE PUNCH BUFFER
ZEROBL:	SETZM	PNBLK
	MOVE	T1,[XWD PNBLK,PNBLK+1]
	BLT	T1,PNBLK+22
	SETZB	CHKSUM,NWDC
	POPJ	P,0

ZWCHR:	CAILE	ZWDC,20
	JRST	ZWCHRA
ZWCHRB:	MOVE	$ORIGN,SAVADR
	TRO	F,RZERO
	SETZ	ZWDC,
	JRST	PNCHB
ZWCHRA:	PUSHJ	P,OUTMUL
	JRST	PNCHC

ZEROWD:	TRNE	F,RZERO
	JRST	PNCHD
	SKIPN	ZWDC
	MOVEM	$ORIGN,SAVADR
	ADDI	$ORIGN,1
	ADDI	ZWDC,1
	CAILE	ZWDC,20
	PUSHJ	P,OUTBLK
	JRST	PNCHB

OUTBLK:	JUMPE	NWDC,CPOPJ	;RETURN IF NOTHING TO OUTPUT
	MOVNI	T1,(NWDC)	;FORM NEGATIVE WORD COUNT
	ANDI	T1,WDMASK
	MOVEM	T1,PNBLK
	ADD	CHKSUM,T1
	ADDI 	NWDC,3
OUTBLB:	MOVNI	CHKSUM,(CHKSUM)
	ANDI	CHKSUM,WDMASK
	MOVEM	CHKSUM,PNBLK+2
	PUSHJ	P,LEADR		;FOUR WORDS OF BLANKS FOR LEADER
	SETZ	AC4,
OUTBLA:	MOVE	AC3,PNBLK(AC4)	;GET WORD
	PUSHJ	P,PNWRD
	ADDI	AC4,1
	SOJG	NWDC,OUTBLA	;MORE TO GO
	PUSHJ	P,LEADR		;PUNCH MORE LEADER
	PJRST	ZEROBL		;ZERO BLOCK AND POP

LEADR:	MOVEI	AC3,0
	PUSHJ	P,PNWRD
PNWRD:	LDB	ARG,[POINT 8,AC3,35]
	PUSHJ	P,$WRWRD
	LDB	ARG,[POINT 8,AC3,27]
	PJRST	$WRWRD

;OUTPUT A MULTIPLE DATA BLOCK.  WE NEVER COME HERE UNLESS
;ZWDC>20 AND NWDC=0
OUTMUL:	MOVNI	ZWDC,(ZWDC)
	ANDI	ZWDC,WDMASK
	MOVEM	ZWDC,PNBLK
	MOVE	T1,SAVADR
	MOVEM	T1,PNBLK+1
	MOVE	CHKSUM,SAVADR
	ADD	CHKSUM,ZWDC
	SETZM	PNBLK+3
	MOVEI	NWDC,4
	JRST	OUTBLB


LIT
;PAGE 20 -- NRL
;LOW SEGMENT CRUFT

	RELOC	0

	INTERN IPCODE
IPCODE:	^D315		;IDENTIFICATION CODE FOR TYMSHARE
$RADIX:	10
$BITS:	20
$DFINF:	SIXBIT	/NRL/
$DFBIN:	SIXBIT	/BIN/
UBEGN:
RELOC1:	BLOCK	1
RELOC2:	BLOCK	1
RELOC3:	BLOCK	1
SADR:	BLOCK	1
$RELOC:	BLOCK	1
RELOCZ:	BLOCK	1
RELOCB:	BLOCK	1
RELCZB:	BLOCK	1
$EMASK:	BLOCK	1

SIXNAM:	BLOCK	3
SAVNAM:	BLOCK	2
SAVPTR:	BLOCK	1
LKNPTR:	BLOCK	1
ZMAX:	BLOCK	1
NMAX:	BLOCK	1
SAVNMX:	BLOCK	1
SAVZMX:	BLOCK	1
BLKNO:	BLOCK	1
EXDBLK:	BLOCK	200*2
EXDPTR:	BLOCK	1
PNBLK:	BLOCK	3
PNB:	BLOCK	20
SAVADR:	BLOCK	1
UEND:


	END
   -AÈ