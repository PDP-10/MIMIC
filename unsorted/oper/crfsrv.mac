	TITLE	CRFSRV - SYMBOL TABLE CREF ROUTINES
	ENTRY	CREF,DCREF
	TWOSEG
	RELOC 400000

;CREF IS DONE THROUGH THE CREF WORD IN EACH SYMBOL BLOCK
;THE LEFT HALF IS A POINTER TO THE BEGINNING OF THE CREF CHAIN
;FOR THAT SYMBOL. THE RIGHT HALF IS A POINTER TO THE CURRENT
;CREF BLOCK FOR THE SYMBOL.
;A CREF BLOCK CONTAINS LINE NUMBERS PACKED TWO PER WORD.
;THE 400000 BIT IS SET IF THE SYMBOL WAS DEFINED ON THAT LINE.
;THE CURRENT BLOCK IS THE LAST BLOCK IN THE CHAIN. ITS FIRST WORD
;CONTAINS, INSTEAD OF A POINTER TO THE NEXT BLOCK, A COUNT OF THE
;NUMBER OF LINE NUMBERS CONTAINED IN THE BLOCK.

	EXTERN	$CRFNO	;EXEC'S LINE NUMBER
	EXTERN	ALLOC	;ALLOCATE
	INTERN	CURSYM	;HOLDS POINTER TO CURRENT SYMBOL.
			;WARNING!!! CORE ALLOCATORS MUST UPDATE
			;CURSYM IF THEY MOVE THE SYMBOL TABLE
			;WHILE OBTAINING CORE!!!

F=0	;EXEC FLAG AC
A=13	;ARG COMM AC
T2=14
T3=15
T4=16
S=17	;STACK POINTER

CRFSIZ=2	;2^2 WORDS PER CREF BLOCK
CRFMAX=6	;MAXIMUM NUMBER OF LINES PER BLOCK


DCREF:	MOVE	T4,$CRFNO	;CREF A DEFINITION.  GET LINE#,
	TROA	T4,400000	;SET HIGH ORDER BIT AND SKIP.
CREF:	MOVE	T4,$CRFNO	;GET CREF LINE NUMBER
CHKCRF:	TLNN	F,QCREF		;CREF ENABLED?
	POPJ	S,		;NO, GO RIGHT BACK
	MOVEM	T4,SAVLIN	;SAVE LINE NUMBER.
	SKIPN	T2,SYMC(A)	;YES, GET SYMBOLS CREF WORD
	JRST	,BEGCRF		;CREF WORD ZERO, MUST SET IT UP
	MOVE	T3,0(T2)	;GET BLOCK LINE COUNT OF CURRENT BLOCK
	LDB	T4,BYTBL-1(T3)	;GET CREF# OF LAST INSERTION IN
	CAME	T4,$CRFNO	;THS BLOCK.  DOES IT EQUAL CURRENT
	AOS	T3,0(T2)	;NO, ADVANCE TO NEXT SLOT.
	CAILE	T3,CRFMAX	;IS THERE A NEXT SLOT NOW?
	JRST	NEWCRF	;NO.
	MOVE	T4,SAVLIN	;YES, GET CURRENT DEFINITION.
	DPB	T4,BYTBL-1(T3)	;STORE IT AWAY.
	POPJ	S,	;AND VANISH.

NEWCRF:	MOVEM	A,CURSYM	;NEED A CREF BLOCK, SAVE POINTER TO SYMBOL
	MOVEI	A,CRFSIZ	;ALLOCATE CREF BLOCK
	PUSHJ	S,ALLOC
	JRST	NOALLC	;COULDNT, GIVE UP.
	HRRZ	T4,CURSYM	;RECOVER POINTER TO SYMBOL BLOCK
	MOVE	T2,SYMC(T4)	;RECOVER POINTER TO CURRENT CREFBLK
	MOVEM	A,0(T2)		;LINK TO FILLED BLOCK
CURCRF:	HRRM	A,SYMC(T4)	;THIS BLOCK BECOMES CURRENT ONE
	MOVEI	T2,1	;SET BLOCK COUNT TO 1.
	MOVEM	T2,0(A)
	MOVE	T2,SAVLIN	;STORE LINE NUMBER IN FIRST
	HRLM	T2,1(A)	;FIRST SLOT OF CREF BLOCK.
NOALLC:	MOVE	A,CURSYM		;AT LAST RECOVER ORIGINAL ARGUMENT.
	POPJ	S,	;EXIT.

BEGCRF:	MOVEM	A,CURSYM		;INIT CREF LIST FOR THIS SYMBOL
	MOVEI	A,CRFSIZ	;ALLOCATE BLOCK
	PUSHJ	S,ALLOC
	JRST	NOALLC	;COULDNT, GIVE UP
	HRRZ	T4,CURSYM	;RECOVER ORIGINAL SYMBOL BLOCK POINTER
	HRLM	A,SYMC(T4)	;SVE POINTER TO BEGINNING OF LIST
	JRST	,CURCRF		;AND TREAT AS IF NEW BLOCK

BYTBL:	POINT 18,1(T2),17	;SLOT 1
	POINT 18,1(T2),35	;SLOT 2
	POINT 18,2(T2),17	;SLOT 3
	POINT 18,2(T2),35	;SLOT 4
	POINT 18,3(T2),17	;SLOT 5
	POINT 18,3(T2),35	;SLOT 6
	SUBTTL OUTPUT AN ARBITRARY RADIX INTEGER
	ENTRY WRTINT,WRTNOL
	INTERN NRADIX,NBITS,VALUE,LEADER
	EXTERN $WRCHR

	ARG=13
	AC1=13
	MASK=14	;MASK+1 MUST BE AVAILABLE!
	TEST=16
	DIGITS=12	;DIGITS MUST BE PRESERVED BY $WRCHR!
STK=17

;
;WRTINT OUTPUTS THE INTEGER IN VALUE
;MASKED BY AN NBIT-WIDE MASK, WITH REPRESENTATION
;APPROPRIATE TO RADIX
;
;AFTER COMPUTING A DIGIT'S VALUE,
;THE CHARACTER CODE IS GENERATED BY THE FOLLOWING MAPPING -
;OCTAL DIGIT VALUE	REPRESENTATION	ASCII CODE	TRANSFORMATION
; 0 - 11		 0 - 9		 60 - 71	 +60
;12 - 43		 A - Z		101 - 132	 +67
;DIGITS GREATER THAN 43 (FOR RADICES GREATER THAN 43)
;CANNOT BE REPRESENTED, AND CAUSE UNFLAGGED GARBAGE IN THE OUTPUT
;
WRTNOL:	AOSA	,NOLEAD		;TURN ON NO LEADER FLAG
WRTINT:	SETZM	,NOLEAD		;TURN OFF NO LEADER FLAG
	MOVEI	DIGITS,1	;SET UP INITIAL DIGIT WIDTH OF OUTPUT
	MOVE	AC1,NBITS	;COMPUTE MASK FROM MASK WIDTH
	MOVEI	MASK,1		;START WITH 2^0
	LSH	MASK,0(AC1)	;COMPUTE 2^NBITS
	MOVEM	MASK,DIGTST	;SAVE FOR DIGIT WIDTH COMPUTATION
	SUBI	MASK,1		;2^NBITS -1 IS NBIT WIDE MASK
	AND	MASK,VALUE	;MASK GETS VALUE TO BE CONVERTED
	MOVE	TEST,NRADIX	;NOW COMPUTE DIGIT WIDTH OF OUTPUT
TSTDIG:	CAML	TEST,DIGTST	;IS LARGEST REPRESENTABLE NUMBER BIG ENOUGH?
	JRST	,NXTDIV-1	;YES, HAVE ENOUGH DIGITS TO DISPLAY MASKED VALUE
	IMUL	TEST,NRADIX	;NO,GO TO NEXT LARGEST REPRESENTABLE NUMBER
	AOJA	DIGITS,TSTDIG	;WHICH REQUIRES ONE MORE DIGIT
	SETZM	,DIGCNT		;READY TO GO, INITIALIZE COUNT OF CONVERTED DIGITS
NXTDIV:	IDIV	MASK,NRADIX	;CONVERT VALUE BY DIVIDING BY RADIX
	CAILE	MASK+1,11	;REMAINDER (IN NEXT AC) IS DIGIT
	ADDI	MASK+1,7	; 12 - 43  = A - Z , ADD 67 TO CONVERT
	ADDI	MASK+1,60	;  0 - 11  = 1 - 9 , ADD 60 TO CONVERT
	PUSH	STK,MASK+1	;SAVE THE DIGIT ON THE STACK
	AOS	,DIGCNT		;COUNT THE DIGIT
	JUMPN	MASK,NXTDIV	;GO FOR NEXT DIGIT (IF ANY LEFT)
TSTLDR:	SKIPN	,NOLEAD	;IS LEADER WANTED?  IF SO,
	CAMG	DIGITS,DIGCNT	;SEE IF ANY LEADING CHARACTERS NEEDED
	JRST	,DIGOUT		;NO, GO AHEAD WITH OUTPUT
	MOVE	ARG,LEADER	;THEY ARE WANTED... OUTPUT THE
	PUSHJ	STK,$WRCHR	;LEADER CHARACTER.
	SOJA	DIGITS,TSTLDR	;ACCOUNT FOR OUTPUT CHARACTER
;
DIGOUT:	POP	STK,ARG		;LEADER TAKEN CARE OF, OUPUT DIGITS,
	PUSHJ	STK,$WRCHR
	SOSE	,DIGCNT		;COUNT THE OUTPUT DIGIT
	JRST	,DIGOUT
	POPJ	STK,		;ALL DIGITS OUTPUT, RETURN
	LIT
;
;VARIABLES.

	RELOC 0
NOLEAD:	BLOCK 1
LEADER:	" "	;LEADER FILL CHARACTER
VALUE:	BLOCK 1
NBITS:	BLOCK 1
NRADIX:	BLOCK 1
DIGCNT:	BLOCK 1
DIGTST:	BLOCK 1
SAVLIN:	BLOCK 1
CURSYM:	BLOCK 1
	END
