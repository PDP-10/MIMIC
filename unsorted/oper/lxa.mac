	TITLE LEXEC	MIMIC LINKING LOADER EXECUTIVE
	SUBTTL EXEC PARAMETERS
	TWOSEG
	RELOC 400000
	SALL

;INSTALLATION SWITCHES

IFNDEF ONLINE,<	ONLINE=0>
IFNDEF TYMSHR,<	TYMSHR=0>
IFNDEF FDATA,<	FDATA=0>
IFNDEF DTALIN,<	DTALIN=0>

;R.M. SUPNIK, 11/1/71.
;
;ACCUMULATORS:

	F=0	;FLAGS
	A=13	;ARGUMENT
	ARG==A
	P=17	;PUSHDOWN

	T=14	;TEMPORARIES, AVAILABLE TO LEXEC
	PA1==14
	T1=15
	PA2==15
	T2=16
	PA3==16

;I/O CHANNELS

	INF=1	;CURRENT INPUT FILE
	SYM=2	;CURRENT SYMBOL INPUT FILE
	OTF=3	;OUTPUT FILE
	OSF=4	;OUTPUT SYMBOL FILE
	MAP=5	;LOAD MAP (UNIMPLEMENTED)
	CCL=6	;COMMAND FILE

;DEVCHR BITS (LEFT HALF OF AC)

	DSKDEV=200000	;DEVICE IS A FILE STRUCTURE
	DIRDEV=000004	;DEVICE IS A DIRECTORY DEVICE
	INPDEV=000002	;DEVICE IS AN INPUT DEVICE
	OTPDEV=000001	;DEVICE IS AN OUTPUT DEVICE

;I/O ERROR BITS

	IOIMPM=400000	;IMPROPER MODE
	IODERR=200000	;DEVICE ERROR
	IODTERR=100000	;DATA ERROR
	IOBKTL=040000	;BLOCK TOO LARGE
	IOEOF=020000	;END OF FILE

;LOCAL FLAGS (RIGHT HALF OF F):

	QFST=400000	;FIRST FIELD IN COMMAND FLAG
	QINTR=200000	;SORT INTERCHANGE FLAG
;LEXEC A, PAGE 1
;FILE DESCRIPTION BLOCKS.  FOR EACH FILE POTENTIALLY
;HANDLED BY THE SYSTEM (INF, OTF, SYM, OSF), THERE IS AN ASSOCIATED
;BLOCK GIVING THE NECESSARY INFORMATION ABOUT THE FILE FOR THE
;FIELD.  THE BLOCK IS FORMATTED AS FOLLOWS:

FBUFH=0	;WORD 0: PTR TO PREALLOCATED FILE BUFFER
FDFNAM=1	;1: DEFAULT FILE NAME
FDFEXT=2	;2: DEFAULT FILE EXTENSION
FNAM=3	;3: CURRENT FILE NAME
FEXT=4	;4: CURRENT FILE EXTENSION
FPJ=6	;6: CURRENT PROJECT#, PROG#
FOPEN=7	;7: OPEN BLOCK
FDEV=^D8	;8: CURRENT DEVICE
FPTR=^D9	;9: PTR TO FILE HEADER
FCHL=^D10	;10: ASSIGNED CHANNEL
FHDR=^D11	;11: FILE HEADER
FSWT=^D14	;14: SWITCH TABLE
FFLD=^D15	;15: FIELD NAME (ASCII)

;WITHIN THE FILE HEADER, INDIVIDUAL FIELDS ARE IDENTIFIELD BY
;OFFSETS:

HBYT=1	;BYTE PTR
HCNT=2	;BYTE COUNT

INFHDR=INFBLK+FHDR
OTFHDR=OTFBLK+FHDR
OSFHDR=OSFBLK+FHDR
SYMHDR=SYMBLK+FHDR
CCLHDR=CCLBLK+FHDR

BUFSIZ=203	;BUFFER SIZE
STKLN=100	;STACK LENGTH
CCLNAM='MLE'	;CCL FILE NAME IS MIMIC LINK EDITORS
;LEXEC A, PAGE 3
;USEFUL MACROS:

	DEFINE CPY(B,C)
<	MOVE T,B
	MOVEM T,C>

	DEFINE SW(B,C)
<	ASCIZ /B/
	C>

	DEFINE MCH(B)
<	MOVE PA1,@COMPTR
	CAIE PA1,B>

	DEFINE MCHR(B)
<	MOVE PA1,@COMPTR
	CAIN PA1,B>

	OPDEF FAIL [JRST]
	OPDEF SKP [CAIA]
	OPDEF PJRST [JRST]

	NM==ARG
	SUBTTL MAIN EXECUTIVE
;LEXEC A, PAGE 4
;THE MAIN EXECUTIVE IS NOT A VERY HAIRY AFFAIR.  ESSENTIALLY,
;WE NEED TO PROCESS A COMMAND STRING MADE UP AS FOLLOWS:
; OUTPUT FILE_INPUT FILE,INPUT FILE,...,INPUT FILE<ALTMODE>
;IF NO OUTPUT FILE IS SPECIFIED, THE EXECUTIVE CONDUCTS AN
;INTERACTIVE DIALOG TO GET THE NECESSARY INFORMATION.

LEXEC:	TDZA F,F	;NORMAL START, ZERO ALL FLAGS.
CCLST:	MOVSI F,QCCL	;CCL START, SET CCL FLAG.
	MOVE P,[IOWD STKLN,STKST]	;INITIALIZE THE STACK.
	PUSHJ P,INITCD	;INITIALIZE THE COMMAND DEVICE (ONCE).
NEWPRG:	IFN TIMLTD,<	EXTERN CHARGE
	JSP 16,CHARGE
	JUMP 0,1	;WRITE INITIAL BILL
	JUMP 0,[ASCII/MIM3/]
>
	PUSHJ P,INITFS	;FOR EACH PROG, INITIALIZE FREE STORAGE.
	PUSHJ P,$INITU	;INITIALIZE THE USER.

NEWLIN:	TLNE F,QEOF	;END OF FILE ON CCL DEVICE?
	JRST ENDLOD	;YES, PRETEND END OF COMMAND STRING.
	PUSHJ P,GETLIN	;GET A COMMAND LINE.

LOADLP:	MOVEI A,INFBLK	;USING THE INPUT FILE BLOCK,
	PUSHJ P,GETNAM	;LOOK FOR A FILE NAME.
	JRST NOFILE	;NOT FOUND.
	MCHR "@"	;DID IT END IN @?
	JRST USRCCL	;YES, USER SUPPLIED CCL FILE.
	TROE F,QFST	;FOUND, IS IT THE FIRST (SET NOT FIRST FLAG)?
	JRST NOTFST	;NO.
	CAIE PA1,"_"	;FIRST FILE.  DID IT END IN _ OR =?
	CAIN PA1,"="
	JRST CHKINF	;YES, INPUT FILE SPECIFIER.
NOTFST:	PUSHJ P,INITIF	;NOT FIRST OR NOT INPUT... INITIALIZE.
	JRST ENTFND	;ERROR, DON'T LOAD.
	PUSHJ P,$LOADR	;FILE OK, CALL LOADER.
	JRST FATALE	;NON-SKIP: FATAL ERROR.
ENTFND:
NOFILE:	MCH "+"		;DID COMMAND END IN + OR COMMA?
	CAIN PA1,","
	JRST LOADLP	;YES, GO ON TO NEXT FILE.
	PUSHJ P,CHKALT	;NO, IN ALTMODE?
	SKIPA
	JRST ENDLOD	;YES, END OF LOAD.
	PUSHJ P,CHKEOL	;NO GO THERE.  IN SOME OTHER TERMINATOR?
	JRST BADLIN	;NO, ERROR
	JRST NEWLIN	;YES, GO GET NEW COMMAND LINE.

ENDLOD:	OUTSTR CRLF	;AFTER ALTMODE, OUTPUT CR-LF.
	PUSHJ P,CNTUND	;END OF LOAD.  COUNT UNDEFINED GLOBALS.
	JRST DODIAL	;NONE, GO DO DIALOG.
	PUSHJ P,TYPJU	;SOME LEFT. GO TYPE THEM.
	TLZ F,QCCL+QCCLC+QCCLU+QEOF	;CLEAR CCL FLAGS, IF ON.
	JRST NEWLIN	;GO GET MORE COMMANDS.

DODIAL:	TLNE F,QMAP	;LOAD MAP REQUEST?
	PUSHJ P,TYPMAP	;YES, TYPE IT OUT.
	PUSHJ P,DIALOG	;CHECK TO SEE IF DIALOG NEEDED TO GET
	TLNN F,QOBFIL	;OUTPUT FILE.  ANY OUTPUT FILE SPECIFIED
	JRST NOUTPT	;BY ANY DEVIOUS MEANS?
	PUSHJ P,$ELOAD	;GO CLEAN UP LOADER PROCESS.
	PUSHJ P,DMPSYM	;GO DUMP COMPOSITE SYMBOL FILE.
FATALE:			;ON FATAL ERROR, GIVE UP.
NOUTPT:	PUSHJ P,EXCLOS	;CLOSE DOWN THE EXEC.
IFN TIMLTD,<
	JSP 16,CHARGE	;WRITE FINAL BILL
	JUMP 0,2
	JUMP 0,[ASCII/MIM3/]
>
	TLNN F,QEOF	;END OF CCL FILE REACHED?  NO,
	JRST NEWPRG	;TRY FOR ANOTHER PROGRAM.
IFN ONLINE,<	EXTERN BILFRC
	PUSHJ P,BILFRC	;EXIT, FORCE BILL OUT.
>
IFN TYMSHR,<	PUSHJ P,BRF	;WRITE FINAL BILL
>
	EXIT		;EXIT TO MONITOR AND DONT RETURN.

;ONCE AGAIN, THERE ARE A SMALL NUMBER OF SUBROUTINES WHICH
;THE USER MUST PROVIDE.  THESE ARE:

	EXTERN $INITU,$ELOAD,$LOADR
	INTERN SYMBEG
	ENTRY $RDWRD,$WRWRD,$RDSYM,$WRSYM
	EXTERN $RADIX,$BITS,$USRSW,$DFBIN
	EXTERN JOBREN,$DFINF,$EMASK
;LEXEC A, PAGE 5
;MORE OF THE EXECUTIVE.

CHKINF:	MOVEI A,OTFBLK	;OUTPUT FILE SPECIFIER: COPY FILE
	PUSHJ P,MOVSCN	;INFORMATION TO OTF BLOCK.
	MOVEI A,OSFBLK	;COPY SAME INFORMATION TO OSF BLOCK.
	PUSHJ P,MOVIMP
	TLO F,QOBFIL	;SET OUTPUTBINARY FILE FLAG.
	JRST LOADLP	;GO CONTINUE COMMAND SCAN.

BADDLG:			;ON DIALOG ERROR, RESTART.
DIALOG:	TLZE F,QOBFIL	;HAS AN OUTPUT FILE ALREADY BEEN SPECIFIED?
	JRST NODIAL	;YES, NO DIALOG NEEDED.
	OUTSTR FILMSG	;OUTPUT MESSAGE "FILE="
	PUSHJ P,TTYLIN	;GET INPUT LINE FROM TTY.
	MOVEI A,OTFBLK	;SCAN FOR A FILE NAME.
	PUSHJ P,GETNAM
	POPJ P,		;NOT FOUND, EXIT.
	MOVEI A,OTFBLK	;FOUND, STORE INFORMATION FROM SCANNER.
	PUSHJ P,MOVSCN
	MOVEI A,OSFBLK
	PUSHJ P,MOVIMP
NODIAL:	PUSHJ P,INITOF	;INITIALIZE THE OUTPUT FILE(S).
	JRST BADDLG	;NO GO, TRY AGAIN.
	POPJ P,		;EXIT.

CHKALT:	SKIPA T1,[ALTTBL]	;A SIMPLE MATHCING ROUTINE,
CHKEOL:	MOVEI T1,EOLTBL	;ONE FOR ALTMODES, OTHER FOR ALL TERMINATORS.
	SKIPN T2,(T1)
	POPJ P,
	CAME T,T2
	AOJA T1,CHKEOL+1
CPOPJ1:	AOS ,(P)
	POPJ P,

EOLTBL:	15	;LINE TERMINATORS:  CR
	12	;LF
	07	;BELL
	13	;VERTICAL TAB
	32	;^Z
	14	;FORM FEED
ALTTBL:	33	;ALTMODE IN VARIOUS FORMS
	175
	176
	Z
;LEXEC A, PAGE 6
;COMMAND DEVICE SUBROUTINES.
;INITCD-- INIALIZE COMMAND DEVICE.  SETS UP CCL FILE IF
;	SPECIFIED.  DOES NOTHING FOR TTY.
;GETLIN-- GET A LINE FROM EITHER THE TTY OR THE CCL FILE.
;
FILMSG:	ASCIZ /OUTPUT FILE=/

INITCD:	RESET	;RESET ALL I/O DEVICES.
	CLRBFI	;CLEAR TTI BUFFER.
IFN ONLINE,<	EXTERN BILL
	PUSH P,F	;SAVE AC-0, ONLY ACTIVE AC.
	PUSHJ P,BILL	;CALL BILLING PROGRAM
	ARG 5,XN1
	ARG 5,XE1
	ARG 5,XN2
	ARG 5,XE2
	ARG 0,XNCO2
	ARG 0,XNPR2
	ARG 5,XN3
	ARG 5,XE3
	ARG 0,XNCO3
	ARG 0,XNPR3
	ARG 2,XPCT1
	ARG 2,XPCT2
	ARG 0,XMIN
	POP P,F	;POP FLAGS.
>
IFN TYMSHR,<
	PUSHJ P,BRI	;WRITE INITIAL BILLING RECORD
>
	TLNN F,QCCL	;INITIALIZE COMMAND DEVICE.  ARE WE EXPECTING
	POPJ P,		;A CCL FILE?  NO, EXIT.
	SETZM ,CCLBUF	;YES, SO ZERO THE CCL BUFFER.
	MOVE T,[XWD CCLBUF,CCLBUF+1]
	BLT T,CCLBUF+BUFSIZ-1
	MOVE T1,[XWD 2,TMPBLK]	;YES, FIRST TRY FOR TMPCOR FILE.
	TMPCOR T1,	;DO A READ-AND-DELETE ON TMPCOR FILE 'MLE'.
	JRST NOTCOR	;NOT IMPLEMENTED OR NOT FOUND, TRY FOR REAL FILE.
	TLO F,QCCLC	;FOUND AND READ, SET CCL CORE FLAG.
	MOVEI T1,5*200	;SET UP FAKE BYTE POINTER AND BUFFER COUNT
	MOVEM T1,CCLHDR+HCNT	;FOR GET CHARACTER ROUTINE.
	MOVE T1,[POINT 7,CCLBUF]
	MOVEM T1,CCLHDR+HBYT
	POPJ P,		;EXIT.

TMPBLK:	XWD CCLNAM,0	;TMPCOR BLOCK:  FILE NAME
	IOWD 200,CCLBUF	;READ COMMAND.

NOTCOR:	PUSHJ P,MAKCCL	;MAKE UP THE CCL FILE NAME FROM JOB#.
OPNCCL:	OPEN CCL,CCLBLK+FOPEN	;OPEN THE CCL CHANNEL.
	JRST NOCCL	;ERROR, SET EOF FLAG.
	LOOKUP CCL,CCLBLK+FNAM	;LOOKUP THE FILE.
	JRST NOCCL	;NO GO.
	PUSH P,JOBFF	;SAVE CURRENT JOBFF.
	MOVEI T1,CCLBUF	;FORCE MONITOR BUFFER ALLOCATION TO EXPECTED
	MOVEM T1,JOBFF	;AREA FOR CCL FILES.
	INBUF CCL,1	;ONE BUFFER WILL DO.
	POP P,JOBFF	;RESTORE JOBFF.
	POPJ P,		;EXIT.

MAKCCL:	MOVEI A,3	;TRIED AND TRUE METHOD FOR MAKING A CCL
	PJOB T,		;FILE NAME.
MAKPJ:	IDIVI T,^D10	;CONVERT JOB # TO THREE SIXBIT DIGITS.
	ADDI T1,'0'
	LSHC T1,-6
	SOJG A,MAKPJ
	HLR T2,TMPBLK	;PUT SIXBIT FILE NAME IN RIGHT HALF.
	MOVEM T2,CCLBLK+FNAM	;STORE IN CCL BLOCK.
	POPJ P,		;EXIT.

USRCCL:	TLOE F,QCCL+QCCLU	;USER SUPPLIED CCL FILE.  ARE WE IN
	JRST BADLIN	;THE MIDDLE OF A CCL FILE?  YES, ERROR.
	MOVEI A,CCLBLK	;NO, SET UP POINTER TO CCL FILE BLOCK.
	MOVE T1,SCNDEV	;GET USER SUPPLIED DEVICE.
	DEVCHR T1,	;IS IT A DIRECTORY DEVICE?
	TLNN T1,DIRDEV
	JRST BADDV1	;NO, ERROR.
	PUSHJ P,MOVSCN	;YES, SET UP CCL BLOCK FILE NAME.
	PUSHJ P,OPNCCL	;OPEN THE CCL FILE.
	JRST NEWLIN	;GET A NEW LINE (FROM THE CCL FILE).
;LEXEC A, PAGE 6B
;GET LINE ROUTINES FOR TELETYPE AND CCL FILE.
;
GETLIN:	TLNE F,QCCL	;GET A LINE.  FROM CCL FILE?
	JRST CCLLIN	;YES.
TTYLIN:	OUTCHR ["*"]	;TYPE OUT INPUT REQUEST.
IFN TYMSHR,<
	PUSHJ P,BRCP	;WRITE CHECKPOINT BILL
>
	MOVEI T,COMBUF-1	;INITIALIZE SCANNING POINTER.
	MOVEM T,COMPTR
	INCHWL COMBUF	;GET FIRST CHARACTER.
	INCHRS 2(T)	;TRY FOR SUBSEQUENT CHARACTERS.
	POPJ P,		;NOT FOUND, EXIT.
	AOJA T,.-2	;FOUND, ADVANCE BUFFER POINTER.

CCLLIN:	MOVEI A,COMBUF-1	;LINE FROM CCL.
	MOVEM A,COMPTR	;INITIALIZE SCANNING POINTER.
NEWCCL:	PUSHJ P,GETCCL	;GET A CCL CHARACTER.
	MOVEM T,1(A)	;STORE IT.
	PUSHJ P,CHKEOL	;END OF LINE?
	AOJA A,NEWCCL	;NO, ADVANCE PTR AND GET NEXT CHAR.
IFN TYMSHR,<
	PUSHJ P,BRCP	;WRITE A CHECKPOINT BILLING RECORD
>
	POPJ P,		;YES, EXIT.

GETCCL:	SOSLE ,CCLHDR+HCNT	;GET CCL CHARACTER. BUFFER EMPTY?
	JRST OKTOGT	;NO, GET CHARACTER.
	TLNE F,QCCLC	;YES.  WAS INPUT FROM TMPCOR FILE?
	JRST NOCCLC	;IF SO, NO MORE INPUT.
	INPUT CCL,	;OTHERWISE, GET NEXT INPUT BUFFER.
	STATZ CCL,IOEOF	;CHECK FOR END OF FILE.
	JRST NOMORC	;END OF FILE, NO MORE COMMANDS.
OKTOGT:	ILDB T,CCLHDR+HBYT	;EVERYTHING OK, GET CHARACTER
	JUMPE T,GETCCL	;IGNORE ZERO CHARACTERS
	POPJ P,		;AND RETURN.

NOMORC:	TLNE F,QCCLU	;EOF.  USER SUPPLIED FILE?
	JRST NODLTE	;THEN DONT DELETE IT.
	SETZM CCLBLK+FNAM	;END OF COMMAND FILE, ZERO THE FILE
	RENAME CCL,CCLBLK+FNAM	;NAME AND DELETE IT.
	JFCL		;NO ERRORS TODAY.
NODLTE:	RELEAS CCL,	;RELEASE THE CCL CHANNEL.
NOCCLC:	MOVEI T,15	;RETURN END-OF-LINE.
NOCCL:	TLO F,QEOF	;SET END-OF-FILE FLAG.
	TLZ F,QCCL+QCCLC+QCCLU	;CLEAR CCL FLAGS.
	POPJ P,		;EXIT.
;LEXEC A, PAGE 7
;I/O SUBROUTINES WHICH DO ALL THE WORK:
;INITIF-- INITIALIZE INPUT FILES, BOTH BINARY AND SYMBOLS
;INITOF-- INITIALIZE OUTPUT FILES, BOTH BINARY AND SYMBOLS
;$RDWRD-- READ WORD FROM CURRENT BINARY INPUT FILE
;$WRWRD-- WRITE WORD TO BINARY OUTPUT FILE
;$RDSYM-- READ WORD FROM CURRENT SYMBOL INPUT FILE
;$WRSYM-- WRITE WORD TO SYMBOL OUTPUT FILE

INITIF:	TLZ F,QSYM	;CLEAR SYMBOL FILE FLAG.
	MOVEI A,INFBLK	;INITIALIZE INPUT FILES.  ENTER WITH FILE
	PUSHJ P,MOVSCN	;NAME IN SCANNER AREA.   MOVEI IT TO
	MOVE T,SCNDEV	;INPUT FILE AREA.  GET DEVICE NAME.
	DEVCHR T,	;GET ITS CHARACTERISTICS.
	TLNN T,INPDEV	;IS IT AN INPUT DEVICE?
	JRST BADDEV	;NO, CANNOT BE USED.
	OPEN INF,INFBLK+FOPEN	;OPEN THE BINARY INPUT FILE.
	JRST EROPEN	;NO GO.
	PUSHJ P,INITBF	;INITIALIZE RESERVED BUFFERS.
	LOOKUP INF,INFBLK+FNAM	;LOOKUP SPECIFIED FILE.
	JRST LKFAIL	;NOT FOUND.

DONEXT:	MOVEI A,SYMBLK	;MOVE SCANNER INFORMATION TO INPUT SYMBOL
	PUSHJ P,MOVIMP	;FILE AREA.
	MOVE T,SCNDEV	;GET SCANNER OUTPUT.
	DEVCHR T,	;GET ITS CHARACTERISTICS.
	TLNN T,DIRDEV	;DIRECTORY DEVICE?
	JRST NOSYMF	;NO, NO SYMBOL FILE POSSIBLE.
	OPEN SYM,SYMBLK+FOPEN	;OPEN SYMBOL FILE.
	JRST EROPEN	;NO GO.
	PUSHJ P,INITBF	;INITIALIZE SYM FILE BUFFERS.
	LOOKUP SYM,SYMBLK+FNAM	;LOOKUP SPECIFIED FILE.
	JRST NOSYMF	;NOT FOUND.
	TLO F,QSYM	;FOUND, SET SYMBOL FILE FLAG.
NOSYMF:	AOS ,(P)	;TAKE SKIP RETURN.
	POPJ P,

LKFAIL:	SKIPE ,SCNEXT	;LOOKUP FAILURE.  WAS AN EXTENSION GIVEN?
	JRST ERLKUP	;YES, DON'T TRY AGAIN.
	SETZM INFBLK+FEXT	;NO, TRY AGAIN WITH ZERO EXTENSION.
	LOOKUP INF,INFBLK+FNAM
	JRST ERLKUP	;FAILED AGAIN, GIVE UP.
	JRST DONEXT	;OK, LOOK UP SYMBOL FILE.
;LEXEC A, PAGE 8

INITOF:	TLZ F,QSMO	;CLEAR SYMBOL OUTPUT FLAG.
	MOVEI A,OTFBLK	;INITIALIZE OUTPUT FILE.  COPYING FROM
	MOVE T,OTFBLK+FDEV	;SCANNER HAS ALREADY
	DEVCHR T,	;TAKEN PLACE.  GET DEVICE CHARS.
	TLNN T,OTPDEV	;OUTPUT DEVICE?
	JRST BADDEV	;NO, DIE.
	OPEN OTF,OTFBLK+FOPEN	;YES, OPEN OUTPUT FILE.
	JRST EROPEN	;DEAD.
	PUSHJ P,INITBF	;INITIALIZE BUFFERS.
	ENTER OTF,OTFBLK+FNAM	;ENTER OUTPUT FILE.
	JRST ERENTR	;DOA.
	TLO F,QOBFIL	;EVERYTHING OK, SET OUTPUT FILE FLAG.

DONXT1:	MOVEI A,OSFBLK	;INITIALIZE OUTPUT SYMBOL FILE.  GET
	MOVE T,OSFBLK+FDEV	;SPECIFIED DEVICE.
	DEVCHR T,	;GET ITS CHARACTERISTICS.
	TLNE T,DIRDEV	;DIRECTORY DEVICE AND
	TLNN F,QSMRQ	;SYMBOL FILE REQUEST OUTSTANDING?
	JRST CPOPJ1	;NO, IGNORE SYMBOL FILE.
	OPEN OSF,OSFBLK+FOPEN	;OPEN OUTPUT SYMBOL FILE.
	JRST EROPEN	;RIP.
	PUSHJ P,INITBF	;INTIALIZE BUFFERS.
	ENTER OSF,OSFBLK+FNAM	;CREATE THE FILE.
	JRST ERENTR	;DEAD.
	TLO F,QSMO	;SET SYMBOL OUTPUT FLAG.
	JRST CPOPJ1	;TAKE SKIP RETURN.

MOVSCN:	SKIPN T,SCNEXT	;COPY FROM SCANNER TO BLOCK SPECIFIED BY
	;ARG.  MOVSCN USES SCANNER EXTENSION, UNLESS NONE SPECIFIED.
	;MOVIMP ALWAYS USES DEFAULT EXTENSION.
MOVIMP:	MOVE T,FDFEXT(A)
	HLLZM T,FEXT(A)	;COPY EXTENSION.
	CPY SCNDEV,FDEV(A)	;COPY DEVICE.
	CPY SCNNAM,FNAM(A)	;COPY FILE NAME.
	CPY SCNPJ,FPJ(A)	;COPY PJ# PG#
	SETZM FEXT+1(A)	;CLEAR CREATION DATE WORD.
	POPJ P,		;EXIT.
;LEXEC A, PAGE 9

	DEFINE PIO(B)	;DO PROGRAMMED OUTPUT
<	SOSG B'HDR+HCNT	;BLOCK COUNT EXHAUSTED?
	PUSHJ P,B'DMP	;YES, OUTPUT CURRENT BLOCK.
	IDPB A,B'HDR+HBYT	;STORE NEXT WORD.
	POPJ P,		;EXIT.

B'DMP:	OUTPUT B,	;OUTPUT BLOCK.
B'TST:	STATO B,IODERR+IODTER+IOBKTL+IOIMPM	;ERROR?
	POPJ P,		;NO, EXIT.
	MOVEI A,B'BLK	;YES, GIVE MESSAGE
	JRST IOERR>

	DEFINE PIA(B)	;DO PROGRAMMED INPUT.
<	SOSG B'HDR+HCNT	;CURRENT BUFFER EXHAUSTED.
	JRST B'GET	;YES, GET NEW BUFFER
B'GTX:	ILDB A,B'HDR+HBYT	;NO, GET NEXT BYTE
	JRST CPOPJ1	;TAKE SKIP RETURN.

B'GET:	INPUT B,	;GET NEW BLOCK.
	STATZ B,IOEOF	;END OF FILE?
	POPJ P,		;TAKE NON-SKIP RETURN.
	STATO B,IODERR+IOBKTL+IOIMPM+IODTER	;ERROR?
	JRST B'GTX	;NO, GO BACK.
	MOVEI A,B'BLK	;YES, GIVE MESSAGE
	JRST IOERR>

$RDWRD:	PIA INF;	;$RDWRD READS FROM INF

$RDSYM:	TLNN F,QSYM	;$RDSYM READS FROM SYM
	POPJ P,
	PIA SYM;

$WRWRD:	TLNN F,QOBFIL	;$WRWRD WRITES TO OTF
	POPJ P,
	PIO OTF;

$WRSYM:	TLNN F,QSMO	;$WRSYM WRITES TO OSF
	POPJ P,
	PIO OSF;
;LEXEC A, PAGE 10
;A FEW MORE USEFUL SUBROUTINES:
;INITLD--	INITIALIZE LOADER EXECUTIVE.
;EXCLOS--	CLOSE DOWN LOADER EXECUTIVE.
;INITBF--	INITIALIZE FILE BUFFERS.
;DMPSYM--	DUMP SYMBOL TABLE TO FILE.
;INITBF IS RATHER COMPLICATED:  IT DUPLICATES THE FUNCTION
;OF THE INBUF/OUTBUF UUO FOR FIXED CORE AREAS.  IT IS CALLED
;WITH A FILE BLOCK POINTER IN A.  IT GETS THE AREA TO BE
;USED AS A BUFFER FROM THE FILE BLOCK.

INITBF:	CPY FBUFH(A),FHDR(A)	;GET SOURCE BLOCK'S
		;400000,,BUF1+1 WORD AND STORE IN FILE HEADER.
	HRRZI T1,BUFSIZ(T)	;T1= BUF1+1+BUFSIZ= BUF2+1
	HRLI T1,BUFSIZ-2	;T1 NOW HAS BUFSIZ-2,,BUF2+1
	MOVEM T1,(T)	;STORE IN BUF1+1.
	HRLI T,BUFSIZ-2	;T NOW HAS BUFSIZ-2,,BUF1+1.
	MOVEM T,(T1)	;STORE IN BUF2+1.
	POPJ P,		;EXIT.

DMPSYM:	CPY SYMBEG,TMPPTR	;SET UP PTR IN SYMBOLS.
DSL:	CAML T,JOBFF	;END OF SYMBOL TABLE REACHED?
	POPJ P,		;YES, EXIT.
	MOVE A,@TMPPTR	;NO, GET NEXT SYMBOL TABLE WORD.
	PUSHJ P,$WRSYM	;OUTPUT IT.
	AOS T,TMPPTR	;ADVANCE TO NEXT SYMBOL TABLE WORD.
	JRST DSL

	EXTERN JOBHRL
EXCLOS:	CLOSE INF,	;END OF LOADING... CLOSE ALL
	CLOSE SYM,	;CHANNELS.
	CLOSE OSF,
	CLOSE OTF,
	TLNE F,QOBFIL	;WAS THERE AN OUTPUT BINARY FILE?
	PUSHJ P,OTFTST	;YES, TEST FOR CLOSE ERRORS.
	TLNE F,QSMO	;WAS THERE AN OUTPUT SYMBOL FILE?
	PUSHJ P,OSFTST	;YES, TEST FOR ERRORS.

	OUTSTR LDMSG1	;OUTPUT "LOADER " MESSAGE
	HRRZ T,JOBREL	;GET LOW SEGMENT END.
	PUSHJ P,PRDECS	;REDUCE TO DECIMAL "K" AND PRINT.
	OUTCHR ["+"]	;OUTPUT "+"
	HRRZ T,JOBHRL	;GET HIGH SEGMENT END,
	ANDI T,377777	;ELIMINATE EXTRANEOUS HIGH ORDER BIT.
	PUSHJ P,PRDECS	;REDUCE TO K AND PRINT
	OUTSTR LDMSG2	;OUTPUT "K" +CR-LF.
	POPJ P,		;EXIT.

LDMSG1:	ASCIZ /LINKER /
LDMSG2:	ASCIZ /K
/
;LEXEC A, PAGE 11
;ERROR PROCESSOR

	DEFINE ER(B,C)
<	MOVEI T,.+2
	PJRST PRERR
	ASCIZ \B\>

BADDV1:	MOVEI T,BADDEV+2	;CCL ERROR, BAD DEVICE, TYPE MESSAGE
	TLZA F,QCCL+QCCLC+QCCLU	;AND CLEAR CCL FLAGS.
BADLIN:	MOVEI T,BADCHR+2	;BAD LINE ERROR.
	PUSHJ P,PRERR	;SAME AS BAD CHARACTER, EXCEPT
	JRST NEWLIN	;DIFFERENT RETURN.

BADCHR:	ER <ILLEGAL CHARACTER 1>,NEWLIN	;ILLEGAL CHAR. IN COMMAND
BADSW:	AOS COMPTR
	ER <ILLEGAL SWITCH /1>,CPOPJ	;ILLEGAL SWITCH
NONMER:	ER <FILE NAME REQUIRED FOR 4>,CPOPJ
EROPEN:	ER <OPEN FAILURE ON FILE 3>,CPOPJ
ERENTR:	ER <ENTER FAILURE ON FILE 3>,CPOPJ
ERLKUP:	ER <LOOKUP FAILURE ON FILE 3>,CPOPJ
IOERR:	ER <I/O ERROR IN FILE 3>,CPOPJ
BADDEV:	ER <4 ILLEGAL AS 2 DEVICE>,CPOPJ
LDERRM:	ASCIZ /
?/

PRERR:	HRLI T,(POINT 7,)	;CONVERT ARG. TO BYTE POINTER.
	MOVEM T,TMPPTR	;SAVE IN CORE.
	OUTSTR LDERRM	;OUTPUT QUESTION MARK.
PRELP:	ILDB T,TMPPTR	;GET NEXT MESSAGECHAR.
	JUMPE T,CRLFST	;WHEN DONE, GO TYPE CR-LF.
	CAIL T,"1"	;IF CHARACTER IS 1-4,
	CAILE T,"4"	;GO DO SPECIAL ROUTINE.
	SKIPA
	XCT ,ERRTBL-"1"(T)
	OUTCHR T	;OTHERWISE, SIMPLY OUTPUT IT.
	JRST PRELP	;GO GET NEXT CHARACTER.

ERRTBL:	MOVE T,@COMPTR	;1= PRINT CURRENT CHARACTER.
	JRST PRFLD	;2= PRINT FIELD NAME.
	JRST PRFIL	;3= PRINT FILE NAME.
	JRST PRDEV	;4= PRINT DEVICE NAME.

PRFLD:	OUTSTR FFLD(A)	;PRINT FIELD FROM FILE BLOCK.
	JRST PRELP	;GO TO NEXT CHARACTER.

PRDEV:	MOVE T,SCNDEV	;GET CURRENT DEVICE FROM SCANNER.
	PUSHJ P,ERRSIX	;PRINT IT.
	JRST PRELP	;GO BACK.

PRFIL:	PUSHJ P,XPFIL	;GO PRINT CURRENT FILE NAME.
	JRST PRELP	;RETURN TO ERROR PROCESSOR.

CRLF:	ASCIZ /
/
;LEXEC A, PAGE 12
;TYPE FILE NAME ROUTINES.
;$PRFIL PRINTS THE NAME OF THE CURRENT FILE IF THIS HCHANGED SINCE THE LAST CALL ON $PRFIL.

	ENTRY $PRSYM,$PRFIL
$PRFIL:	MOVE T,INFBLK+FDEV	;GET THE NAME AND EXTENSION OF
	MOVE T1,INFBLK+FNAM	;THE CURRENT INPUT FILE, AS
	MOVE T2,INFBLK+FEXT	;WELL AS THE CURRENT DEVICE.
	CAME T,OLDDEV	;DO WE HAVE AN ACROSS THE BOARD MATCH
	JRST PRIDNT	;WITH THE LAST CALL?
	CAMN T1,OLDNAM	;IF NOT, PRINT FILE NAME.
	CAME T2,OLDEXT
	JRST PRIDNT
	POPJ P,		;IF SO, EXIT.

PRIDNT:	MOVEM T,OLDDEV	;NO MATCH.  SAVE NEW DEVICE, NAME, AND
	MOVEM T1,OLDNAM	;EXTENSION AS OLD DEVICE, NAME, AND
	MOVEM T2,OLDEXT	;EXTENSION.
	MOVEI A,INFBLK	;SET UP ARGUMENT AND
	PUSHJ P,XPFIL	;PRINT THE FILE NAME, AT LAST.
CRLFST:	OUTSTR CRLF	;OUTPUT CRLF.
	POPJ P,		;EXIT.

XPFIL:	MOVE T,FDEV(A)	;GET DEVICE NAME.
	CAMN T,[SIXBIT /DSK/]	;IS IT 'DSK'?
	JRST .+3	;YES, DON'T PRINT IT.
	PUSHJ P,ERRSIX	;NO, PRINT IT, FOLLOWED BY :
	OUTCHR [":"]
	SKIPN T,FNAM(A)	;GET FILE NAME.
	POPJ P,		;IF NONE, DONE.
	PUSHJ P,ERRSIX	;IF THERE, PRINT IT.
	HLLZ T,FEXT(A)	;GET EXTENSION.
	JUMPE T,CPOPJ	;IF NOT THERE, EXIT.
	OUTCHR ["."]	;OTHERWISE, PRINT IT PRECEDED BY PERIOD.
	PUSHJ P,ERRSIX
	POPJ P,		;EXIT.

$PRSYM:	MOVE T,SYMN(A)	;PRINT SYMBOL... PRINT SYM NAME.
ERRSIX:	JUMPE T,CPOPJ	;IF ALL DONE, EXIT.
	CLEAR T+1,	;ISOLATE NEXT CHARACTER.
	ROTC T,6
	ADDI T+1,40	;CONVERT TO ASCII.
	OUTCHR T+1	;OUTPUT IT.
	JRST ERRSIX	;GO ON.
;LEXEC A, PAGE 13
;DEAD PAGE
;LEXEC A, PAGE 14
;SYMBOL TABLE TYPING ROUTINES.
;TYPSYM-- TYPE ENTIRE SYMBOL TABLE
;TYPMAP-- TYPE LOAD MAP (TITLES+ENTRIES)
;TYPUND-- TYPE UNDEFINED GLOBALS (EXTERNS)

	ENTRY $PRVAL
	EXTERN WRTNOL,LEADER,NRADIX,NBITS,VALUE,WRTINT
TYPMAP:	OUTSTR MAPMSG	;MAP:  GIVE MESSAGE
	MOVSI A,QENT+QTITLE+QINT	;SET MASK TO PRINT TITLES+ENTRIES
	JRST TYPTBL

TYPSYM:	OUTSTR SYMMSG
	HRLZI A,-1	;SYMBOL TABLE:  TYPE ALL SYMBOLS.
	PJRST TYPTBL

TYPUND:	PUSHJ P,CNTUND	;COUNT UNDEFINED SYMBOLS.
	POPJ P,		;NONE, EXIT.
TYPJU:	MOVE A,$EMASK	;GET DEFN OF GLOBAL.
	TLZ A,QENT+QINT	;EXCISE ENTRY/INTERN FLAGS.

TYPTBL:	MOVEM A,MASK	;SAVE TYPING MASK.
	PUSHJ P,SSORT	;SORT THE SYMBOL TABLE IF NECESSARY.
	MOVE A,SYMBEG	;PICK UP START OF SYMBOL TABLE.
TYPLP:	CAML A,JOBFF	;END OF TABLE REACHED?
	POPJ P,	;YES, EXIT.
	MOVEM A,TMPPTR	;NO, SAVE CURRENT POINTER.
	MOVE T1,SYMF(A)	;GET SYMBOL FLAGS.
	TDNN T1,MASK	;MASK AND SEE IF ANY MATCHES.
	JRST NOPRNT	;NONE, DONT PRINT SYMBOL.
	TLNE T1,QTITLE	;IS IT A TITLE SYMBOL?
	JRST TITSYM	;YES, HANDLE SPECIALLY.
	PUSHJ P,$PRSYM	;NO, PRINT SYMBOL.
	OUTCHR ["	"]	;TAB OVER.
	MOVE A,SYMV(A)	;PRINT VALUE.
	PUSHJ P,$PRVAL
OUTSSS:	OUTSTR CRLF	;GO TO NEXT LINE.
NOPRNT:	MOVE A,TMPPTR	;GET PTR IN SYMTABLE.
	ADDI A,SYMLNT	;ADD ON SYMBOL ENTRY LENGTH.
	JRST TYPLP	;GO SEE IF END OF TABLE.

TITSYM:	OUTSTR CRLF	;TITLE SYMBOL:  SPACE DOWN 1.
	PUSHJ P,$PRSYM	;PRINT SYMBOL.
	OUTCHR [":"]	;FOLLOWED BY A :
	JRST OUTSSS	;GO RESUME NORMAL PRINT.

$PRVAL:	MOVEM A,VALUE	;SAVE VALUE.
	CPY $RADIX,NRADIX	;SET UP RADIX AND BIT FIELDS.
	CPY $BITS,NBITS
	MOVEI T,"0"	;SET UP ZERO AS LEADER.
	MOVEM T,LEADER
	PJRST WRTINT	;GO PRINT INTEGER.

PRDECS:	LSH T,-^D10
	MOVEI A,1(T)
PRDEC:	MOVEM A,VALUE
	MOVEI T,^D10	;PRINT DECIMAL: RADIX 10, BIT WIDTH 36
	MOVEM T,NRADIX
	MOVEI T,^D36
	MOVEM T,NBITS
	PJRST WRTNOL	;NO LEADING ZEROES

MAPMSG:	ASCIZ /LOADING MAP:
/
SYMMSG:	ASCIZ /SYMBOL TABLE:
/
;LEXEC A, PAGE 15
;
;SSORT-- SPECIAL SORT TO SORT LOAD MAP INTO ALPHABETICAL ORDER.
;THIS ROUTINE BREAKS THE SYMBOL TABLE DOWN INTO AREAS
;BETWEEN TITLE SYMBOLS (OR START AND END OF TABLE) AND CALLS THE
;MAIN SORT ROUTINE TO SORT EACH AREA.
;
;THE MAIN SORT ROUTINE CAN BE TOTALLY INDEPENDENT WITH RESPECT TO
;ALGORITHM, ALTHOUGH THE CALLING SEQUENCE IS FIXED.
;
SSORT:	TLZN F,QUSORT	;IS THE SYMBOL TABLE UNSORTED?
	POPJ P,		;NO, DO NOTHING.
	SKIPA ENDP,SYMBEG	;SET END POINTER FROM START OF TABLE.
L1:	ADDI ENDP,SYMLNT	;ON NEXT PASS, ADVANCE PTR TO NXT SYM.
NXTTB:	CAML ENDP,JOBFF	;HAVE WE REACHED END OF TABLE?
	POPJ P,		;ALL DONE, EXIT, IF END REACHED.
	MOVE T2,SYMF(ENDP)	;GET FLAG OF CURRENT SYMBOL.
	TLNE T2,QTITLE	;IS IT A TITLE SYMBOL?
	JRST L1		;YES, IGNORE IT.
;
;AT THIS POINT, ENDP POINTS TO A VALID (NON-TITLE) SYMBOL AND
;IS THEREFORE DECLARED TO BE THE START OF THE NEXT SORT BRACKET.
;
	SKIPA STRTP,ENDP	;SET START BRACKET TO CURRENT SYMBOL.
L2:	ADDI ENDP,SYMLNT	;ON NEXT PASS, ADVANCE TO NEXT SYM.
	CAML ENDP,JOBFF	;END OF TABLE REACHED?
	JRST DOSORT	;YES, END BRACKET IN PLACE.
	MOVE T2,SYMF(ENDP)	;GET FLAG OF CURRENT SYMBOL.
	TLNN T2,QTITLE	;IS IT A TITLE SYMBOL?
	JRST L2		;NO, CONTINUE ADVANCING END BRACKET.
;
;AT THIS POINT, ENDP POINTS TO END OF TABLE OR TERMINATING
;TITLE SYMBOL.  SORT FROM STRTP TO ENDP [STRTP,ENDP).
;
DOSORT:	PUSHJ P,RSORT	;CALL REGULAR SORT.
	JRST NXTTB	;ON TO NEXT PART OF TABLE.

	STRTP==T
	ENDP==T1	;SORT ACCUMULATORS
	SORTP==A
;LEXEC A, PAGE 16
;
;REGULAR SORT.  CALLED BY
;	STRTP POINTS TO FIRST VALID SYMBOL ENTRY
;	ENDP POINTS BEYOND LAST VALID SYMBOL ENTRY
;	PUSHJ P,RSORT
;	STRTP AND ENDP MUST BE PRESERVED.
;
;THIS IMPLEMENTATION IS A SIMPLE BUBBLE SORT.
;
RSORT:	IORI F,QINTR	;TO INITIALIZE, SET THE INTERCHANGE FLAG.
NXTPAS:	TRZN F,QINTR	;NEW PASS:  ANY INTERCHANGES ON LAST PASS?
	POPJ P,		;NO.
	MOVE SORTP,STRTP	;YES, CLEAR FLAG, SET SORT POINTER
SRTLP:	ADDI SORTP,SYMLNT	;ADVANCE TO NEXT SYMBOL.
	CAML SORTP,ENDP	;END OF TABLE REACHED?
	JRST NXTPAS	;YES, END OF PASS.
	MOVE T2,SYMN-SYMLNT(SORTP)	;NO.  GET PREVIOUS SYMBOL.
	CAMG T2,SYMN(SORTP)	;IS IT > CURRENT SYMBOL?
	JRST SRTLP	;NO, ON TO NEXT SYMBOL.
	EXCH T2,SYMN(SORTP)	;YES, EXCHANGE SYMBOL NAMES.
	MOVEM T2,SYMN-SYMLNT(SORTP)
	MOVE T2,SYMV-SYMLNT(SORTP)	;EXCHANGE SYMBOL VALUES.
	EXCH T2,SYMV(SORTP)
	MOVEM T2,SYMV-SYMLNT(SORTP)
	MOVE T2,SYMF-SYMLNT(SORTP)	;EXCHANGE SYMBOL FLAGS.
	EXCH T2,SYMF(SORTP)
	MOVEM T2,SYMF-SYMLNT(SORTP)	;DONE EXCHANGING.
	IORI F,QINTR	;SET INTERCHANGE FLAG.
	JRST SRTLP	;ON TO NEXT SYMBOL.
  ;è