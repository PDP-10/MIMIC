	TITLE	CIODCM - MIMIC CENTRAL I/O CONTROLLER
	HISEG
	SUBTTL	INTRODUCTION
;
;
;THE ENTIRE DESIGN OF CIO IS INTENDED TO STRIKE A
;REASONABLE COMPROMISE BETWEEN EFFICIENCY OF EXECUTION
;AND EASE OF USE.  WHILE PRESENTING RANDOM-ACCESS
;INTERFACES TO MIMIC AND VM DEVICE SERVICE
;ROUTINES, .READ AND .WRITE INTERNALLY ARE BIASED
;TOWARD SEQUENTIAL OPERATION.
;
;CIO COMPONENTS AND THEIR ARGUMENTS ARE:
;	.ATTAC	(.LEBLK) ATTACH UCB TO FILE/TTY
;	.DETAC	(.UCBAD) DETACH UCB FROM FILE/TTY.
;	.ACTVT	   "     SCHEDULE AN I/O OPERATION.
;	.CNCEL	   "     CANCEL AN OUTSTANDING OPERATION.
;	.TMCHK	(OM 'CLOCK') PERFORM TIMELY OPERATIONS.
;	.READ	(.UCBAD) GET A FRAME FROM A FILE/TTY.
;	.WRITE	   "     PUT A FRAME INTO A FILE/TTY.
;
;.ATTAC, .DETAC, .READ AND .WRITE HAVE NORMAL (SKIP-TYPE) AND
;ERROR (FALL-THROUGH) RETURNS.  ERRORS ARE FLAGGED BY BITS
;IN UCB STATUS.
;
;TO TRANSFER A FRAME BETWEEN A UNIT (UCB) AND CIO, PLACE THE
;NUMBER ('ADDRESS') OF THE DESIRED FRAME IN UCB FRMNUM AND
;CALL .WRITE (WITH THE DATA TO BE OUTPUT IN UCB
;FRMBFR) OR .READ AS APPPROPRIATE.
;
;CONTROLLERS OF SERIAL DEVICES LIKE PAPER TAPE READERS
;SIMPLY INCREMENT UCB FRMNUM BEFORE EACH .READ/.WRITE CALL.
;CONTROLLERS OF RANDOM-ACCESS DEVICES DO AN INITIAL JAM
;INTO FRMNUM. WITH INCREMENTING BEFORE EACH TRANSFER.
;
;AS SEEN BY THE OM, I/O GENERALLY WORKS AS FOLLOWS:
;THE OM CPU DECODES AN I/O INSTRUCTION AND JUMPS TO THE CODE
;REPRESENTING THE SIMULATED DEVICE CONTROLLER ADDRESSED.
;THE LATTER SETS UP WHATEVER INTERNAL REGISTERS IT NEEDS BUT
;IN PARTICULAR, IT ALSO SCHEDULES THE I/O OPERATION BY PLACING
;IN UCB SRVTIM THE TIME (IN OM CLOCK UNITS) AT WHICH THE
;OPERATION IS TO BE PERFORMED AND PLACING IN UCB SRVICE THE
;ADDRESS OF THE CODE REPRESENTING THAT PORTION OF THE CONTROLLER
;RESPONSIBLE FOR THE ACTUAL DATA TRANSFER.  THE CONROLLER
;THEN CALLS .ACTVT WHICH INSERTS THE UCB INTO .ACTVQ, THE
;QUEUE OF ACTIVE ('RUNNING') UNITS.  THIS QUEUE IS ORDERED BY
;INCREASING VALUES OF SRVTIM; THAT IS, IT GOES FROM 'EARLIEST'
;TO 'LATEST'.  THE DUMMY UCB USED BY SCP FOR CONSOLE I/O IS
;ALWAYS THE LAST IN .ACTVQ, WITH A TIME OF 377777777777.
;
;THE OM MAINTAINS A 'CLOCK' IN AC0 AND PERIODICALLY (NORMALLY
;EVERY CPU FETCH PHASE) CALLS .TMCHK WHICH COMPARES CURRENT
;OM TIME WITH THAT OF THE EARLIEST UCB, RETURNING IMMED-
;IATELY IF TIME .LT. .EVNTM (THE SRVTIM OF THE EARLIEST UCB).
;IF TIME .GE. .EVNTM THEN THE HEAD UCB IS REMOVED FROM
;.ACTVQ, ITS ADDRESS IS PLACED IN .UCBAD AND ITS SERVICE ROU-
;TINE IS CALLED.  THE LATTER GENERALLY WILL CALL EITHER .READ
;OR .WRITE ONE OR MORE TIMES AND THEN RETURN TO .TMCHK, WHICH
;WILL LOOP UNTIL A UCB LATER THAN CURRENT TIME IS FOUND.
;
;NOTE THAT UCB'S NEED NOT REPRESENT I/O DEVICE UNITS.
; THE SUBROUTINES .ACTVT, .CNCEL AND .TMCHK PERMIT THE
;SYNCHRONIZATION OF EXECUTION OF ANY PDP/10 CODE WITH OM
;EXECUTION.  THE DATA STRUCTURES MANIPULATED BY THESE ROUTINES
;NEED RESEMBLE UCB'S ONLY IN WORDS 0-2.
;
	SUBTTL	VARIOUS DEFINITIONS
;
;	ENTRY POINTS FOR CIO USERS.
;
	INTERN	.ATTAC
	INTERN	.DETAC
	INTERN	.ACTVT
	INTERN	.CNCEL
	INTERN	.TMCHK
	INTERN	.READ
	INTERN	.WRITE
;
;	EXTERNAL DATA IN COMMON.
;
	EXTERN	SMGR,CHLTBL,GETFAB
	EXTERN	.ACTVQ
	EXTERN	.EVNTM
	EXTERN	.FLAGS
;
;	ACCUMULATOR ASSIGNMENTS.  NOTE THAT .ATTAC AND .DETAC
;	HAVE ALL AC'S AVAILABLE, .READ AND .WRITE 'OWN' AC'S
;	10-16, AND .ACTVT, .CNCEL AND .TMCHK OWN 13-16.
;
;$
;$
;$BEWARE OF AC CONFLICTS IF YOU REASSIGN THE AC'S.
;$
;$
	CLK=0
	STK=17
	DDM=7	;USED ONLY BY .ATTAC
	UCB=10
	FAB=11
	STA=12
	UUO=13
	TA1=14
	NEW=16
	DED=15
	NXT=16
	TA2=15
	CUR=13
	TA3=16
	PRV=14
	TIM=15
	TA4=6
	TA5=7
	SUBTTL	ATTACH UCB TO FILE/TTY
;
;
;
.ATTAC:	HRRZ UCB,.UCBAD	;GET THE UCB ADDRESS.
	HRRZ DDM,UDDM(UCB)	;GET THE PARENT DDM ADDRESS.
	HLRZ STA,USTAT(UCB)	;GET THE UCB STATUS AND CLEAR
	TRZ STA,ALLERR+QBLK	;ALL ERROR BITS.
	TRNN STA,QATBL	;IS THE UCB ATTACHABLE?
	JRST ATTERR	;NO, ERROR.
	TRNN STA,QATT	;IS IT ALREADY ATTACHED (NO, SET IT)?
	JRST	DOATT		;NO.
	PUSHJ	STK,.DETAC	;YES, DETACH IT.
	POPJ STK,	;MIMIC ERROR.
	JRST .ATTAC	;BEGIN AGAIN.
DOATT:	SKIPN .LEBLK	;IS THE FILE NAME ZERO?
	JRST ATTY	;YES, GO SET "ATT TO TTY" BIT.
ATTFIL:	PUSHJ STK,GETFAB	;CREATE A FILE-ACCESS BLOCK.
	PUSHJ STK,GETCHL	;ALLOCATE A SOFTWARE CHANNEL.
	JRST NOCHNL	;NO CHANNELS, TAKE ERROR EXIT.
		;FAB PTR IS SET UP BY GETCHL.
	;
	MOVE	TA1,.LEBLK	;COPY THE FILE NAME AND EXTENSION
	MOVEM	TA1,FNAME(FAB)	;INTO THE FAB FOR USE BY THE
	HLLZ	TA1,.LEBLK+1	;CONSOLE SAVE/UNSAVE FUNCTION.
	HLLM	TA1,FEXT(FAB)
	MOVE	TA1,.LEBLK+3	;SAVE THE PROJECT#,
	MOVEM	TA1,FPJ(FAB)	;PROGRAMMER#.
	MOVE TA1,DNFRM(DDM)	;SET FAB NFRAMS FROM DDM
	MOVEM TA1,FNFRM(FAB)
	HRRZ TA1,DSIZ(DDM)	;SET FAB FRAME SIZE FROM DDM.
	HRRM TA1,FSIZ(FAB)
	HRLI TA1,-200	;FORM THE CHANNEL C OMMAND:
	HRRI TA1,FBUF+1(FAB)	;IOWD 200,BUFFER
	MOVEM TA1,FBUF(FAB)
	CLEARM ,FBUF+1(FAB)	;CLEAR WORD AFTER IOWD.
	HRLM STA,FSTAT(FAB)	;STORE FAB STATUS.
;
	CLEARM ,1(TA1)	;CLEAR THE BUFFER.
	AOBJN TA1,.-1
;
	HRLZ UUO,FCHNL(FAB)	;GET THE CHANNEL, OPEN
	HRRI	UUO,OPNBLK	;AS DISK IN DUMP MODE.
	IOR	UUO,[OPEN 0,0]
	XCT	UUO
	JRST UNKERR	;ERROR
DOLOOK:	HRLZ UUO,FCHNL(FAB)	;PERFORM A LOOKUP ON
	HRRI	UUO,.LEBLK	;THE DESIGNATED FILE.
	IOR	UUO,[LOOKUP 0,0]
	XCT	UUO
	JRST	.+2		;NO FILE OR READ PROTECTED.
	JRST	ENTFIL		;FILE EXISTS; DO ENTER ON IT.
	TRNE	STA,QRD	;IS THE DEVICE READ ONLY?
	JRST	NOFILE	;YES, DONT CREATE FOR A READ ONLY FILE.
	CLEARM	,.LEBLK+2	;CLEAR CREATION-DATE BEFORE ENTER.
	HRLZ	UUO,FCHNL(FAB)	;DO AN ENTER HERE TOO SO WE
	HRRI	UUO,.LEBLK	;CAN CREATE A FILE.
	IOR	UUO,[ENTER 0,0]
	XCT	UUO
	JRST	PROTERR	;ERROR, MUST BE PROTECTION FAILURE.
	HRRZI	TA1,^D36	;BITS/WORD TO TA1.
	HRRZ	TA2,FSIZ(FAB)	;BITS/FRAME TO TA2.
	IDIV	TA1,TA2		;GIVES FRAMES/WORD IN TA1.
	MOVE	TA2,FNFRM(FAB)	;FRAMES/UNIT TO TA2.
	IDIV	TA2,TA1		;GIVES WORDS/UNIT IN TA2.
	SKIPE	TA3		;IS THE REMAINDER NON-ZERO?
	AOS	TA2		;YES, WE NEED ANOTHER WORD.
	IDIVI	TA2,^D128	;GIVES BLOCKS/UNIT IN TA2.
	SKIPN	TA3		;IS THE REMAINDER NON-ZERO?
	SKIPN	TA2		;IS THIS NUMBER ZERO?
	AOS	TA2		;YES, MAKE IT ONE SO THAT WE WILL
	;			;WRITE AT LEAST ONE BLOCK, GIVING
	;			;SCP A FILE IT CAN BOTH READ AND
	;			;WRITE (AFTER WE OPEN AS IN/OUT).
	HRRZI	TA1,1		;INITIAL BLOCK NUMBER TO TA1.
	;			;NOTE THAT THEY GO 1-N, NOT 0-N.
WRITLP:	HRLZ	UUO,FCHNL(FAB)	;DO A USETO TO THE CURRENT BLOCK.
	HRRI	UUO,0(TA1)
	IOR	UUO,[USETO 0,0]
	XCT	UUO
	HRLZ	UUO,FCHNL(FAB)	;DO AN OUT TO CREATE THE BLOCK.
	HRRI	UUO,FBUF(FAB)
	IOR	UUO,[OUT 0,0]
	XCT	UUO
	JRST	.+2
	JRST UNKERR	;ERROR.
	AOS	TA1		;BUMP THE BLOCK NUMBER.
	SOJG	TA2,WRITLP	;HAVE WE BUILT THE ENTIRE FILE?
	HRLZ	UUO,FCHNL(FAB)	;CLOSE THE NOW-CREATED FILE.
	IOR	UUO,[CLOSE 0,0]
	XCT	UUO
	JRST	DOLOOK		;GO PRETEND IT ALWAYS EXISTED.
ENTFIL:	;HERE IF FILE PRE-EXISTED OR WAS CREATED; MACHST NICHT.
	;WE WILL DO AN ENTER SO THAT AT LEAST SCP CAN BOTH
	;READ AND WRITE IT.
	TRNE	STA,QFIX	;IS THIS A VARIABLE-CAPACITY DEVICE?
	JRST	SETBLK		;NO,FIXED; LEAVE FAB NFRAMS ALONE.
	;$
	;$
	;THIS CODE PICKS UP PIP IMAGE MODE WORD COUNT
	;AND CONVERT IT TO A FRAME COUNT.
	HLRE	TA3,.LEBLK+3	;GET THE FILE WORD COUNT.
	JUMPL TA3,.+2	;IF POSITIVE, IT IS A BLOCK COUNT.
	IMULI TA3,^D128	;WORD COUNT= BLOCK COUNT*128.
	MOVM TA3,TA3	;FORCE  THE COUNT POSITIVE.
	HRRZI TA1,^D36
	HRRZ TA2,DSIZ(DDM)
	IDIV TA1,TA2	;GIVES FRAMES/WORD
	IMUL TA1,TA3	;GIVES FRAMES/FILE
	MOVEM TA1,FNFRM(FAB)	;STORE AS FAB NFRAMS.
;
SETBLK:	TRNE STA,QRD	;IS FILE READ ONLY?
	JRST	RDONLY		;YES, DO NOT DO ENTER.
	MOVE	TA1,FPJ(FAB)	;RESTORE PROJECT", PROG#,
	MOVEM	TA1,.LEBLK+3	;CLOBBERED BY THE LOOKUP.
	HRLZ	UUO,FCHNL(FAB)	;NO, DO THE ENTER.
	HRRI	UUO,.LEBLK
	IOR	UUO,[ENTER 0,0]
	XCT	UUO
	JRST PROTERR	;ERROR, MUST BE PROTECTION.
RDONLY:	SETOM ,FFRM(FAB)	;SET FAB CURBLK TO ZERO, FAB CURFRM TO -1.
	HRRZS ,FBLK(FAB)	;THIS WILL FORCE I/O ON THE FIRST READ OR
	;WRITE, SINCE BLOCK#S RUN FROM 1-N.  FURTHER, CURFRM=-1 IMPLIES
	;THAT NO FRAME IS IN THE BUFFER.
	TROA STA,QDSK+QATT	;SET ATTACHED TO DISK BIT.
ATTY:	TRO STA,QTTY+QATT	;FOR TTY, SET ATTACHED TO TTY BIT INSTEAD.
	SETZM ,UFRM(UCB)	;CLEAR THE FRAME#.
	AOSA ,0(STK)	;SET UP SUCCESS RETURN.
ATTERR:	TRO STA,ENTAT	;ON ERROR, SET BIT BUT DONT TAKE SKIP RETURN.
	HRLM STA,USTAT(UCB)
	POPJ STK,	;EXIT.
;
NOCHNL:	TRO STA,ECHNL	;NO CHANNELS, SET ERROR BIT
	JRST ATTERR+1	;GO CLOSE UP.
UNKERR:	TRO STA,EUNK	;UNKNOWN ERROR.
	JRST DEALCC	;GO DEALLOCATE CHANNEL.
PROTERR:	TROA STA,EPROT	;PROTECTION FAILURE ERROR...
NOFILE:	TRO STA,ENOF	;NO SUCH FILE ERROR...
DEALCC:	PUSHJ STK,PUTCHL	;DEALLOCATE CHANNEL.
	JRST ATTERR+1	;GO CLOSE UP SHOP.
;
OPNBLK:	EXP	17		;UNBUFFERRED DUMP MODE D.
	SIXBIT	/DSK/		;DISK.
	XWD	0,0		;NO MONITOR-CREATED BUFFERS.
	SUBTTL	DETACH UCB FROM FILE/TTY
;
;
;
.DETAC:	HRRZ	UCB,.UCBAD	;GET THE UCB ADDRESS.
	HLRZ STA,USTAT(UCB)	;GET THE UNIT STATUS.
	TRZ STA,ALLERR	;CLEAR ALL ERROR BITS.
	TRZN STA,QATT+QDSK	;ARE WE ATTACHED TO ANYTHING (CLEAR BIT)?
	JRST DETERR	;NO.
	TRZE STA,QTTY	;ARE WEATTACHED TO A TTY?
	JRST	DETXIT		;YES, EXIT WITH THE FLAG CLEAR.
	HLRZ	FAB,UFAB(UCB)	;NO, TO DISK; GET FAB ADDRESS.
	HLRZ	TA1,FSTAT(FAB)	;GET FAB STATUS.
	TRNN	TA1,QBLK	;HAS THE CURRENT BLOCK BEEN CHANEGED?
	JRST	CLSFIL		;NO, NO NEED TO REWRITE IT.
	HLRZ	UUO,FBLK(FAB)	;YES, USETO TO THAT BLOCK.
	HRL	UUO,FCHNL(FAB)
	IOR	UUO,[USETO 0,0]
	XCT	UUO
	HRLZ	UUO,FCHNL(FAB)	;WRITE THE BLOCK BACK.
	HRRI	UUO,FBUF(FAB)
	IOR	UUO,[OUT 0,0]
	XCT	UUO
	JRST	.+2
	HALT	;ERROR.
CLSFIL:	HRLZ	UUO,FCHNL(FAB)	;NOW CLOSE THE FILE.
	IOR	UUO,[CLOSE 0,0]
	XCT	UUO
	HRLZ	UUO,FCHNL(FAB)	;RELEASE THE CHANNEL.
	IOR	UUO,[RELEASE 0,0]
	XCT	UUO
	PUSHJ STK,PUTCHL	;GIVE UP THE CHANNEL.
DETXIT:	AOSA	,0(STK)	;SET UP SKIP RETURN.
DETERR:	TRO STA,EUNAT	;ON ERROR, SET BIT.
	HRLM STA,USTAT(UCB)	;RESTORE UNIT STATUS.
	POPJ	STK,
	SUBTTL	SCHEDULE A UCB
;
;
;
	PUSHJ STK,.CNCEL	;IF ACTIVE, CANCEL THE TARGET UCB.
.ACTVT:	HRRZ NEW,.UCBAD	;GET THE ADDRESS OF THE UCB TO BE SCHEDULED.
	SKIPE ,UACT(NEW)	;IS IT CURRENTLY ACTIVE?
	JRST .ACTVT-1	;YES, GO CANCEL IT.
	MOVEI CUR,.ACTVQ	;NO, ADDRESS OF QUEUE HEADER TO CUR.
ACTNXT:	MOVE PRV,CUR	;REMEMBER POINTER WORD IN PRV.
	SKIPG CUR,UACT(CUR)	;ADVANCE TO 1ST(NEXT) QUEUE UCB.
	JRST INSERT	;IF END OF QUEUE, INSERT.
	MOVE TIM,UTIM(CUR)	;GET CURRENT UCB'S TIME.  IS
	CAMG TIM,UTIM(NEW)	;IT > THAT OF NEW UCB?
	JRST ACTNXT	;NO, ADVANCE TO NEXT QUEUE UCB.
INSERT:	MOVEM NEW,UACT(PRV)	;POINT EARLIER UCB TO NEW ONE.
	MOVEM CUR,UACT(NEW)	;POINT NEW ONE TO LATER ONE.
	HRRZ TA1,.ACTVQ	;GET ADDRESS OF NEW HEAD UCB AND
	MOVE TA1,UTIM(TA1)	;PUT ITS ASSOCIATED TIME IN .EVNTM.
	MOVEM TA1,.EVNTM
	POPJ STK,	;EXIT
	SUBTTL CANCEL A SCHEDULED UCB
;
;
;
.CNCEL:	HRRZ DED,.UCBAD	;GET ADDRESS OF "DEAD" UCB.
	MOVEI CUR,.ACTVQ	;INITIALIZE THE SEARCH LOOP BELOW.
CNCNXT:	CAMN DED,UACT(CUR)	;DOES HEADER(CURRENT UCB) POINT
	JRST FOUND	;AT DEAD ONE?  YES, GO REMOVE DEAD ONE.
	SKIPG CUR,UACT(CUR)	;NO, ADVANCE TO NEXT QUEUE UCB.
	JRST NFOUND	;END OF QUEUE, DEAD ONE WAS NOT ACTIVE.
	JRST CNCNXT	;NOT END, TRY AGAIN.
FOUND:	MOVE NXT,UACT(DED)	;GET UCB POINTED TO BY DEAD ONE.
	MOVEM NXT,UACT(CUR)	;MAKE PREVIOUS UCB POINT TO IT.
	SKIPG TA1,.ACTVQ	;ISTHE QUEUE NOW EMPTY?
	SKIPA TA1,[377777777777]	;YES, SET .EVNTM TO INFINITY.
	MOVE TA1,UTIM(TA1)	;NO, SET .EVNTM TO TIME OF HEAD UCB.
	MOVEM TA1,.EVNTM
NFOUND:	CLEARM ,UACT(DED)	;ZERO THE DEAD ONE'S LINK WORD.
	POPJ STK,	;EXIT.
	SUBTTL PROCESS ANY TIMED-OUT UCBS
;
;
;
.TMCHK:	CAML CLK,.EVNTM	;IS THE SYSTEM CLOCK PAST THE NEXT EVENT?
	SKIPG CUR,.ACTVQ	;YES, ISSTHE QUEUE EMPTY?
	POPJ STK,	;QUEUE EMPTY OR EVENT NOT DUE, EXIT.
	MOVE NXT,UACT(CUR)	;GET POINTER TO 2ND UCB AND
	MOVEM NXT,.ACTVQ	;STORE IN QUEUE HEADER.
	CLEARM ,UACT(CUR)	;ZERO THE LINK WORD OF FORMER 1ST UCB.
	MOVEM CUR,.UCBAD	;MAKE ITS ADDRESS AVAILABLE TO
			;USER SERVICE ROUTINE.
	JUMPG NXT,.+2	;IS THE QUEUE NOW EMPTY?
	SKIPA TIM,[377777777777]	;YES, SET .EVNTM TO INFINITY.
	MOVE TIM,UTIM(NXT)	;NOW, SET .EVNTM TO TIME OF HEAD UCB.
	MOVEM TIM,.EVNTM
	HRRZ TA1,USRV(CUR)	;GET SERVICE ROUTINE ADDRESS FROM
	PUSHJ STK,0(TA1)	;UCB AND CALL IT.
	JRST .TMCHK	;START OVER.
	SUBTTL TTY/FILE READ ROUTINE
;
;
;
.READ:	HRRZ	UCB,.UCBAD	;GET THE UCB ADESS.
	HLRZ	STA,USTAT(UCB)	;GET UCB STATUS.
	TRZ STA,ALLERR	;CLEAR THE ERROR FLAGS.
	TRNN STA,QATT	;IS THE UCB ATTACHED?
	JRST NTATER	;NO, ERROR EXIT.
REDATT:	TRNN	STA,QTTY	;ARE WE ATTACHED TO A TELETYPE?
	JRST	REDDSK		;NO.
;WHAT FOLLOWS IS A SIMULATION OF A TELETYPE MODEL 33/35.
REDTKB:	MOVE 	TA1,UBUF(UCB)	;YES, GET CURRENT UCB FRMBFR AND SET
	TLO	TA1,400000	;THE NO-INPUT FLAG, ANTICIPATING FAILURE.
	TTCALL	2,TA1		;GO FISHING (BUT NO I/O WAIT).
	JRST	TKBXIT		;NO LUCK, AND UUO OVERHEAD IS ENORMOUS.
	CAIE	TA1,AWRU		;GOT A BYTE!  IS IT WRU?
	JRST	NOSTOP		;NO.
	MOVSI	TA1,400000	;YES, SET THE EXTERNAL STOP BIT.
	IORM	TA1,.FLAGS	;DO NOT TRANSMIT BELL TO THE VM,
	JRST	REDTKB		;HENCE JRST REDTKB IS EASY EXIT.
NOSTOP:
IFN LEVELD,<	CAIE TA1,176	;IS THE CHARACTER ONE OF THREE
	CAIN TA1,033	;VARIETIES OF ALTMODE?
	MOVEI TA1,175	;YES, THEN CONVERT TO 175.
>
	CAIE TA1,136	;IS THE CHARACTER
	JRST TKBXIT	;UP ARROW?  NO, EXIT TO VM.
	TTCALL 0,TA1	;YES, INTERPRET AS "CONTROL-" AND
	CAIE TA1,136	;GET ANOTHER CHARACTER, USING I/O WAIT.
	TRC TA1,000100	;UNLESS ANOTHER ARRW, DO CONTROL FUNCTION.
	JRST TKBXIT	;GO STORE BUILT CHARACTER.

REDDSK:	HLRZ	FAB,UFAB(UCB)	;YES, GET THE FAB ADDRESS.
	MOVE	TA1,UFRM(UCB)	;GET UCB FRMNUM.
	CAML TA1,FNFRM(FAB)	;IS FRMNUM .LT. NFRAMS?
	JRST FRMNER	;NO, ERROR.
DOREAD:	PUSHJ	STK,SETFAB	;GO SET UP BYTPNT, BLFMCN.
	JRST NTATER+1	;ERROR, TAKE ERROR EXIT.
	ILDB	TA1,FPTR(FAB)	;FETCH THE BYTE FROM THE BUFFER,
	;			;BUMPING THE BYTE POINTER.
TKBXIT:	MOVEM	TA1,UBUF(UCB)	;STORE THE BYTE INUCB FRMBFR.
REDXIT:	AOSA ,0(STK)	;EFFECT THE SKIP.
NTATER:	TRO STA,EUNAT	;ERROR, SET UNATTACHED BIT.
	HRLM	STA,USTAT(UCB)	;STORE UNIT STATUS.
	POPJ	STK,		;EXIT.
	SUBTTL	TTY/FILE WRITE ROUTINE
;
;
;
.WRITE:	HRRZ	UCB,.UCBAD	;GET THE UCB ADDRESS.
	HLRZ	STA,USTAT(UCB)	;GET UCB STATUS.
	TRZ STA,ALLERR	;CLEAR THE ERROR FLAGS.
	TRNN STA,QATT	;ARE WE ATTACHED TO SOMETHING?
	JRST NTATER	;NO, BOMB.
	TRNN STA,QTTY	;ARE WE ATTACHED TO A TTY?
	JRST WRTDSK		;NO.
IFE LEVELD+ONLINE,<	TTCALL 1,UBUF(UCB)>	;YES, OUTPUT THE FRAME.
IFN LEVELD+ONLINE,<	TTCALL 15,UBUF(UCB)>	;IF LEVEL-D, USE IMAGE MODE.
	JRST	WRTXIT		;EXIT.
WRTDSK:	HLRZ	FAB,UFAB(UCB)	;YES, GET THE FAB ADDRESS.
	MOVE TA1,FNFRM(FAB)	;GET FAB NFRAMS.
	TRNN STA,QFIX	;IS THIS A VARIABLE CAPACITY DEVICE?
	ADDI TA1,1	;YES, REAL LIMIT IS NFRAMS+1.
	CAMGE TA1,UFRM(UCB)	;IS FRMNUM OUT OF RANGE?
	JRST FRMNER	;YES.
DOWRIT:	PUSHJ	STK,SETFAB	;GO SET UP BYTPNT, BLFMCN.
	JRST FRMNER+1	;ERROR, TAKE ERROR EXIT.
	MOVE	TA1,UBUF(UCB)	;GET THE FRAME TO BE PUT AWAY.
	IDPB	TA1,FPTR(FAB)	;STORE FRAME.
	MOVE TA1,UFRM(UCB)	;GET UCB FRMNUM.
	CAML TA1,FNFRM(FAB)	;FRMNUM=NFRAMS?
	AOS ,FNFRM(FAB)	;YES, LAST FRAME,  ADVANCE NFRAMS.
	MOVSI TA1,QBLK	;SET BLOCK CHANGED IN FAB STATUS.
	IORM TA1,FSTAT(FAB)
WRTXIT:	AOSA ,0(STK)	;EFFECT THE SKIP.
FRMNER:	TRO STA,EFRM	;ERROR, SET BIT.
	HRLM STA,USTAT(UCB)	;RESTORE UNIT STATUS.
	POPJ	STK,		;EXIT.
	SUBTTL 	INTRICATE READ/WRITE FAB SETUP ROUTINE
;
;
;
SETFAB:	PUSH	STK,7		;FOR THIS WE NEED MORE AC'S.
	PUSH	STK,6
	MOVE TA1,UFRM(UCB)	;GET UCB FRMNUM.
	CAME TA1,FFRM(FAB)	;IS IT THE SAME AS FAB CURFRM.
	JRST	WELOSE		;NO, TAKE THE LONG PATH.
	SKIPE	,FBLF(FAB)	;IS THE BYTPNT BEYOND THE BUFFER.
	JRST	SETXIT	;NO, SHORT ROUTE.
WELOSE:	;			;YES, WE MAY LOSE SOME TIME HERE.
	;HOWEVER WE GOT HERE (NON-SEQUENTIAL OPERATION, OR
	;SEQUENTIAL BUT EXHAUSTED BUFFER), WE MUST DECIDE WHICH
	;BLOCK IS NEEDED, WHETHER IT IS ALREADY IN THE BUFFER
	;AND IF NOT IN, WHETHER TO WRITE THE CURRENT BLOCK BACK
	;TO DISK AND WHETHER TO READ THE ONE WE'RE AFTER.  TOO
	;BAD FOR US IF ALL THESE THINGS MUST HAPPEN BECAUSE AS
	;PRESENTLY STRUCTURED THE MONITOR CALLS ITS SCHEDULER
	;FOR USETI/USETO, AND WE DEFINITELY GO INTO I/O WAIT
	;FOR IN OR OUT.
	HRRZI	TA1,^D36	;GET BITS/WORD.
	HRRZ	TA2,FSIZ(FAB)	;GET BITS/FRAME.
	IDIV	TA1,TA2		;GIVES FRAMES/WORD IN TA1.
	IMULI	TA1,^D128	;GIVES FRAMES/BLOCK IN TA1.
	MOVE    TA2,UFRM(UCB)	;GET UCB FRMNUM.
	IDIV	TA2,TA1		;GIVES 0-N BLOCK NUMBER IN TA2,
	;			;BLOCK-RELATIVE FRAME NUMBER IN TA3.
	ADDI	TA2,1		;PUT BLOCK NUMBER IN RANGE 1-N.
	HLRZ	TA4,FBLK(FAB)	;GET FAB CURBLK.
	CAMN	TA2,TA4		;IS THE BLOCK WE WANT IN THE BUFFER?
	JRST	BLOKIN	;YES, JUST LOVELY.
	HLRZ	TA5,FSTAT(FAB)	;NO, GET FAB STATUS.
	TRZN	TA5,QBLK	;BLOCK-CHANGED? (CLEAR IT).
	JRST	BLKRED		;NO, NO NEED TO WRITE IT BACK.
	HRLZ	UUO,FCHNL(FAB)	;YES, USETO TO CURBLK.
	HRRI	UUO,0(TA4)
	IOR	UUO,[USETO 0,0]
	XCT	UUO
	HRLZ	UUO,FCHNL(FAB)	;NOW WRITE BACK THE BLOCK.
	HRRI	UUO,FBUF(FAB)
	IOR	UUO,[OUT 0,0]
	XCT	UUO
	JRST	.+2
	JRST BADSET	;ERROR.
BLKRED:	;NOW WE MUST READ IN THE BLOCK WE WANT, ONLY IT MIGHT NOT
	;EXIST - THAT IS, IF WE ARE APPENDING A FRAME TO A
	;VARIABLE-CAPACITY DEVICE AND WE JUST FILLED  THE
	;CURRENT BUFFER THEN WE WILL ARRIVE HERE BUT MUST NOT
	;DO A READ SINCE THE 'NEXT' BLOCK DOESN'T YET EXIST
	;(WE WILL 'CREATE' IT IN CORE AND EVENTUALLY WRITE IT).
	HRLM	TA5,FSTAT(FAB)	;CLEAR BLOCK-MODIFIED WHETHER
	;			;OR NOT WE ACTUALLY READ.
	MOVE	TA4,UFRM(UCB)	;GET UCB FRMNUM.
	CAMN TA4,FNFRM(FAB)	;DOES FRMNUM= LAST FRAME?
	SKIPE ,FBLF(FAB)	;YES, IS THE LAST BLOCK EXHAUSTED?
	JRST GETBLK	;NO TO EITHER... BLOCK MUST EXIST.
	MOVE TA4,FBUF(FAB)	;YES, WE ARE AFTER THE FIRST FRAME
	CLEARM ,1(TA4)	;OF A BLOCK THAT DOESNT EXIST.  HENCE
	AOBJN TA4,.-1	;WE CLEAR THE BUFFER, CREATING A BLOCK OF
	JRST BLOKST	;ZEROES.  FOR GODS SAKE, DONT READ NOW!!
GETBLK:	HRLZ	UUO,FCHNL(FAB)	;OK TO READ; USETI TO THE RIGHT BLOCK.
	HRRI	UUO,0(TA2)
	IOR	UUO,[USETI 0,0]
	XCT	UUO
	HRLZ	UUO,FCHNL(FAB)	;NOW READ THE BLOCK.
	HRRI	UUO,FBUF(FAB)
	IOR	UUO,[IN 0,0]
	XCT	UUO
	JRST	.+2
	JRST BADSET	;ERROR.
BLOKST:	HRLM	TA2,FBLK(FAB)	;UPDATE FAB CURBLK.
BLOKIN:	;THE PROPER BLOCK WAS OR IS NOW IN THE BUFFER.  WE NOW
	;WILL SET UP THE FAB BYTE POINTER AND BLOCK FRAME COUNT.
	;REMEMBER THAT TA1 CONTAINS FRAMS/BLOCK AND THAT THE
	;BLOCK-RELATIVE FRAME NUMBER IS STILL IN TA3.  INCIDENT
	;I, TOO, FIND ALL THIS CONFUSING.  MPMCC.
	SUB	TA1,TA3		;GIVES NUMBER OF FRAME SLOTS
	;			;OPEN IN THIS BUFFER, INCLUDING
	;			;THAT FOR THE ONE WE'RE AFTER.
	MOVEM	TA1,FBLF(FAB)	;SET FAB BLFMCN.
	HRRZI	TA1,^D36	;GET BITS/WORD.
	HRRZ	TA2,FSIZ(FAB)	;GET BITS/FRAME.
	IDIV	TA1,TA2		;GIVES FRAMES/WORD IN TA1.
	HRRZ	TA2,TA3		
	IDIV	TA2,TA1		;GIVES BLOCK WORD NUMBER IN TA2.
	;			;WORD FRAM NUMBER IN TA3.
	;			;WE'LL BUILD BYTPNT IN TA2.
	ADDI	TA2,FBUF+2(FAB)	;FORM THE 'Y' FIELD.
	HRRZ	TA1,FSIZ(FAB)	;GET FRAME SIZE AGAIN.
	DPB	TA1,[POINT 6,TA2,^D11] ;SLIP IT IN AS 'S'.
	IMUL	TA1,TA3		;MULTIPLY BY WORD FRAME NUMBER.
	;			;THIS GIVES WORD BITS IN UP
	;			;TO BUT NOT INCLUDING THE FRAME
	;			;THAT THE CALLER IS AFTER.
	HRRZI	TA3,^D36	;BITS/WORD TO TA3.
	SUB	TA3,TA1		;GIVES THE PROPER 'P' VALUE.
	DPB	TA3,[POINT 6,TA2,5] ;IN IT GOES.
	MOVEM	TA2,FPTR(FAB)	;PLACE FINISHED BYTPNT IN FAB.
	;			;NOTE THAT THE POINTER IS 
	;			;INCREMENTED BY .READ/.WRITE
	;			;BEFORE LOAD/STORE.
SETXIT:	SOS ,FBLF(FAB)	;DECREMENT FAB BLFMCN TO REFLECT THIS OPERATION.
	MOVE TA1,UFRM(UCB)	;SET FAB CURFRM TO THE
	ADDI TA1,1	;FRAME #
	MOVEM TA1,FFRM(FAB)	;WILL BE ADDRESSED BY BYTPNT AFTER
	;			;.READ/.WRITE.  NOTE ALSO THAT
	;			;WE GET FRMNUM FROM THE UCB IN
	;			;CASE THIS WAS THE START OF A
	;			;RANDOM ACCESS TRANSFER.
	AOSA ,-2(STK)	;TAKE SKIP RETURN.
BADSET:	TRO STA,EUNK	;ERROR, TAKE FIRST RETURN.
	POP	STK,6
	POP	STK,7
	POPJ	STK,		;EXIT.
;
;
;OK YOU NOVICES WHO DON'T COMMENT YOUR CODE -- REMEMBER THIS
;ROUTINE, AND HOW DIFFICULT IT CAN BE TO FOLLOW EVEN WELL-
;COMMENTED SEQUENCES.  COMMENTING IS ANOTHER FORM OF THINKING
;ALOUD AND WHEN YOU GET TO BE TWENTY-SIX YOU TOO WILL NEED
;SUCH CRUTCHES.  FURTHERMORE, THINK OF THE FIX YOU'D BE IN
;IF I HADN'T HELPED YOU OUT BY THINKING ALOUD.
;
;
;CHANNEL ALLOCATION/DEALLOCATION SUBROUTINES.
;
GETCHL:	HRRZ UCB,.UCBAD	;GET THE FAB ADDRESS FROM THE UCB.
	HLRZ FAB,UFAB(UCB)
	MOVSI TA1,-^D16	;PREPARE TO SEARCH 16 WORD TABLE.
CHNLLP:	AOSN ,CHLTBL(TA1)	;-1= FREE, ANYTHING ELSE=IN USE.
	JRST CHLFND	;IF CHANNEL FOUND, FINE.
	AOBJN TA1,CHNLLP	;IF NOT, CONTINUE SEARCH. IF
	POPJ STK,	;END OF TABLE, NO CHANNELS AVAILABLE.
;
CHLFND:	LSH TA1,5	;PUT ALLOCATED CHANNEL # IN AC FIELD.
	HRRM TA1,FCHNL(FAB)
	AOS ,(STK)
	POPJ STK,
;
PUTCHL:	HRRZ UCB,.UCBAD
	HLRZ FAB,UFAB(UCB)
	HRRZ TA1,FCHNL(FAB)	;GET CHL# FROM FAB.
	LSH TA1,-5	;CONVERT FROM AC# TO TABLE ENTRY.
	SETOM ,CHLTBL(TA1)	;SET TABLE ENTRY TO "FREE".
	POPJ STK,
	END
 )7FvE