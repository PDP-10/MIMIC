	TITLE	CIODCM - MIMIC CENTRAL I/O CONTROLLER
	HISEG
	SUBTTL	INTRODUCTION
	SUBTTL	DESIGNED 1970, MIKE MCCARTHY
	SUBTTL	REVISED 5/73, R. SUPNIK
;
;
;THE ENTIRE DESIGN OF CIO IS INTENDED TO STRIKE A
;REASONABLE COMPROMISE BETWEEN EFFICIENCY OF EXECUTION
;AND EASE OF USE.  WHILE PRESENTING RANDOM-ACCESS
;INTERFACES TO MIMIC AND VM DEVICE SERVICE
;ROUTINES, .READ AND .WRITE INTERNALLY ARE BIASED
;TOWARD SEQUENTIAL OPERATION.
;
;CIO COMPONENTS AND THEIR ARGUMENTS ARE:
;	.ATTAC	(.LEBLK) ATTACH UCB TO FILE/TTY
;	.DETAC	(.UCBAD) DETACH UCB FROM FILE/TTY.
;	.ACTVT	   "     SCHEDULE AN I/O OPERATION.
;	.CNCEL	   "     CANCEL AN OUTSTANDING OPERATION.
;	.TMCHK	(OM 'CLOCK') PERFORM TIMELY OPERATIONS.
;	.READ	(.UCBAD) GET A FRAME FROM A FILE/TTY.
;	.WRITE	   "     PUT A FRAME INTO A FILE/TTY.
;
;.ATTAC, .DETAC, .READ AND .WRITE HAVE NORMAL (SKIP-TYPE) AND
;ERROR (FALL-THROUGH) RETURNS.  ERRORS ARE FLAGGED BY BITS
;IN UCB STATUS.
;
;TO TRANSFER A FRAME BETWEEN A UNIT (UCB) AND CIO, PLACE THE
;NUMBER ('ADDRESS') OF THE DESIRED FRAME IN UCB FRMNUM AND
;CALL .WRITE (WITH THE DATA TO BE OUTPUT IN UCB
;FRMBFR) OR .READ AS APPPROPRIATE.
;
;CONTROLLERS OF SERIAL DEVICES LIKE PAPER TAPE READERS
;SIMPLY INCREMENT UCB FRMNUM BEFORE EACH .READ/.WRITE CALL.
;CONTROLLERS OF RANDOM-ACCESS DEVICES DO AN INITIAL JAM
;INTO FRMNUM. WITH INCREMENTING BEFORE EACH TRANSFER.
;
;AS SEEN BY THE OM, I/O GENERALLY WORKS AS FOLLOWS:
;THE OM CPU DECODES AN I/O INSTRUCTION AND JUMPS TO THE CODE
;REPRESENTING THE SIMULATED DEVICE CONTROLLER ADDRESSED.
;THE LATTER SETS UP WHATEVER INTERNAL REGISTERS IT NEEDS BUT
;IN PARTICULAR, IT ALSO SCHEDULES THE I/O OPERATION BY PLACING
;IN UCB SRVTIM THE TIME (IN OM CLOCK UNITS) AT WHICH THE
;OPERATION IS TO BE PERFORMED AND PLACING IN UCB SRVICE THE
;ADDRESS OF THE CODE REPRESENTING THAT PORTION OF THE CONTROLLER
;RESPONSIBLE FOR THE ACTUAL DATA TRANSFER.  THE CONROLLER
;THEN CALLS .ACTVT WHICH INSERTS THE UCB INTO .ACTVQ, THE
;QUEUE OF ACTIVE ('RUNNING') UNITS.  THIS QUEUE IS ORDERED BY
;INCREASING VALUES OF SRVTIM; THAT IS, IT GOES FROM 'EARLIEST'
;TO 'LATEST'.
;
;THE OM MAINTAINS A 'CLOCK' IN AC0 AND PERIODICALLY (NORMALLY
;EVERY CPU FETCH PHASE) CALLS .TMCHK WHICH COMPARES CURRENT
;OM TIME WITH THAT OF THE EARLIEST UCB, RETURNING IMMED-
;IATELY IF TIME .LT. .EVNTM (THE SRVTIM OF THE EARLIEST UCB).
;IF TIME .GE. .EVNTM THEN THE HEAD UCB IS REMOVED FROM
;.ACTVQ, ITS ADDRESS IS PLACED IN .UCBAD AND ITS SERVICE ROU-
;TINE IS CALLED.  THE LATTER GENERALLY WILL CALL EITHER .READ
;OR .WRITE ONE OR MORE TIMES AND THEN RETURN TO .TMCHK, WHICH
;WILL LOOP UNTIL A UCB LATER THAN CURRENT TIME IS FOUND.
;
;NOTE THAT UCB'S NEED NOT REPRESENT I/O DEVICE UNITS.
; THE SUBROUTINES .ACTVT, .CNCEL AND .TMCHK PERMIT THE
;SYNCHRONIZATION OF EXECUTION OF ANY PDP/10 CODE WITH OM
;EXECUTION.  THE DATA STRUCTURES MANIPULATED BY THESE ROUTINES
;NEED RESEMBLE UCB'S ONLY IN WORDS 0-2.
;
	SUBTTL	VARIOUS DEFINITIONS
;
;	ENTRY POINTS FOR CIO USERS.
;
	INTERN	.ATTAC
	INTERN	.DETAC
	INTERN	.ACTVT
	INTERN	.CNCEL
	INTERN	.TMCHK
	INTERN	.READ
	INTERN	.WRITE
;
;	EXTERNAL DATA IN COMMON.
;
	EXTERN	SMGR,CHLTBL,GETFAB,OPNBLK
	EXTERN	.ACTVQ
	EXTERN	.EVNTM
	EXTERN	.FLAGS
;
;	ACCUMULATOR ASSIGNMENTS.  NOTE THAT .ATTAC AND .DETAC
;	HAVE ALL AC'S AVAILABLE, .READ AND .WRITE,
;	.ACTVT, .CNCEL AND .TMCHK OWN 13-16.
;
;
CLK=0	;VM TIMER
STK=17	;PDL
DDM=12	;USED ONLY BY .ATTAC
UUO=6	;USED BY .DETAC, .ATTAC, SETFAB
UCB=13	;USED BY ALL
FAB=14
STA=15
CUR=13	;.TMCHK	.CNCEL	.ACTVT
NXT=14	;.TMCHK	.CNCEL
TIM=15	;.TMCHK		.ACTVT
DED=15	;	.CNCEL
NEW=14	;		.ACTVT
PRV=16	;		.ACTVT
TA1=7	;.ATTAC	.DETAC	SETFAB
TA2=10	;.ATTAC	.DETAC	SETFAB
TA3=11	;.ATTAC	.DETAC	SETFAB
TA4=12	;		SETFAB
TA5=16	;UNIVERSAL TEMPORARY
	SUBTTL	ATTACH UCB TO FILE/TTY
;
;.ATTAC MAKES A CONNECTION BETWEEN A UCB (IN .UCBAD) AND A FILE/TTY
;SPECIFIED IN .LEBLK.  IT DETACHES ANY ATTACHED
;FILES, ALLOCATES A CHANNEL AND FAB FOR THE UCB, AND SETS UP THE
;FAB IN A 'FIRST I/O' STATE.
;
DODET:	PUSHJ STK,.DETAC	;ATTACHED?  DETACH WHATEVER IS THERE.
	POPJ STK,		;DETACH FAILED, DIE.
.ATTAC:	HRRZ UCB,.UCBAD	;GET THE UCB ADDRESS.
	HRRZ DDM,UDDM(UCB)	;GET THE PARENT DDM ADDRESS.
	HLRZ STA,USTAT(UCB)	;GET THE UCB STATUS AND CLEAR
	ANDCMI STA,ALLERR+QBLK	;ALL ERROR BITS.
	TRNN STA,QATBL	;IS THE UCB ATTACHABLE?
	JRST ATTERR	;NO, ERROR.
	TRNE STA,QATT	;IS IT ALREADY ATTACHED?
	JRST DODET	;YES, GO DETACH IT.
;
DOATT:	SKIPN .LEBLK	;IS THE FILE NAME ZERO?
	JRST ATTY	;YES, GO SET "ATT TO TTY" BIT.
ATTFIL:	PUSHJ STK,GETFAB	;CREATE A FILE-ACCESS BLOCK.
	PUSHJ STK,GETCHL	;ALLOCATE A SOFTWARE CHANNEL.
	JRST NOCHNL	;NO CHANNELS, TAKE ERROR EXIT.
			;FAB PTR IS SET UP BY GETCHL.
	;
	MOVE TA1,.LEBLK	;COPY THE FILE NAME AND EXTENSION
	MOVEM TA1,FNAME(FAB)	;INTO THE FAB FOR USE BY THE
	HLLZ TA1,.LEBLK+1	;CONSOLE SAVE/UNSAVE FUNCTION.
	HLLM TA1,FEXT(FAB)
	MOVE TA1,.LEBLK+3	;SAVE THE PROJECT#,
	MOVEM TA1,FPJ(FAB)	;PROGRAMMER#.
	HRRZ TA1,DSIZ(DDM)	;SET FAB FRAME SIZE FROM DDM.
	HRRM TA1,FSIZ(FAB)
	LSH TA1,6		;USE ALSO AS 'P' FIELD OF BYTE POINTER.
	HRLZM TA1,FPTR(FAB)
	HRLI TA1,-200	;FORM THE CHANNEL C OMMAND:
	HRRI TA1,FBUF+1(FAB)	;IOWD 200,BUFFER
	MOVEM TA1,FBUF(FAB)
	CLEARM ,FBUF+1(FAB)	;CLEAR WORD AFTER IOWD.
	HRLM STA,FSTAT(FAB)	;STORE FAB STATUS.
	CLEARM ,1(TA1)	;CLEAR THE BUFFER.
	AOBJN TA1,.-1
;
	HRLZ UUO,FCHNL(FAB)	;GET THE CHANNEL, OPEN
	HRRI UUO,OPNBLK	;AS DISK IN DUMP MODE.
	TLO UUO,(OPEN 0,0)
	XCT UUO
	JRST UNKERR	;ERROR
DOLOOK:	HRLZ UUO,FCHNL(FAB)	;PERFORM A LOOKUP ON
	HRRI UUO,.LEBLK	;THE DESIGNATED FILE.
	TLO UUO,(LOOKUP 0,0)
	XCT UUO
	JRST .+2	;NO FILE OR READ PROTECTED.
	JRST ENTFIL	;FILE EXISTS; DO ENTER ON IT.
	TRNE STA,QRD	;IS THE DEVICE READ ONLY?
	JRST NOFILE	;YES, DONT CREATE FOR A READ ONLY FILE.
	CLEARM ,.LEBLK+2	;CLEAR CREATION-DATE BEFORE ENTER.
	HRLZ UUO,FCHNL(FAB)	;DO AN ENTER HERE TOO SO WE
	HRRI UUO,.LEBLK	;CAN CREATE A FILE.
	TLO UUO,(ENTER 0,0)
	XCT UUO
	JRST PROTERR	;ERROR, MUST BE PROTECTION FAILURE.
	OUTSTR NEWMSG	;TELL THE USER OF NEW FILE.
	HRLZ UUO,FCHNL(FAB)	;CLOSE THE NOW-CREATED FILE.
	TLO UUO,(CLOSE 0,0)
	XCT UUO
	JRST DOLOOK	;GO PRETEND IT ALWAYS EXISTED.
;
;HERE IF FILE PRE-EXISTED OR WAS CREATED; MACHST NICHT.
;WE WILL DO AN ENTER SO THAT AT LEAST SCP CAN BOTH
;READ AND WRITE IT.
;
;THIS CODE PICKS UP PIP IMAGE MODE WORD COUNT AND CONVERTS IT A 
;FRAME COUNT.
;
ENTFIL:	HLRE TA3,.LEBLK+3	;GET THE FILE WORD COUNT.
	JUMPL TA3,.+2	;IF POSITIVE, IT IS A BLOCK COUNT.
	IMULI TA3,^D128	;WORD COUNT= BLOCK COUNT*128.
	MOVM TA3,TA3	;FORCE  THE COUNT POSITIVE.
	HRRZI TA1,^D36
	HRRZ TA2,DSIZ(DDM)
	IDIV TA1,TA2	;GIVES FRAMES/WORD
	IMUL TA1,TA3	;GIVES FRAMES/FILE
	TRNE STA,QFIX	;IF FIXED CAPACITY, USE
	MOVE TA1,DNFRM(DDM)	;DDM NFRAMES.
	MOVEM TA1,FNFRM(FAB)	;STORE AS FAB NFRAMS.
;
SETBLK:	TRNE STA,QRD	;IS FILE READ ONLY?
	JRST RDONLY		;YES, DO NOT DO ENTER.
	MOVE TA1,FPJ(FAB)	;RESTORE PROJECT", PROG#,
	MOVEM TA1,.LEBLK+3	;CLOBBERED BY THE LOOKUP.
	HRLZ UUO,FCHNL(FAB)	;NO, DO THE ENTER.
	HRRI UUO,.LEBLK
	TLO UUO,(ENTER 0,0)
	XCT UUO
	JRST PROTERR	;ERROR, MUST BE PROTECTION.
RDONLY:	SETOM ,FFRM(FAB)	;SET FAB CURBLK TO ZERO, FAB CURFRM TO -1.
	HRRZS ,FBLK(FAB)	;THIS WILL FORCE I/O ON THE FIRST READ OR
	;WRITE, SINCE BLOCK#S RUN FROM 1-N.  FURTHER, CURFRM=-1 IMPLIES
	;THAT NO FRAME IS IN THE BUFFER.
	TROA STA,QDSK+QATT	;SET ATTACHED TO DISK BIT.
ATTY:	IORI STA,QTTY+QATT	;FOR TTY, SET ATTACHED TO TTY BIT INSTEAD.
	SETZM ,UFRM(UCB)	;CLEAR THE FRAME#.
	AOSA ,0(STK)	;SET UP SUCCESS RETURN.
ATTERR:	IORI STA,ENTAT	;ON ERROR, SET BIT BUT DONT TAKE SKIP RETURN.
	HRLM STA,USTAT(UCB)
	POPJ STK,	;EXIT.
;
NOCHNL:	IORI STA,ECHNL	;NO CHANNELS, SET ERROR BIT
	JRST ATTERR+1	;GO CLOSE UP.
UNKERR:	IORI STA,EUNK	;UNKNOWN ERROR.
	JRST DEALCC	;GO DEALLOCATE CHANNEL.
PROTER:	TROA STA,EPROT	;PROTECTION FAILURE ERROR...
NOFILE:	IORI STA,ENOF	;NO SUCH FILE ERROR...
DEALCC:	PUSHJ STK,PUTCHL	;DEALLOCATE CHANNEL.
	JRST ATTERR+1	;GO CLOSE UP SHOP.
;
NEWMSG:	ASCIZ /[CREATING NEW FILE]
/
	SUBTTL	DETACH UCB FROM FILE/TTY
;
;.DETAC BREAKS THE CONNECTION BETWEEN A UCB AND A FILE/TTY.
;IT HAS THE SAME CALLING SEQUENCE AND AC USAGES OF .ATTAC
;
.DETAC:	HRRZ	UCB,.UCBAD	;GET THE UCB ADDRESS.
	HLRZ STA,USTAT(UCB)	;GET THE UNIT STATUS.
	ANDCMI STA,ALLERR	;CLEAR ALL ERROR BITS.
	TRZN STA,QATT+QDSK	;ARE WE ATTACHED TO ANYTHING (CLEAR BIT)?
	JRST DETERR	;NO.
	TRZE STA,QTTY	;ARE WEATTACHED TO A TTY?
	JRST DETXIT		;YES, EXIT WITH THE FLAG CLEAR.
	HLRZ FAB,UFAB(UCB)	;NO, TO DISK; GET FAB ADDRESS.
	HLRZ TA1,FSTAT(FAB)	;GET FAB STATUS.
	TRNN TA1,QBLK	;HAS THE CURRENT BLOCK BEEN CHANEGED?
	JRST CLSFIL		;NO, NO NEED TO REWRITE IT.
	HLRZ UUO,FBLK(FAB)	;YES, USETO TO THAT BLOCK.
	HRL UUO,FCHNL(FAB)
	TLO UUO,(USETO 0,0)
	XCT UUO
	HRLZ UUO,FCHNL(FAB)	;WRITE THE BLOCK BACK.
	HRRI UUO,FBUF(FAB)
	TLO UUO,(OUT 0,0)
	XCT UUO
	JRST .+2
	HALT ;ERROR.
CLSFIL:	HRLZ UUO,FCHNL(FAB)	;NOW CLOSE THE FILE.
	TLO UUO,(CLOSE 0,0)
	XCT UUO
	HRLZ UUO,FCHNL(FAB)	;RELEASE THE CHANNEL.
	TLO UUO,(RELEASE 0,0)
	XCT UUO
	PUSHJ STK,PUTCHL	;GIVE UP THE CHANNEL.
DETXIT:	AOSA ,0(STK)	;SET UP SKIP RETURN.
DETERR:	IORI STA,EUNAT	;ON ERROR, SET BIT.
	HRLM STA,USTAT(UCB)	;RESTORE UNIT STATUS.
	POPJ STK,
	SUBTTL SCHEDULE A UCB
;
;.ACTVT IS CALLED TO INSERT A UNIT IN THE ACTIVE QUEUE.  THE
;UNIT IN .UCBAD IN INSERTED ACCORDING TO ITS SPECIFIED TIMEOUT.
;.EVNTM IS UPDATED AS NECESSARY.  USES ONLY AC'S 13-16.
;
	PUSHJ STK,.CNCEL	;IF ACTIVE, CANCEL THE TARGET UCB.
.ACTVT:	HRRZ NEW,.UCBAD	;GET THE ADDRESS OF THE UCB TO BE SCHEDULED.
	SKIPE ,UACT(NEW)	;IS IT CURRENTLY ACTIVE?
	JRST .ACTVT-1	;YES, GO CANCEL IT.
	MOVEI CUR,.ACTVQ	;NO, ADDRESS OF QUEUE HEADER TO CUR.
ACTNXT:	MOVE PRV,CUR	;REMEMBER POINTER WORD IN PRV.
	SKIPG CUR,UACT(CUR)	;ADVANCE TO 1ST(NEXT) QUEUE UCB.
	JRST INSERT	;IF END OF QUEUE, INSERT.
	MOVE TIM,UTIM(CUR)	;GET CURRENT UCB'S TIME.  IS
	CAMG TIM,UTIM(NEW)	;IT > THAT OF NEW UCB?
	JRST ACTNXT	;NO, ADVANCE TO NEXT QUEUE UCB.
INSERT:	MOVEM NEW,UACT(PRV)	;POINT EARLIER UCB TO NEW ONE.
	MOVEM CUR,UACT(NEW)	;POINT NEW ONE TO LATER ONE.
	HRRZ TA5,.ACTVQ	;GET ADDRESS OF NEW HEAD UCB AND
	MOVE TA5,UTIM(TA5)	;PUT ITS ASSOCIATED TIME IN .EVNTM.
	MOVEM TA5,.EVNTM
	POPJ STK,	;EXIT
	SUBTTL CANCEL A UCB
;
;.CNCEL IS CALLED TO REMOVE A UNIT FROM THE ACTIVE QUEUE.  USES
;ONLY AC'S 13-16
;
.CNCEL:	HRRZ DED,.UCBAD	;GET ADDRESS OF "DEAD" UCB.
	MOVEI CUR,.ACTVQ	;INITIALIZE THE SEARCH LOOP BELOW.
CNCNXT:	CAMN DED,UACT(CUR)	;DOES HEADER(CURRENT UCB) POINT
	JRST FOUND	;AT DEAD ONE?  YES, GO REMOVE DEAD ONE.
	SKIPG CUR,UACT(CUR)	;NO, ADVANCE TO NEXT QUEUE UCB.
	JRST NFOUND	;END OF QUEUE, DEAD ONE WAS NOT ACTIVE.
	JRST CNCNXT	;NOT END, TRY AGAIN.
FOUND:	MOVE NXT,UACT(DED)	;GET UCB POINTED TO BY DEAD ONE.
	MOVEM NXT,UACT(CUR)	;MAKE PREVIOUS UCB POINT TO IT.
	SKIPG TA5,.ACTVQ	;ISTHE QUEUE NOW EMPTY?
	SKIPA TA5,[377777777777]	;YES, SET .EVNTM TO INFINITY.
	MOVE TA5,UTIM(TA5)	;NO, SET .EVNTM TO TIME OF HEAD UCB.
	MOVEM TA5,.EVNTM
NFOUND:	CLEARM ,UACT(DED)	;ZERO THE DEAD ONE'S LINK WORD.
	POPJ STK,	;EXIT.
	SUBTTL PROCESS ANY TIMED OUT UCBS
;
;.TMCHK IS CALLED BY THE VM TO CHECK FOR TIMED OUT EVENTS.  IT
;REMOVES ANY TIMED OUT UCB FROM THE ACTIVE QUEUE AND CALLS THE
;SPECIFIED SERVICE ROUTINE.  USES ONLY AC'S 13-16.
;
.TMCHK:	CAML CLK,.EVNTM	;IS THE SYSTEM CLOCK PAST THE NEXT EVENT?
	SKIPG CUR,.ACTVQ	;YES, ISSTHE QUEUE EMPTY?
	POPJ STK,	;QUEUE EMPTY OR EVENT NOT DUE, EXIT.
	MOVE NXT,UACT(CUR)	;GET POINTER TO 2ND UCB AND
	MOVEM NXT,.ACTVQ	;STORE IN QUEUE HEADER.
	CLEARM ,UACT(CUR)	;ZERO THE LINK WORD OF FORMER 1ST UCB.
	MOVEM CUR,.UCBAD	;MAKE ITS ADDRESS AVAILABLE TO
			;USER SERVICE ROUTINE.
	JUMPG NXT,.+2	;IS THE QUEUE NOW EMPTY?
	SKIPA TIM,[377777777777]	;YES, SET .EVNTM TO INFINITY.
	MOVE TIM,UTIM(NXT)	;NOW, SET .EVNTM TO TIME OF HEAD UCB.
	MOVEM TIM,.EVNTM
	HRRZ TA5,USRV(CUR)	;GET SERVICE ROUTINE ADDRESS FROM
	PUSHJ STK,0(TA5)	;UCB AND CALL IT.
	JRST .TMCHK	;START OVER.
	SUBTTL FILE/TTY READ ROUTINE
;
;.READ IS CALLED TO READ THE NEXT DATA ITEM, IF ANY, INTO A UCB
;BUFFER FROM AN ATTACHED FILE OR TTY.
;.READ USES ONLY AC'S 13-16.
;
.READ:	HRRZ UCB,.UCBAD	;GET THE UCB ADDRESS.
	HLRZ STA,USTAT(UCB)	;GET THE UCB STATUS.
	ANDCMI STA,ALLERR	;CLEAR ALL ERROR FLAGS.
	TRNN STA,QATT	;IS THE UCB ATTACHED?
	JRST NTATER	;NO, ERROR.
	TRNE STA,QTTY	;YES, TO DISK?
	JRST REDTTY	;NO, GO SIMULATE TTY.
;
REDDSK:	HLRZ FAB,UFAB(UCB)	;GET THE FAB ADDRESS.
	MOVE TA5,UFRM(UCB)	;GET UCB FRAME#.
	CAML TA5,FNFRM(FAB)	;IS FRMNUM .LT. NFRAMS?
	JRST FRMNER	;NO, ERROR.
	PUSHJ STK,SETFAB	;SET UP BYTE POINTER.
	JRST NTATER+1	;ERROR?  DIE.
	ILDB TA5,FPTR(FAB)	;GET BYTE FROM BUFFER.
TKBXIT:	MOVEM TA5,UBUF(UCB)	;STORE BYTE IN UCB BUFFER.
	AOSA ,0(STK)
NTATER:	IORI STA,EUNAT	;UNATTACHED ERROR--SET FLAG
	HRLM STA,USTAT(UCB)	;STORE REVISED STATUS.
	POPJ STK,
;
REDTTY:	MOVE TA5,UBUF(UCB)	;TTY SIMULATION-- GET CURRENT CONTENTS
	TLO TA5,400000	;AND SET NO INPUT FLAG.
	INCHRS TA5	;GO FISHING.
	JRST TKBXIT	;NO LUCK, AND OVERHEAD IS ENORMOUS.
	CAIE TA5,AWRU	;GOT A BYTE!  IS IT WRU?
	JRST NOSTOP	;NO.
	MOVSI TA5,WRUFLG	;YES, SET STOP FLAG FOR VM.
	IORM TA5,.FLAGS
	JRST REDTTY	;TRY FOR MORE INPUT.
;
NOSTOP:	CAIE TA5,"^"	;IS CHARACTER UPARROW?
	JRST TKBXIT	;NO, GIVE TO VM.
	INCHRW TA5	;YES, CONTROL CHAR SIMULATION.  WAIT FOR PART 2.
	CAIE TA5,"^"
	XORI TA5,100	;DO CONTROL FUNCTION UNLESS ANOTHER UPARROW.
	JRST TKBXIT
	SUBTTL TTY/FILE WRITE ROUTINE
;
;.WRITE IS THE ANALOG OF .READ FOR OUTPUT TO A FILE/TTY.  ONLY
;AC'S 13-16 ARE USED
;
.WRITE:	HRRZ UCB,.UCBAD	;GET THE UCB ADDR.
	HLRZ STA,USTAT(UCB)	;GET THE UCB STATUS.
	ANDCMI STA,ALLERR	;CLEAR ALL ERROR FLAGS.
	TRNN STA,QATT	;ATTACHED?
	JRST NTATER	;NO, ERROR.
	TRNN STA,QDSK	;YES, TO DISK?
	JRST WRTTTY	;NO, TO TTY.
WRTDSK:	HLRZ FAB,UFAB(UCB)	;GET FAB ADDRESS.
	MOVE TA5,FNFRM(FAB)	;GET ACTUAL NUMBER OF FRAMES.
	TRNN STA,QFIX	;ON VARIABLE CAPACITY, ALLOW MORE.
	ADDI TA5,1	;1 MORE TO BE EXACT.
	CAMG TA5,UFRM(UCB)	;IS REQUESTED FRAME# VALID?
	JRST FRMNER	;NO, ERROR
	PUSHJ STK,SETFAB	;SET UP BYTE POINTER.
	JRST FRMNER+1	;ERROR?
	MOVE TA5,UBUF(UCB)	;GET BYTE AND WRITE IT.
	IDPB TA5,FPTR(FAB)
	MOVSI TA5,QBLK	;MARK BLOCK AS MODIFIED.
	IORM TA5,FSTAT(FAB)
	MOVE TA5,UFRM(UCB)	;GET UCB FRAME NUMBER.
	CAML TA5,FNFRM(UCB)	;DID WE EXTEND FILE?
	AOS ,FNFRM(UCB)	;THEN MARK AS EXTENDED.
WRTXIT:	AOSA ,0(STK)
FRMNER:	IORI STA,EFRM	;FRAME# ERROR, MARK IT SO.
	HRLM STA,USTAT(UCB)	;STORE REVISED STATUS.
	POPJ STK,
;
WRTTTY:
IFE LEVELD+ONLINE,<	TTCALL 1,UBUF(UCB)>
IFN LEVELD+ONLINE,<	TTCALL 15,UBUF(UCB)>
	JRST WRTXIT
	SUBTTL READ/WRITE FAB SETUP ROUTINE
;
;SETFAB HANDLES ALL THE DIRTY WORK FOR .READ/.WRITE.  ITS MAIN
;FUNCTION IS TO MAKE SURE THAT THE BYTE POINTER IN THE FAB POINTS
;TO THE BYTE SPECIFIED BY UCB FRAME NUMBER.
;
;ON ITS LONG PATH, SETFAB SAVES AND RESTORES AC'S
;6-12, SO THAT IT STILL ONLY USES 13-16.
;
SETFAB:	MOVE TA1,UFRM(UCB)	;GET UCB FRAME NUMBER.
	CAMN TA1,FFRM(FAB)	;SAME AS EXPECTED FRAME NUMBER?
	SKIPN ,FBLF(FAB)	;YES, AT END OF BUFFER.
	JRST WELOSE		;NO TO EITHER, WE LOSE.
;
SHORTP:	SOS ,FBLF(FAB)	;SHORT PATH.... DECREMENT # FRAMES LEFT.
	AOS ,FFRM(FAB)	;INCREMENT TARGET FRAME#.
	AOS ,(STK)	;SET UP STKIP RETURN.
	POPJ STK,
;
;WASN'T THAT EASY?  LOOK WHAT FOLLOWS---
;
WELOSE:	PUSH STK,12	;SAVE AC'S 6-12.  WE NEED ALL WE CAN GET.
	PUSH STK,11
	PUSH STK,10
	PUSH STK,7
	PUSH STK,6
;
	HRRZI TA1,^D36	;GET BITS/WORD.
	HRRZ TA2,FSIZ(FAB)	;GET BITS/FRAME.
	IDIVI TA1,(TA2)	;GIVES FRAMES/WORD IN TA1.
	LSH TA1,7	;GIVES FRAMES/PDP-10 BLOCK IN TA1.
	MOVE TA2,UFRM(UCB)	;GET UCB FRAME NUMBER.
	IDIVI TA2,(TA1)	;GIVES 0-(N-1) BLOCK# IN TA2, BLOCK RELATIVE
			;FRAME NUMBER IN TA3.
	ADDI TA2,1	;PUT BLOCK NUMBER IN RANGE 1-N.
	HLRZ TA4,FBLK(FAB)	;GET CURRENT BLOCK.
	CAIN TA2(TA4)	;SAME AS ONE WE WANT?
	JRST BLOKIN	;SKIP REWRITE/READ SEQUENCE.
	HLRZ TA5,FSTAT(FAB)	;NO, GET FAB STATUS.
	TRZN TA5,QBLK	;BLOCK MODIFIED?
	JRST BLKRED	;NO, SKIP REWRITE SEQUENCE.
;
;AT THIS POINT--
;TA1=	#FRAMES/BLOCK
;TA2=	DESIRED BLOCK
;TA3=	BLOCK RELATIVE FRAME NUMBER
;TA4=	CURRENT BLOCK
;TA5=	FAB STATUS
;
	HRLZ UUO,FCHNL(FAB)	;BUILD USETO UUO
	HRRI UUO,0(TA4)	;TO CURRENT BLOCK.
	TLO UUO,(USETO 0,0)
	XCT UUO
	HRLZ UUO,FCHNL(FAB)	;BUILD OUT UUO
	HRRI UUO,FBUF(FAB)
	TLO UUO,(OUT 0,0)	;FOR CURRENT BUFFER.
	XCT UUO
	JRST .+2	;OK?
	JRST BADSET	;NO, ERROR.
;
BLKRED:	HRLM TA5,FSTAT(FAB)	;STORE REVISED STATUS IN FAB.
	HRLZ UUO,FCHNL(FAB)	;BUILD USETI TO DESIRED BLOCK.
	HRRI UUO,0(TA2)
	TLO UUO,(USETI 0,0)
	XCT UUO
	HRLZ UUO,FCHNL(FAB)	;BUILD IN TO CURRENT BUFFER.
	HRRI UUO,FBUF(FAB)
	TLO UUO,(IN 0,0)
	XCT UUO
	JRST BLOKST	;OK?
	HRLZ UUO,FCHNL(FAB)	;NOT OK, BUILD STATO 20000
	TLO UUO,(STATO 0,0)	;TO TEST FOR END OF FILE.
	HRRI UUO,020000
	XCT UUO
	JRST BADSET	;ANY OTHER ERROR, DIE.
	MOVE TA4,FBUF(FAB)	;NO, GET XWD -COUNT/POINTER AND
	SETZM ,1(TA4)	;CLEAR THE BUFFER IN LIEU OF READ.
	AOBJN TA4,.-1
;
BLOKST:	HRLM TA2,FBLK(FAB)	;STORE NEW BLOCK AS CURRENT.
BLOKIN:
;
;WITH THE PROPER BLOCK NOW IN MEMORY, WE MUST CALCULATE THE
;BYTE POINTER TO THE PROPER BYTE.  AT THIS POINT,
; TA1=	FRAMES/BLOCK
; TA3=	BLOCK RELATIVE FRAME NUMBER (STILL)
;THE BYTE POINTER CONSISTS OF THREE FIELDS--
; BITS 0-5	P (OFFSET)
; BITS 6-11	S (SIZE) SET BY .ATTAC
; BITS 19-35	A (ADDRESS)
;
	SUB TA1,TA3	;COMPUTE NUMBER OF BYTES REMAINING IN BLOCK.
	MOVEM TA1,FBLF(FAB)	;STORE IN FAB.
	ADD TA1,TA3	;RECOVER FRAMES/BLOCK AND
	LSH TA1,-7	;GET BACK FRAMES/WORD.
	IDIVI TA3,(TA1)	;GIVES BLOCK RELATIVE WORD# IN TA3,
	ADDI TA3,FBUF+2(FAB)	;TA4 BYTE# WITHIN WORD.
	HRRM TA3,FPTR(FAB)	;WE NOW HAVE ADDRESS FIELD!
	HRRZ TA1,FSIZ(FAB)	;GET FRAME SIZE* RELATIVE BYTE NUMBER.
	IMULI TA1,(TA4)
	HRRZI TA3,^D36	;COMPUTE OFFSET FROM 36 AND
	SUB TA3,TA1
	DPB TA3,[POINT 6,FPTR(FAB),5]	;AND STORE IN P FIELD.
;ALL DONE
;
	SOS ,FBLF(FAB)	;DECREMENT BYTES REMAINING.
	MOVE TA1,UFRM(UCB)	;TARGET NEXT TIME IS ONE MORE THAN
	ADDI TA1,1
	MOVEM TA1,FFRM(FAB)	;TARGET THIS TIME.
	AOSA ,-5(STK)		;SET UP SKIP RETURN.
BADSET:	IORI STA,EUNK		;ANY SETFAB ERROR IS BAD SHIT.
	POP STK,6		;POP AC'S 6-12.
	POP STK,7
	POP 0
	POP STK,11
	POP STK,12
	POPJ STK,
;CHANNEL ALLOCATION/DEALLOCATION SUBROUTINES.
;
GETCHL:	HRRZ UCB,.UCBAD	;GET THE FAB ADDRESS FROM THE UCB.
	HLRZ FAB,UFAB(UCB)
	MOVSI TA1,-^D16	;PREPARE TO SEARCH 16 WORD TABLE.
CHNLLP:	AOSN ,CHLTBL(TA1)	;-1= FREE, ANYTHING ELSE=IN USE.
	JRST CHLFND	;IF CHANNEL FOUND, FINE.
	AOBJN TA1,CHNLLP	;IF NOT, CONTINUE SEARCH. IF
	POPJ STK,	;END OF TABLE, NO CHANNELS AVAILABLE.
;
CHLFND:	LSH TA1,5	;PUT ALLOCATED CHANNEL # IN AC FIELD.
	HRRM TA1,FCHNL(FAB)
	AOS ,(STK)
	POPJ STK,
;
PUTCHL:	HRRZ UCB,.UCBAD
	HLRZ FAB,UFAB(UCB)
	HRRZ TA1,FCHNL(FAB)	;GET CHL# FROM FAB.
	LSH TA1,-5	;CONVERT FROM AC# TO TABLE ENTRY.
	SETOM ,CHLTBL(TA1)	;SET TABLE ENTRY TO "FREE".
	POPJ STK,
	END
A@b